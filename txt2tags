#!/usr/bin/env python
# txt2tags - generic text conversion tool
# http://txt2tags.org
#
# Copyright 2001-2013 Aurelio Jargas
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# License: http://www.gnu.org/licenses/gpl-2.0.txt
# Subversion: http://svn.txt2tags.org
# Bug tracker: http://bugs.txt2tags.org
#
########################################################################
#
#   BORING CODE EXPLANATION AHEAD
#
# Just read it if you wish to understand how the txt2tags code works.
#
########################################################################
#
# The code that [1] parses the marked text is separated from the
# code that [2] insert the target tags.
#
#   [1] made by: def convert()
#   [2] made by: class BlockMaster
#
# The structures of the marked text are identified and its contents are
# extracted into a data holder (Python lists and dictionaries).
#
# When parsing the source file, the blocks (para, lists, quote, table)
# are opened with BlockMaster, right when found. Then its contents,
# which spans on several lines, are feeded into a special holder on the
# BlockMaster instance. Just when the block is closed, the target tags
# are inserted for the full block as a whole, in one pass. This way, we
# have a better control on blocks. Much better than the previous line by
# line approach.
#
# In other words, whenever inside a block, the parser *holds* the tag
# insertion process, waiting until the full block is read. That was
# needed primary to close paragraphs for the XHTML target, but
# proved to be a very good adding, improving many other processing.
#
# -------------------------------------------------------------------
#
# These important classes are all documented:
# CommandLine, SourceDocument, ConfigMaster, ConfigLines.
#
# There is a RAW Config format and all kind of configuration is first
# converted to this format. Then a generic method parses it.
#
# These functions get information about the input file(s) and take
# care of the init processing:
# get_infiles_config(), process_source_file() and convert_this_files()
#
########################################################################

#XXX Python coding warning
# Avoid common mistakes:
# - do NOT use newlist=list instead newlist=list[:]
# - do NOT use newdic=dic   instead newdic=dic.copy()
# - do NOT use dic[key]     instead dic.get(key)
# - do NOT use del dic[key] without key in dic before

#XXX Smart Image Align don't work if the image is a link
# Can't fix that because the image is expanded together with the
# link, at the linkbank filling moment. Only the image is passed
# to parse_images(), not the full line, so it is always 'middle'.

#XXX Paragraph separation not valid inside Quote
# Quote will not have <p></p> inside, instead will close and open
# again the <blockquote>. This really sux in CSS, when defining a
# different background color. Still don't know how to fix it.

#XXX TODO (maybe)
# New mark or macro which expands to an anchor full title.
# It is necessary to parse the full document in this order:
#  DONE  1st scan: HEAD: get all settings, including %!includeconf
#  DONE  2nd scan: BODY: expand includes & apply %!preproc
#        3rd scan: BODY: read titles and compose TOC info
#        4th scan: BODY: full parsing, expanding [#anchor] 1st
# Steps 2 and 3 can be made together, with no tag adding.
# Two complete body scans will be *slow*, don't know if it worths.
# One solution may be add the titles as postproc rules


##############################################################################

# User config (1=ON, 0=OFF)

USE_I18N    = 1   # use gettext for i18ned messages?        (default is 1)
COLOR_DEBUG = 1   # show debug messages in colors?          (default is 1)
BG_LIGHT    = 0   # your terminal background color is light (default is 0)
HTML_LOWER  = 0   # use lowercased HTML tags instead upper? (default is 0)

##############################################################################


# These are all the core Python modules used by txt2tags (KISS!)
import re
import os
import sys
import locale
import time  # %%date, %%mtime
import getopt
import textwrap
import csv
import struct
import unicodedata
import base64  # embedImage()
import shlex  # CommandLine.tokenize()

# import urllib  # read remote files (URLs) -- postponed, see issue 96
# import email  # %%mtime for remote files -- postponed, see issue 96

try:
    import targets
except ImportError:
    targets = None
    TARGETS_LIST = []

# Program information
my_url = 'http://txt2tags.org'
my_name = 'txt2tags'
my_email = 'verde@aurelio.net'
my_revision = '$Revision$'  # automatic, from SVN
my_version = '2.7'

# Add SVN revision number to version: 1.2.345
my_version = '%s.%s' % (my_version, re.sub(r'\D', '', my_revision))

# i18n - just use if available
if USE_I18N:
    try:
        import gettext
        # If your locale dir is different, change it here
        cat = gettext.Catalog('txt2tags', localedir='/usr/share/locale/')
        _ = cat.gettext
    except:
        _ = lambda x: x
else:
    _ = lambda x: x

# FLAGS   : the conversion related flags  , may be used in %!options
# OPTIONS : the conversion related options, may be used in %!options
# ACTIONS : the other behavior modifiers, valid on command line only
# MACROS  : the valid macros with their default values for formatting
# SETTINGS: global miscellaneous settings, valid on RC file only
# NO_TARGET: actions that don't require a target specification
# NO_MULTI_INPUT: actions that don't accept more than one input file
# CONFIG_KEYWORDS: the valid %!key:val keywords
#
# FLAGS and OPTIONS are configs that affect the converted document.
# They usually have also a --no-<option> to turn them OFF.
#
# ACTIONS are needed because when handling multiple input files, strange
# behavior may occur, such as use command line interface for the
# first file and gui for the second. There is no --no-<action>.
# Options --version and --help inside %!options are odd.
#
FLAGS = {
    'headers': 1,
    'enum-title': 0,
    'mask-email': 0,
    'toc-only': 0,
    'toc': 0,
    'qa': 0,
    'rc': 1,
    'css-sugar': 0,
    'css-inside': 0,
    'quiet': 0,
    'slides': 0,
    'spread': 0,
    'web': 0,
    'fix-path': 0,
    'embed-images': 0,
    }
OPTIONS = {
    'target': '',
    'toc-level': 3,
    'toc-title': '',
    'style': '',
    'infile': '',
    'outfile': '',
    'encoding': '',
    'config-file': '',
    'split': 0,
    'lang': '',
    'width': 0,
    'height': 0,
    'chars': '',
    'show-config-value': '',
    'template': '',
    'dirname': '',  # internal use only
    }
ACTIONS = {
    'help': 0,
    'version': 0,
    'gui': 0,
    'verbose': 0,
    'debug': 0,
    'dump-config': 0,
    'dump-source': 0,
    'targets': 0,
    }
MACROS = {
    # date
    'date': '%Y%m%d',
    'mtime': '%Y%m%d',
    # files
    'infile': '%f',
    'currentfile': '%f',
    'outfile': '%f',
    # app
    'appurl': '',
    'appname': '',
    'appversion': '',
    # conversion
    'target': '',
    'cmdline': '',
    'encoding': '',
    # header
    'header1': '',
    'header2': '',
    'header3': '',
    # Creative Commons license
    'cc': '',
    }
SETTINGS = {}  # for future use
NO_TARGET = [
    'help',
    'version',
    'gui',
    'toc-only',
    'dump-config',
    'dump-source',
    'targets',
    ]
NO_MULTI_INPUT = [
    'gui',
    'dump-config',
    'dump-source'
    ]
CONFIG_KEYWORDS = [
    'cc',
    'target',
    'encoding',
    'style',
    'stylepath',  # internal use only
    'options',
    'preproc',
    'postproc',
    'postvoodoo',
    'guicolors',
    ]


TARGET_NAMES = {
  'txt2t'   : _('Txt2tags document'),
  'html'    : _('HTML page'),
  'html5'   : _('HTML5 page'),
  'xhtml'   : _('XHTML page'),
  'xhtmls'  : _('XHTML Strict page'),
  'htmls'   : _('HTML Spreadsheet'),
  'sgml'    : _('SGML document'),
  'dbk'     : _('DocBook document'),
  'tex'     : _('LaTeX document'),
  'texs'    : _('LaTeX Spreadsheet'),
  'lout'    : _('Lout document'),
  'man'     : _('UNIX Manual page'),
  'utmac'   : _('Utmac (utroff) document'),
  'mgp'     : _('MagicPoint presentation'),
  'wiki'    : _('Wikipedia page'),
  'gwiki'   : _('Google Wiki page'),
  'doku'    : _('DokuWiki page'),
  'pmw'     : _('PmWiki page'),
  'moin'    : _('MoinMoin page'),
  'pm6'     : _('PageMaker document'),
  'txt'     : _('Plain Text'),
  'aat'     : _('ASCII Art Text'),
  'aap'     : _('ASCII Art Presentation'),
  'aas'     : _('ASCII Art Spreadsheet'),
  'aatw'    : _('ASCII Art Text Web'),
  'aapw'    : _('ASCII Art Presentation Web'),
  'aasw'    : _('ASCII Art Spreadsheet Web'),
  'db'      : _('SQLite database'),
  'adoc'    : _('AsciiDoc document'),
  'rst'     : _('ReStructuredText document'),
  'csv'     : _('CSV table'),
  'csvs'    : _('CSV Spreadsheet'),
  'ods'     : _('Open Document Spreadsheet'),
  'creole'  : _('Creole 1.0 document'),
  'md'      : _('Markdown document'),
  'bbcode'  : _('BBCode document'),
  'red'     : _('Redmine Wiki page'),
  'spip'    : _('SPIP article'),
  'rtf'     : _('RTF document'),
  'wp'      : _('WordPress post'),
  'tml'     : _('Foswiki or TWiki page'),
  'mom'     : _('MOM groff macro'),
  'vimwiki' : _('Vimwiki document')
}


TARGET_TYPES = {
  'html'   : (_('HTML'), ['html', 'html5', 'xhtml', 'xhtmls', 'htmls', 'aatw', 'aapw', 'aasw', 'wp']),
  'wiki'   : (_('WIKI'), ['txt2t', 'wiki', 'gwiki', 'doku', 'pmw', 'moin', 'adoc', 'rst', 'creole', 'md', 'bbcode', 'red', 'spip', 'tml', 'vimwiki']),
  'office' : (_('OFFICE'), ['sgml', 'dbk', 'tex', 'texs', 'lout', 'mgp', 'pm6', 'csv', 'csvs', 'ods', 'rtf', 'db', 'mom', 'utmac']),
  'text'   : (_('TEXT'), ['man', 'txt', 'aat', 'aap', 'aas']),
}

if targets:
    TARGETS_LIST = targets.TARGETS_LIST

OTHER_TARGETS = []

NOT_LOADED = []
LOADED = []
for target in TARGETS_LIST:
    if target not in TARGET_NAMES:
        LOADED.append(target)
        TARGET_NAMES[target] = getattr(getattr(targets, target), 'NAME', target.capitalize() + ' target')
        try:
            TARGET_TYPES[getattr(targets, target).TYPE][1].append(target)
        except:
            OTHER_TARGETS.append(target)
    else:
        NOT_LOADED.append(target)
TARGETS_LIST = LOADED

TARGETS = TARGET_NAMES.keys()
TARGETS.sort()

DEBUG = 0     # do not edit here, please use --debug
VERBOSE = 0   # do not edit here, please use -v, -vv or -vvv
QUIET = 0     # do not edit here, please use --quiet
GUI = 0       # do not edit here, please use --gui
AUTOTOC = 1   # do not edit here, please use --no-toc or %%toc

DFT_TEXT_WIDTH   = 72  # do not edit here, please use --width
DFT_SLIDE_WIDTH  = 80  # do not edit here, please use --width
DFT_SLIDE_HEIGHT = 25  # do not edit here, please use --height

# ASCII Art config
AA_KEYS = 'tlcorner trcorner blcorner brcorner tcross bcross lcross rcross lhhead hheadcross rhhead headerscross tvhead vheadcross bvhead cross border side bar1 bar2 level2 level3 level4 level5 bullet hhead vhead'.split()
AA_SIMPLE = '+-|-==-^"-=$'  # do not edit here, please use --chars
AA_ADVANCED = '+++++++++++++++' + AA_SIMPLE  # do not edit here, please use --chars
AA = dict(zip(AA_KEYS, AA_ADVANCED))
AA_COUNT = 0
AA_PW_TOC = {}
AA_IMG = 0
AA_TITLE = ''
AA_MARKS = []

AA_QA = """\
       ________
   /#**TXT2TAGS**#\\
 /#####/      \####CC\\
/###/            \#BY#|
^-^               |NC#|
                  /SA#|
               /#####/
            /#####/
          /####/
         /###/
        |###|
        |###|
         \o/

         ___
        F2.7G
         (C)\
""".split('\n')

# ReStructuredText config
# http://docs.python.org/release/2.7/documenting/rest.html#sections
RST_KEYS = 'title level1 level2 level3 level4 level5 bar1 bullet'.split()
RST_VALUES = '#*=-^"--'  # do not edit here, please use --chars
RST = dict(zip(RST_KEYS, RST_VALUES))

CSV_KEYS = 'separator quotechar'.split()
CSV_VALUES = ','  # do not edit here, please use --chars
CSV = dict(zip(CSV_KEYS, CSV_VALUES))

RC_RAW = []
CMDLINE_RAW = []
CONF = {}
BLOCK = None
TITLE = None
regex = {}
TAGS = {}
rules = {}
MAILING = ''

# Gui globals
Tkinter = tkFileDialog = tkMessageBox = None

lang = 'english'
TARGET = ''

STDIN = STDOUT = '-'
MODULEIN = MODULEOUT = '-module-'
ESCCHAR   = '\x00'
SEPARATOR = '\x01'
LISTNAMES = {'-': 'list', '+': 'numlist', ':': 'deflist'}
LINEBREAK = {'default': '\n', 'win': '\r\n', 'mac': '\r'}

ESCAPES = {  'pm6':  [(ESCCHAR + '<', 'vvvvPm6Bracketvvvv', r'<\#92><')],
             'man':  [('-', 'vvvvManDashvvvv', r'\-')],
             'sgml': [('[', 'vvvvSgmlBracketvvvv', '&lsqb;')],
             'lout': [('/', 'vvvvLoutSlashvvvv', '"/"')],
             'tex':  [('_', 'vvvvTexUndervvvv', r'\_'),
                      ('\\', 'vvvvTexBackslashvvvv', r'$\backslash$')],
             'rtf':  [('\t', 'vvvvRtfTabvvvv', ESCCHAR + 'tab')],
          }

for target in TARGETS_LIST:
    ESCAPES[target] = getattr(getattr(targets, target), 'ESCAPES', [])

# Platform specific settings
LB = LINEBREAK.get(sys.platform[:3]) or LINEBREAK['default']

VERSIONSTR = _("%s version %s <%s>") % (my_name, my_version, my_url)


def Usage():
    fmt1 = "%4s  %-15s %s"
    fmt2 = "%4s, %-15s %s"
    return '\n'.join([
        '',
        _("Usage: %s [OPTIONS] [infile.t2t ...]") % my_name,
        '',
        fmt1 % (''  , '--targets'      , _("print a list of all the available targets and exit")),
        fmt2 % ('-t', '--target=TYPE'  , _("set target document type. currently supported:")),
        fmt1 % (''  , ''               , ', '.join(TARGETS[:8]) + ','),
        fmt1 % (''  , ''               , ', '.join(TARGETS[8:16]) + ','),
        fmt1 % (''  , ''               , ', '.join(TARGETS[16:25]) + ','),
        fmt1 % (''  , ''               , ', '.join(TARGETS[25:34]) + ','),
        fmt1 % (''  , ''               , ', '.join(TARGETS[34:])),
        fmt2 % ('-i', '--infile=FILE'  , _("set FILE as the input file name ('-' for STDIN)")),
        fmt2 % ('-o', '--outfile=FILE' , _("set FILE as the output file name ('-' for STDOUT)")),
        fmt1 % (''  , '--encoding=ENC' , _("inform source file encoding (UTF-8, iso-8859-1, etc)")),
        fmt1 % (''  , '--toc'          , _("add an automatic Table of Contents to the output")),
        fmt1 % (''  , '--toc-title=S'  , _("set custom TOC title to S")),
        fmt1 % (''  , '--toc-level=N'  , _("set maximum TOC level (depth) to N")),
        fmt1 % (''  , '--toc-only'     , _("print the Table of Contents and exit")),
        fmt2 % ('-n', '--enum-title'   , _("enumerate all titles as 1, 1.1, 1.1.1, etc")),
        fmt1 % (''  , '--style=FILE'   , _("use FILE as the document style (like HTML CSS)")),
        fmt1 % (''  , '--css-sugar'    , _("insert CSS-friendly tags for HTML/XHTML")),
        fmt1 % (''  , '--css-inside'   , _("insert CSS file contents inside HTML/XHTML headers")),
        fmt1 % (''  , '--embed-images' , _("embed image data inside HTML, html5, xhtml, RTF, aat and aap documents")),
        fmt2 % ('-H', '--no-headers'   , _("suppress header and footer from the output")),
        fmt2 % ('-T', '--template=FILE', _("use FILE as the template for the output document")),
        fmt1 % (''  , '--mask-email'   , _("hide email from spam robots. x@y.z turns <x (a) y z>")),
        fmt1 % (''  , '--width=N'      , _("set the output's width to N columns (used by aat, aap and aatw targets)")),
        fmt1 % (''  , '--height=N'     , _("set the output's height to N rows (used by aap target)")),
        fmt1 % (''  , '--chars=S'      , _("set the output's chars to S (used by all aa targets and rst)")),
        fmt1 % (''  , ''               , _("aa default " + AA_SIMPLE + " rst default " + RST_VALUES)),
        fmt2 % ('-C', '--config-file=F', _("read configuration from file F")),
        fmt1 % (''  , '--fix-path'     , _("fix resources path (image, links, CSS) when needed")),
        fmt1 % (''  , '--gui'          , _("invoke Graphical Tk Interface")),
        fmt2 % ('-q', '--quiet'        , _("quiet mode, suppress all output (except errors)")),
        fmt2 % ('-v', '--verbose'      , _("print informative messages during conversion")),
        fmt2 % ('-h', '--help'         , _("print this help information and exit")),
        fmt2 % ('-V', '--version'      , _("print program version and exit")),
        fmt1 % (''  , '--dump-config'  , _("print all the configuration found and exit")),
        fmt1 % (''  , '--dump-source'  , _("print the document source, with includes expanded")),
        '',
        _("Example:"),
        "     %s -t html --toc %s" % (my_name, _("file.t2t")),
        '',
        _("The 'no-' prefix disables the option:"),
        '     --no-toc, --no-style, --no-enum-title, ...',
        '',
        _("By default, converted output is saved to 'infile.<target>'."),
        _("Use --outfile to force an output file name."),
        _("If  input file is '-', reads from STDIN."),
        _("If output file is '-', dumps output to STDOUT."),
        '',
        my_url,
        '',
    ])


##############################################################################


# Here is all the target's templates
# You may edit them to fit your needs
#  - the %(HEADERn)s strings represent the Header lines
#  - the %(STYLE)s string is changed by --style contents
#  - the %(ENCODING)s string is changed by --encoding contents
#  - if any of the above is empty, the full line is removed
#  - use %% to represent a literal %
#
HEADER_TEMPLATE = {
    'aat': """\
""",
    'csv': """\
""",
    'csvs': """\
""",
    'db': """\
""",
    'rst': """\
""",
    'ods': """\
<?xml version='1.0' encoding='UTF-8'?>
<office:document xmlns:table="urn:oasis:names:tc:opendocument:xmlns:table:1.0" xmlns:fo="urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0" xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:style="urn:oasis:names:tc:opendocument:xmlns:style:1.0" xmlns:text="urn:oasis:names:tc:opendocument:xmlns:text:1.0" xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" office:version="1.1" office:mimetype="application/vnd.oasis.opendocument.spreadsheet"><office:meta><meta:generator>Txt2tags www.txt2tags.org</meta:generator></office:meta><office:automatic-styles/><office:body><office:spreadsheet>
""",
    'txt': """\
%(HEADER1)s
%(HEADER2)s
%(HEADER3)s
""",

    'txt2t': """\
%(HEADER1)s
%(HEADER2)s
%(HEADER3)s
%%! style    : %(STYLE)s
%%! encoding : %(ENCODING)s
""",

    'sgml': """\
<!doctype linuxdoc system>
<article>
<title>%(HEADER1)s
<author>%(HEADER2)s
<date>%(HEADER3)s
""",

    'html': """\
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.org">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=%(ENCODING)s">
<LINK REL="stylesheet" TYPE="text/css" HREF="%(STYLE)s">
<TITLE>%(HEADER1)s</TITLE>
</HEAD><BODY BGCOLOR="white" TEXT="black">
<CENTER>
<H1>%(HEADER1)s</H1>
<FONT SIZE="4"><I>%(HEADER2)s</I></FONT><BR>
<FONT SIZE="4">%(HEADER3)s</FONT>
</CENTER>
""",

    'htmlcss': """\
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
<META NAME="generator" CONTENT="http://txt2tags.org">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=%(ENCODING)s">
<LINK REL="stylesheet" TYPE="text/css" HREF="%(STYLE)s">
<TITLE>%(HEADER1)s</TITLE>
</HEAD>
<BODY>

<DIV CLASS="header" ID="header">
<H1>%(HEADER1)s</H1>
<H2>%(HEADER2)s</H2>
<H3>%(HEADER3)s</H3>
</DIV>
""",

# HTML5 reference code:
# https://github.com/h5bp/html5-boilerplate/blob/master/index.html
# https://github.com/murtaugh/HTML5-Reset/blob/master/index.html
    'html5': """\
<!DOCTYPE html>
<html>
<head>
<meta charset="%(ENCODING)s">
<title>%(HEADER1)s</title>
<meta name="generator" content="http://txt2tags.org">
<link rel="stylesheet" href="%(STYLE)s">
<link rel="stylesheet" href="css/blue/style.css" type="text/css" id="" media="print, projection, screen" />
<script type="text/javascript">
!function(e,t){function n(){if(!v.isReady){try{T.documentElement.doScroll("left")}catch(e){return void setTimeout(n,1)}v.ready()}}function r(e,t){t.src?v.ajax({url:t.src,async:!1,dataType:"script"}):v.globalEval(t.text||t.textContent||t.innerHTML||""),t.parentNode&&t.parentNode.removeChild(t)}function i(e,n,r,o,a,s){var l=e.length;if("object"==typeof n){for(var u in n)i(e,u,n[u],o,a,r);return e}if(r!==t){for(o=!s&&o&&v.isFunction(r),u=0;l>u;u++)a(e[u],n,o?r.call(e[u],u,a(e[u],n)):r,s);return e}return l?a(e[0],n):t}function o(){return(new Date).getTime()}function a(){return!1}function s(){return!0}function l(e,t,n){return n[0].type=e,v.event.handle.apply(t,n)}function u(e){var t,n,r,i,o,a,s,l=[],u=[],c=arguments;if(r=v.data(this,"events"),e.liveFired!==this&&r&&r.live&&(!e.button||"click"!==e.type)){e.liveFired=this;var f=r.live.slice(0);for(o=0;o<f.length;o++)r=f[o],r.origType.replace(U,"")===e.type?u.push(r.selector):f.splice(o--,1);for(n=v(e.target).closest(u,e.currentTarget),a=0,s=n.length;s>a;a++)for(o=0;o<f.length;o++)r=f[o],n[a].selector===r.selector&&(i=n[a].elem,u=null,("mouseenter"===r.preType||"mouseleave"===r.preType)&&(u=v(e.relatedTarget).closest(r.selector)[0]),u&&u===i||l.push({elem:i,handleObj:r}));for(a=0,s=l.length;s>a;a++)if(n=l[a],e.currentTarget=n.elem,e.data=n.handleObj.data,e.handleObj=n.handleObj,n.handleObj.origHandler.apply(n.elem,c)===!1){t=!1;break}return t}}function c(e,t){return"live."+(e&&"*"!==e?e+".":"")+t.replace(/\\./g,"`").replace(/ /g,"&")}function f(e){return!e||!e.parentNode||11===e.parentNode.nodeType}function d(e,t){var n=0;t.each(function(){if(this.nodeName===(e[n]&&e[n].nodeName)){var t=v.data(e[n++]),r=v.data(this,t);if(t=t&&t.events){delete r.handle,r.events={};for(var i in t)for(var o in t[i])v.event.add(this,i,t[i][o],t[i][o].data)}}})}function p(e,t,n){var r,i,o;return t=t&&t[0]?t[0].ownerDocument||t[0]:T,1===e.length&&"string"==typeof e[0]&&e[0].length<512&&t===T&&!pt.test(e[0])&&(v.support.checkClone||!ht.test(e[0]))&&(i=!0,(o=v.fragments[e[0]])&&1!==o&&(r=o)),r||(r=t.createDocumentFragment(),v.clean(e,t,r,n)),i&&(v.fragments[e[0]]=o?r:1),{fragment:r,cacheable:i}}function h(e,t){var n={};return v.each(Xt.concat.apply([],Xt.slice(0,t)),function(){n[this]=e}),n}function m(e){return"scrollTo"in e&&e.document?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}var g,y,v=function(e,t){return new v.fn.init(e,t)},b=e.jQuery,x=e.$,T=e.document,w=/^[^<]*(<[\\w\\W]+>)[^>]*$|^#([\\w-]+)$/,N=/^.[^:#\\[\\.,]*$/,S=/\\S/,E=/^(\\s|\\u00A0)+|(\\s|\\u00A0)+$/g,C=/^<(\\w+)\\s*\\/?>(?:<\\/\\1>)?$/,A=navigator.userAgent,F=!1,j=[],L=Object.prototype.toString,D=Object.prototype.hasOwnProperty,k=Array.prototype.push,O=Array.prototype.slice,M=Array.prototype.indexOf;v.fn=v.prototype={init:function(e,n){var r,i;if(!e)return this;if(e.nodeType)return this.context=this[0]=e,this.length=1,this;if("body"===e&&!n)return this.context=T,this[0]=T.body,this.selector="body",this.length=1,this;if("string"==typeof e){if(!(r=w.exec(e))||!r[1]&&n)return!n&&/^\\w+$/.test(e)?(this.selector=e,this.context=T,e=T.getElementsByTagName(e),v.merge(this,e)):!n||n.jquery?(n||g).find(e):v(n).find(e);if(r[1])return i=n?n.ownerDocument||n:T,(e=C.exec(e))?v.isPlainObject(n)?(e=[T.createElement(e[1])],v.fn.attr.call(e,n,!0)):e=[i.createElement(e[1])]:(e=p([r[1]],[i]),e=(e.cacheable?e.fragment.cloneNode(!0):e.fragment).childNodes),v.merge(this,e);if(n=T.getElementById(r[2])){if(n.id!==r[2])return g.find(e);this.length=1,this[0]=n}return this.context=T,this.selector=e,this}return v.isFunction(e)?g.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),v.makeArray(e,this))},selector:"",jquery:"1.4.2",length:0,size:function(){return this.length},toArray:function(){return O.call(this,0)},get:function(e){return null==e?this.toArray():0>e?this.slice(e)[0]:this[e]},pushStack:function(e,t,n){var r=v();return v.isArray(e)?k.apply(r,e):v.merge(r,e),r.prevObject=this,r.context=this.context,"find"===t?r.selector=this.selector+(this.selector?" ":"")+n:t&&(r.selector=this.selector+"."+t+"("+n+")"),r},each:function(e,t){return v.each(this,e,t)},ready:function(e){return v.bindReady(),v.isReady?e.call(T,v):j&&j.push(e),this},eq:function(e){return-1===e?this.slice(e):this.slice(e,+e+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(O.apply(this,arguments),"slice",O.call(arguments).join(","))},map:function(e){return this.pushStack(v.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||v(null)},push:k,sort:[].sort,splice:[].splice},v.fn.init.prototype=v.fn,v.extend=v.fn.extend=function(){var e,n,r,i,o=arguments[0]||{},a=1,s=arguments.length,l=!1;for("boolean"==typeof o&&(l=o,o=arguments[1]||{},a=2),"object"==typeof o||v.isFunction(o)||(o={}),s===a&&(o=this,--a);s>a;a++)if(null!=(e=arguments[a]))for(n in e)r=o[n],i=e[n],o!==i&&(l&&i&&(v.isPlainObject(i)||v.isArray(i))?(r=r&&(v.isPlainObject(r)||v.isArray(r))?r:v.isArray(i)?[]:{},o[n]=v.extend(l,r,i)):i!==t&&(o[n]=i));return o},v.extend({noConflict:function(t){return e.$=x,t&&(e.jQuery=b),v},isReady:!1,ready:function(){if(!v.isReady){if(!T.body)return setTimeout(v.ready,13);if(v.isReady=!0,j){for(var e,t=0;e=j[t++];)e.call(T,v);j=null}v.fn.triggerHandler&&v(T).triggerHandler("ready")}},bindReady:function(){if(!F){if(F=!0,"complete"===T.readyState)return v.ready();if(T.addEventListener)T.addEventListener("DOMContentLoaded",y,!1),e.addEventListener("load",v.ready,!1);else if(T.attachEvent){T.attachEvent("onreadystatechange",y),e.attachEvent("onload",v.ready);var t=!1;try{t=null==e.frameElement}catch(r){}T.documentElement.doScroll&&t&&n()}}},isFunction:function(e){return"[object Function]"===L.call(e)},isArray:function(e){return"[object Array]"===L.call(e)},isPlainObject:function(e){if(!e||"[object Object]"!==L.call(e)||e.nodeType||e.setInterval)return!1;if(e.constructor&&!D.call(e,"constructor")&&!D.call(e.constructor.prototype,"isPrototypeOf"))return!1;var n;for(n in e);return n===t||D.call(e,n)},isEmptyObject:function(e){for(var t in e)return!1;return!0},error:function(e){throw e},parseJSON:function(t){return"string"==typeof t&&t?(t=v.trim(t),/^[\\],:{}\\s]*$/.test(t.replace(/\\\\(?:["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\\\\n\\r]*"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g,"]").replace(/(?:^|:|,)(?:\\s*\\[)+/g,""))?e.JSON&&e.JSON.parse?e.JSON.parse(t):new Function("return "+t)():void v.error("Invalid JSON: "+t)):null},noop:function(){},globalEval:function(e){if(e&&S.test(e)){var t=T.getElementsByTagName("head")[0]||T.documentElement,n=T.createElement("script");n.type="text/javascript",v.support.scriptEval?n.appendChild(T.createTextNode(e)):n.text=e,t.insertBefore(n,t.firstChild),t.removeChild(n)}},nodeName:function(e,t){return e.nodeName&&e.nodeName.toUpperCase()===t.toUpperCase()},each:function(e,n,r){var i,o=0,a=e.length,s=a===t||v.isFunction(e);if(r)if(s){for(i in e)if(n.apply(e[i],r)===!1)break}else for(;a>o&&n.apply(e[o++],r)!==!1;);else if(s){for(i in e)if(n.call(e[i],i,e[i])===!1)break}else for(r=e[0];a>o&&n.call(r,o,r)!==!1;r=e[++o]);return e},trim:function(e){return(e||"").replace(E,"")},makeArray:function(e,t){return t=t||[],null!=e&&(null==e.length||"string"==typeof e||v.isFunction(e)||"function"!=typeof e&&e.setInterval?k.call(t,e):v.merge(t,e)),t},inArray:function(e,t){if(t.indexOf)return t.indexOf(e);for(var n=0,r=t.length;r>n;n++)if(t[n]===e)return n;return-1},merge:function(e,n){var r=e.length,i=0;if("number"==typeof n.length)for(var o=n.length;o>i;i++)e[r++]=n[i];else for(;n[i]!==t;)e[r++]=n[i++];return e.length=r,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length;o>i;i++)!n!=!t(e[i],i)&&r.push(e[i]);return r},map:function(e,t,n){for(var r,i=[],o=0,a=e.length;a>o;o++)r=t(e[o],o,n),null!=r&&(i[i.length]=r);return i.concat.apply([],i)},guid:1,proxy:function(e,n,r){return 2===arguments.length&&("string"==typeof n?(r=e,e=r[n],n=t):n&&!v.isFunction(n)&&(r=n,n=t)),!n&&e&&(n=function(){return e.apply(r||this,arguments)}),e&&(n.guid=e.guid=e.guid||n.guid||v.guid++),n},uaMatch:function(e){return e=e.toLowerCase(),e=/(webkit)[ \\/]([\\w.]+)/.exec(e)||/(opera)(?:.*version)?[ \\/]([\\w.]+)/.exec(e)||/(msie) ([\\w.]+)/.exec(e)||!/compatible/.test(e)&&/(mozilla)(?:.*? rv:([\\w.]+))?/.exec(e)||[],{browser:e[1]||"",version:e[2]||"0"}},browser:{}}),A=v.uaMatch(A),A.browser&&(v.browser[A.browser]=!0,v.browser.version=A.version),v.browser.webkit&&(v.browser.safari=!0),M&&(v.inArray=function(e,t){return M.call(t,e)}),g=v(T),T.addEventListener?y=function(){T.removeEventListener("DOMContentLoaded",y,!1),v.ready()}:T.attachEvent&&(y=function(){"complete"===T.readyState&&(T.detachEvent("onreadystatechange",y),v.ready())}),function(){v.support={};var t=T.documentElement,n=T.createElement("script"),r=T.createElement("div"),i="script"+o();r.style.display="none",r.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";var a=r.getElementsByTagName("*"),s=r.getElementsByTagName("a")[0];if(a&&a.length&&s){v.support={leadingWhitespace:3===r.firstChild.nodeType,tbody:!r.getElementsByTagName("tbody").length,htmlSerialize:!!r.getElementsByTagName("link").length,style:/red/.test(s.getAttribute("style")),hrefNormalized:"/a"===s.getAttribute("href"),opacity:/^0.55$/.test(s.style.opacity),cssFloat:!!s.style.cssFloat,checkOn:"on"===r.getElementsByTagName("input")[0].value,optSelected:T.createElement("select").appendChild(T.createElement("option")).selected,parentNode:null===r.removeChild(r.appendChild(T.createElement("div"))).parentNode,deleteExpando:!0,checkClone:!1,scriptEval:!1,noCloneEvent:!0,boxModel:null},n.type="text/javascript";try{n.appendChild(T.createTextNode("window."+i+"=1;"))}catch(l){}t.insertBefore(n,t.firstChild),e[i]&&(v.support.scriptEval=!0,delete e[i]);try{delete n.test}catch(u){v.support.deleteExpando=!1}t.removeChild(n),r.attachEvent&&r.fireEvent&&(r.attachEvent("onclick",function c(){v.support.noCloneEvent=!1,r.detachEvent("onclick",c)}),r.cloneNode(!0).fireEvent("onclick")),r=T.createElement("div"),r.innerHTML="<input type='radio' name='radiotest' checked='checked'/>",t=T.createDocumentFragment(),t.appendChild(r.firstChild),v.support.checkClone=t.cloneNode(!0).cloneNode(!0).lastChild.checked,v(function(){var e=T.createElement("div");e.style.width=e.style.paddingLeft="1px",T.body.appendChild(e),v.boxModel=v.support.boxModel=2===e.offsetWidth,T.body.removeChild(e).style.display="none"}),t=function(e){var t=T.createElement("div");e="on"+e;var n=e in t;return n||(t.setAttribute(e,"return;"),n="function"==typeof t[e]),n},v.support.submitBubbles=t("submit"),v.support.changeBubbles=t("change"),t=n=r=a=s=null}}(),v.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};var B="jQuery"+o(),I=0,P={};v.extend({cache:{},expando:B,noData:{embed:!0,object:!0,applet:!0},data:function(n,r,i){if(!n.nodeName||!v.noData[n.nodeName.toLowerCase()]){n=n==e?P:n;var o=n[B],a=v.cache;return o||"string"!=typeof r||i!==t?(o||(o=++I),"object"==typeof r?(n[B]=o,a[o]=v.extend(!0,{},r)):a[o]||(n[B]=o,a[o]={}),n=a[o],i!==t&&(n[r]=i),"string"==typeof r?n[r]:n):null}},removeData:function(t,n){if(!t.nodeName||!v.noData[t.nodeName.toLowerCase()]){t=t==e?P:t;var r=t[B],i=v.cache,o=i[r];n?o&&(delete o[n],v.isEmptyObject(o)&&v.removeData(t)):(v.support.deleteExpando?delete t[v.expando]:t.removeAttribute&&t.removeAttribute(v.expando),delete i[r])}}}),v.fn.extend({data:function(e,n){if("undefined"==typeof e&&this.length)return v.data(this[0]);if("object"==typeof e)return this.each(function(){v.data(this,e)});var r=e.split(".");if(r[1]=r[1]?"."+r[1]:"",n===t){var i=this.triggerHandler("getData"+r[1]+"!",[r[0]]);return i===t&&this.length&&(i=v.data(this[0],e)),i===t&&r[1]?this.data(r[0]):i}return this.trigger("setData"+r[1]+"!",[r[0],n]).each(function(){v.data(this,e,n)})},removeData:function(e){return this.each(function(){v.removeData(this,e)})}}),v.extend({queue:function(e,t,n){if(e){t=(t||"fx")+"queue";var r=v.data(e,t);return n?(!r||v.isArray(n)?r=v.data(e,t,v.makeArray(n)):r.push(n),r):r||[]}},dequeue:function(e,t){t=t||"fx";var n=v.queue(e,t),r=n.shift();"inprogress"===r&&(r=n.shift()),r&&("fx"===t&&n.unshift("inprogress"),r.call(e,function(){v.dequeue(e,t)}))}}),v.fn.extend({queue:function(e,n){return"string"!=typeof e&&(n=e,e="fx"),n===t?v.queue(this[0],e):this.each(function(){var t=v.queue(this,e,n);"fx"===e&&"inprogress"!==t[0]&&v.dequeue(this,e)})},dequeue:function(e){return this.each(function(){v.dequeue(this,e)})},delay:function(e,t){return e=v.fx?v.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(){var n=this;setTimeout(function(){v.dequeue(n,t)},e)})},clearQueue:function(e){return this.queue(e||"fx",[])}});var q=/[\\n\\t]/g,H=/\\s+/,R=/\\r/g,$=/href|src|style/,_=/(button|input)/i,z=/(button|input|object|select|textarea)/i,W=/^(a|area)$/i,X=/radio|checkbox/;v.fn.extend({attr:function(e,t){return i(this,e,t,!0,v.attr)},removeAttr:function(e){return this.each(function(){v.attr(this,e,""),1===this.nodeType&&this.removeAttribute(e)})},addClass:function(e){if(v.isFunction(e))return this.each(function(t){var n=v(this);n.addClass(e.call(this,t,n.attr("class")))});if(e&&"string"==typeof e)for(var t=(e||"").split(H),n=0,r=this.length;r>n;n++){var i=this[n];if(1===i.nodeType)if(i.className){for(var o=" "+i.className+" ",a=i.className,s=0,l=t.length;l>s;s++)o.indexOf(" "+t[s]+" ")<0&&(a+=" "+t[s]);i.className=v.trim(a)}else i.className=e}return this},removeClass:function(e){if(v.isFunction(e))return this.each(function(t){var n=v(this);n.removeClass(e.call(this,t,n.attr("class")))});if(e&&"string"==typeof e||e===t)for(var n=(e||"").split(H),r=0,i=this.length;i>r;r++){var o=this[r];if(1===o.nodeType&&o.className)if(e){for(var a=(" "+o.className+" ").replace(q," "),s=0,l=n.length;l>s;s++)a=a.replace(" "+n[s]+" "," ");o.className=v.trim(a)}else o.className=""}return this},toggleClass:function(e,t){var n=typeof e,r="boolean"==typeof t;return this.each(v.isFunction(e)?function(n){var r=v(this);r.toggleClass(e.call(this,n,r.attr("class"),t),t)}:function(){if("string"===n)for(var i,o=0,a=v(this),s=t,l=e.split(H);i=l[o++];)s=r?s:!a.hasClass(i),a[s?"addClass":"removeClass"](i);else("undefined"===n||"boolean"===n)&&(this.className&&v.data(this,"__className__",this.className),this.className=this.className||e===!1?"":v.data(this,"__className__")||"")})},hasClass:function(e){e=" "+e+" ";for(var t=0,n=this.length;n>t;t++)if((" "+this[t].className+" ").replace(q," ").indexOf(e)>-1)return!0;return!1},val:function(e){if(e===t){var n=this[0];if(n){if(v.nodeName(n,"option"))return(n.attributes.value||{}).specified?n.value:n.text;if(v.nodeName(n,"select")){var r=n.selectedIndex,i=[],o=n.options;if(n="select-one"===n.type,0>r)return null;var a=n?r:0;for(r=n?r+1:o.length;r>a;a++){var s=o[a];if(s.selected){if(e=v(s).val(),n)return e;i.push(e)}}return i}return X.test(n.type)&&!v.support.checkOn?null===n.getAttribute("value")?"on":n.value:(n.value||"").replace(R,"")}return t}var l=v.isFunction(e);return this.each(function(t){var n=v(this),r=e;if(1===this.nodeType)if(l&&(r=e.call(this,t,n.val())),"number"==typeof r&&(r+=""),v.isArray(r)&&X.test(this.type))this.checked=v.inArray(n.val(),r)>=0;else if(v.nodeName(this,"select")){var i=v.makeArray(r);v("option",this).each(function(){this.selected=v.inArray(v(this).val(),i)>=0}),i.length||(this.selectedIndex=-1)}else this.value=r})}}),v.extend({attrFn:{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0},attr:function(e,n,r,i){if(!e||3===e.nodeType||8===e.nodeType)return t;if(i&&n in v.attrFn)return v(e)[n](r);i=1!==e.nodeType||!v.isXMLDoc(e);var o=r!==t;if(n=i&&v.props[n]||n,1===e.nodeType){var a=$.test(n);return n in e&&i&&!a?(o&&("type"===n&&_.test(e.nodeName)&&e.parentNode&&v.error("type property can't be changed"),e[n]=r),v.nodeName(e,"form")&&e.getAttributeNode(n)?e.getAttributeNode(n).nodeValue:"tabIndex"===n?(n=e.getAttributeNode("tabIndex"))&&n.specified?n.value:z.test(e.nodeName)||W.test(e.nodeName)&&e.href?0:t:e[n]):!v.support.style&&i&&"style"===n?(o&&(e.style.cssText=""+r),e.style.cssText):(o&&e.setAttribute(n,""+r),e=!v.support.hrefNormalized&&i&&a?e.getAttribute(n,2):e.getAttribute(n),null===e?t:e)}return v.style(e,n,r)}});var U=/\\.(.*)$/,V=function(e){return e.replace(/[^\\w\\s\\.\\|`]/g,function(e){return"\\\\"+e})};v.event={add:function(n,r,i,o){if(3!==n.nodeType&&8!==n.nodeType){n.setInterval&&n!==e&&!n.frameElement&&(n=e);var a,s;if(i.handler&&(a=i,i=a.handler),i.guid||(i.guid=v.guid++),s=v.data(n)){var l=s.events=s.events||{},u=s.handle;u||(s.handle=u=function(){return"undefined"==typeof v||v.event.triggered?t:v.event.handle.apply(u.elem,arguments)}),u.elem=n,r=r.split(" ");for(var c,f,d=0;c=r[d++];){s=a?v.extend({},a):{handler:i,data:o},c.indexOf(".")>-1?(f=c.split("."),c=f.shift(),s.namespace=f.slice(0).sort().join(".")):(f=[],s.namespace=""),s.type=c,s.guid=i.guid;var p=l[c],h=v.event.special[c]||{};p||(p=l[c]=[],h.setup&&h.setup.call(n,o,f,u)!==!1||(n.addEventListener?n.addEventListener(c,u,!1):n.attachEvent&&n.attachEvent("on"+c,u))),h.add&&(h.add.call(n,s),s.handler.guid||(s.handler.guid=i.guid)),p.push(s),v.event.global[c]=!0}n=null}}},global:{},remove:function(e,t,n,r){if(3!==e.nodeType&&8!==e.nodeType){var i,o,a,s,l,u,c,f=0,d=v.data(e),p=d&&d.events;if(d&&p)if(t&&t.type&&(n=t.handler,t=t.type),!t||"string"==typeof t&&"."===t.charAt(0)){t=t||"";for(i in p)v.event.remove(e,i+t)}else{for(t=t.split(" ");i=t[f++];)if(l=i,o=i.indexOf(".")<0,a=[],o||(a=i.split("."),i=a.shift(),s=new RegExp("(^|\\\\.)"+v.map(a.slice(0).sort(),V).join("\\\\.(?:.*\\\\.)?")+"(\\\\.|$)")),u=p[i])if(n){for(l=v.event.special[i]||{},h=r||0;h<u.length&&(c=u[h],n.guid!==c.guid||((o||s.test(c.namespace))&&(null==r&&u.splice(h--,1),l.remove&&l.remove.call(e,c)),null==r));h++);(0===u.length||null!=r&&1===u.length)&&(l.teardown&&l.teardown.call(e,a)!==!1||G(e,i,d.handle),delete p[i])}else for(var h=0;h<u.length;h++)c=u[h],(o||s.test(c.namespace))&&(v.event.remove(e,l,c.handler,h),u.splice(h--,1));v.isEmptyObject(p)&&((t=d.handle)&&(t.elem=null),delete d.events,delete d.handle,v.isEmptyObject(d)&&v.removeData(e))}}},trigger:function(e,n,r,i){var o=e.type||e;if(!i){if(e="object"==typeof e?e[B]?e:v.extend(v.Event(o),e):v.Event(o),o.indexOf("!")>=0&&(e.type=o=o.slice(0,-1),e.exclusive=!0),r||(e.stopPropagation(),v.event.global[o]&&v.each(v.cache,function(){this.events&&this.events[o]&&v.event.trigger(e,n,this.handle.elem)})),!r||3===r.nodeType||8===r.nodeType)return t;e.result=t,e.target=r,n=v.makeArray(n),n.unshift(e)}e.currentTarget=r,(i=v.data(r,"handle"))&&i.apply(r,n),i=r.parentNode||r.ownerDocument;try{r&&r.nodeName&&v.noData[r.nodeName.toLowerCase()]||r["on"+o]&&r["on"+o].apply(r,n)===!1&&(e.result=!1)}catch(a){}if(!e.isPropagationStopped()&&i)v.event.trigger(e,n,i,!0);else if(!e.isDefaultPrevented()){i=e.target;var s,l=v.nodeName(i,"a")&&"click"===o,u=v.event.special[o]||{};if(!(u._default&&u._default.call(r,e)!==!1||l||i&&i.nodeName&&v.noData[i.nodeName.toLowerCase()])){try{i[o]&&((s=i["on"+o])&&(i["on"+o]=null),v.event.triggered=!0,i[o]())}catch(c){}s&&(i["on"+o]=s),v.event.triggered=!1}}},handle:function(n){var r,i,o,a;if(n=arguments[0]=v.event.fix(n||e.event),n.currentTarget=this,r=n.type.indexOf(".")<0&&!n.exclusive,r||(i=n.type.split("."),n.type=i.shift(),o=new RegExp("(^|\\\\.)"+i.slice(0).sort().join("\\\\.(?:.*\\\\.)?")+"(\\\\.|$)")),a=v.data(this,"events"),i=a[n.type],a&&i){i=i.slice(0),a=0;for(var s=i.length;s>a;a++){var l=i[a];if((r||o.test(l.namespace))&&(n.handler=l.handler,n.data=l.data,n.handleObj=l,l=l.handler.apply(this,arguments),l!==t&&(n.result=l,l===!1&&(n.preventDefault(),n.stopPropagation())),n.isImmediatePropagationStopped()))break}}return n.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY originalTarget pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),fix:function(e){if(e[B])return e;var n=e;e=v.Event(n);for(var r,i=this.props.length;i;)r=this.props[--i],e[r]=n[r];return e.target||(e.target=e.srcElement||T),3===e.target.nodeType&&(e.target=e.target.parentNode),!e.relatedTarget&&e.fromElement&&(e.relatedTarget=e.fromElement===e.target?e.toElement:e.fromElement),null==e.pageX&&null!=e.clientX&&(n=T.documentElement,i=T.body,e.pageX=e.clientX+(n&&n.scrollLeft||i&&i.scrollLeft||0)-(n&&n.clientLeft||i&&i.clientLeft||0),e.pageY=e.clientY+(n&&n.scrollTop||i&&i.scrollTop||0)-(n&&n.clientTop||i&&i.clientTop||0)),!e.which&&(e.charCode||0===e.charCode?e.charCode:e.keyCode)&&(e.which=e.charCode||e.keyCode),!e.metaKey&&e.ctrlKey&&(e.metaKey=e.ctrlKey),e.which||e.button===t||(e.which=1&e.button?1:2&e.button?3:4&e.button?2:0),e},guid:1e8,proxy:v.proxy,special:{ready:{setup:v.bindReady,teardown:v.noop},live:{add:function(e){v.event.add(this,e.origType,v.extend({},e,{handler:u}))},remove:function(e){var t=!0,n=e.origType.replace(U,"");v.each(v.data(this,"events").live||[],function(){return n===this.origType.replace(U,"")?t=!1:void 0}),t&&v.event.remove(this,e.origType,u)}},beforeunload:{setup:function(e,t,n){return this.setInterval&&(this.onbeforeunload=n),!1},teardown:function(e,t){this.onbeforeunload===t&&(this.onbeforeunload=null)}}}};var G=T.removeEventListener?function(e,t,n){e.removeEventListener(t,n,!1)}:function(e,t,n){e.detachEvent("on"+t,n)};v.Event=function(e){return this.preventDefault?(e&&e.type?(this.originalEvent=e,this.type=e.type):this.type=e,this.timeStamp=o(),void(this[B]=!0)):new v.Event(e)},v.Event.prototype={preventDefault:function(){this.isDefaultPrevented=s;var e=this.originalEvent;e&&(e.preventDefault&&e.preventDefault(),e.returnValue=!1)},stopPropagation:function(){this.isPropagationStopped=s;var e=this.originalEvent;e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=s,this.stopPropagation()},isDefaultPrevented:a,isPropagationStopped:a,isImmediatePropagationStopped:a};var Y=function(e){var t=e.relatedTarget;try{for(;t&&t!==this;)t=t.parentNode;t!==this&&(e.type=e.data,v.event.handle.apply(this,arguments))}catch(n){}},K=function(e){e.type=e.data,v.event.handle.apply(this,arguments)};if(v.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){v.event.special[e]={setup:function(n){v.event.add(this,t,n&&n.selector?K:Y,e)},teardown:function(e){v.event.remove(this,t,e&&e.selector?K:Y)}}}),v.support.submitBubbles||(v.event.special.submit={setup:function(){return"form"===this.nodeName.toLowerCase()?!1:(v.event.add(this,"click.specialSubmit",function(e){var t=e.target,n=t.type;return"submit"!==n&&"image"!==n||!v(t).closest("form").length?void 0:l("submit",this,arguments)}),void v.event.add(this,"keypress.specialSubmit",function(e){var t=e.target,n=t.type;return"text"!==n&&"password"!==n||!v(t).closest("form").length||13!==e.keyCode?void 0:l("submit",this,arguments)}))},teardown:function(){v.event.remove(this,".specialSubmit")}}),!v.support.changeBubbles){var J,Q=/textarea|input|select/i,Z=function(e){var t=e.type,n=e.value;return"radio"===t||"checkbox"===t?n=e.checked:"select-multiple"===t?n=e.selectedIndex>-1?v.map(e.options,function(e){return e.selected}).join("-"):"":"select"===e.nodeName.toLowerCase()&&(n=e.selectedIndex),n},et=function(e,n){var r,i,o=e.target;return!Q.test(o.nodeName)||o.readOnly||(r=v.data(o,"_change_data"),i=Z(o),("focusout"!==e.type||"radio"!==o.type)&&v.data(o,"_change_data",i),r===t||i===r||null==r&&!i)?void 0:(e.type="change",v.event.trigger(e,n,o))};v.event.special.change={filters:{focusout:et,click:function(e){var t=e.target,n=t.type;return"radio"===n||"checkbox"===n||"select"===t.nodeName.toLowerCase()?et.call(this,e):void 0},keydown:function(e){var t=e.target,n=t.type;return 13===e.keyCode&&"textarea"!==t.nodeName.toLowerCase()||32===e.keyCode&&("checkbox"===n||"radio"===n)||"select-multiple"===n?et.call(this,e):void 0},beforeactivate:function(e){e=e.target,v.data(e,"_change_data",Z(e))}},setup:function(){if("file"===this.type)return!1;for(var e in J)v.event.add(this,e+".specialChange",J[e]);return Q.test(this.nodeName)},teardown:function(){return v.event.remove(this,".specialChange"),Q.test(this.nodeName)}},J=v.event.special.change.filters}T.addEventListener&&v.each({focus:"focusin",blur:"focusout"},function(e,t){function n(e){return e=v.event.fix(e),e.type=t,v.event.handle.call(this,e)}v.event.special[t]={setup:function(){this.addEventListener(e,n,!0)},teardown:function(){this.removeEventListener(e,n,!0)}}}),v.each(["bind","one"],function(e,n){v.fn[n]=function(e,r,i){if("object"==typeof e){for(var o in e)this[n](o,r,e[o],i);return this}v.isFunction(r)&&(i=r,r=t);var a="one"===n?v.proxy(i,function(e){return v(this).unbind(e,a),i.apply(this,arguments)}):i;if("unload"===e&&"one"!==n)this.one(e,r,i);else{o=0;for(var s=this.length;s>o;o++)v.event.add(this[o],e,a,r)}return this}}),v.fn.extend({unbind:function(e,t){if("object"!=typeof e||e.preventDefault){r=0;for(var n=this.length;n>r;r++)v.event.remove(this[r],e,t)}else for(var r in e)this.unbind(r,e[r]);return this},delegate:function(e,t,n,r){return this.live(t,n,r,e)},undelegate:function(e,t,n){return 0===arguments.length?this.unbind("live"):this.die(t,null,n,e)},trigger:function(e,t){return this.each(function(){v.event.trigger(e,t,this)})},triggerHandler:function(e,t){return this[0]?(e=v.Event(e),e.preventDefault(),e.stopPropagation(),v.event.trigger(e,t,this[0]),e.result):void 0},toggle:function(e){for(var t=arguments,n=1;n<t.length;)v.proxy(e,t[n++]);return this.click(v.proxy(e,function(r){var i=(v.data(this,"lastToggle"+e.guid)||0)%%n;return v.data(this,"lastToggle"+e.guid,i+1),r.preventDefault(),t[i].apply(this,arguments)||!1}))},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}});var tt={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};v.each(["live","die"],function(e,n){v.fn[n]=function(e,r,i,o){var a,s,l,u=0,f=o||this.selector,d=o?this:v(this.context);for(v.isFunction(r)&&(i=r,r=t),e=(e||"").split(" ");null!=(a=e[u++]);)o=U.exec(a),s="",o&&(s=o[0],a=a.replace(U,"")),"hover"===a?e.push("mouseenter"+s,"mouseleave"+s):(l=a,"focus"===a||"blur"===a?(e.push(tt[a]+s),a+=s):a=(tt[a]||a)+s,"live"===n?d.each(function(){v.event.add(this,c(a,f),{data:r,selector:f,handler:i,origType:a,origHandler:i,preType:l})}):d.unbind(c(a,f),i));return this}}),v.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),function(e,t){v.fn[t]=function(e){return e?this.bind(t,e):this.trigger(t)},v.attrFn&&(v.attrFn[t]=!0)}),e.attachEvent&&!e.addEventListener&&e.attachEvent("onunload",function(){for(var e in v.cache)if(v.cache[e].handle)try{v.event.remove(v.cache[e].handle.elem)}catch(t){}}),function(){function e(t){for(var n,r="",i=0;t[i];i++)n=t[i],3===n.nodeType||4===n.nodeType?r+=n.nodeValue:8!==n.nodeType&&(r+=e(n.childNodes));return r}function n(e,t,n,r,i,o){i=0;for(var a=r.length;a>i;i++){var s=r[i];if(s){s=s[e];for(var l=!1;s;){if(s.sizcache===n){l=r[s.sizset];break}if(1!==s.nodeType||o||(s.sizcache=n,s.sizset=i),s.nodeName.toLowerCase()===t){l=s;break}s=s[e]}r[i]=l}}}function r(e,t,n,r,i,o){i=0;for(var a=r.length;a>i;i++){var s=r[i];if(s){s=s[e];for(var l=!1;s;){if(s.sizcache===n){l=r[s.sizset];break}if(1===s.nodeType)if(o||(s.sizcache=n,s.sizset=i),"string"!=typeof t){if(s===t){l=!0;break}}else if(u.filter(t,[s]).length>0){l=s;break}s=s[e]}r[i]=l}}}var i=/((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^[\\]]*\\]|['"][^'"]*['"]|[^[\\]'"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g,o=0,a=Object.prototype.toString,s=!1,l=!0;[0,0].sort(function(){return l=!1,0});var u=function(e,t,n,r){n=n||[];var o=t=t||T;if(1!==t.nodeType&&9!==t.nodeType)return[];if(!e||"string"!=typeof e)return n;for(var s,l,d,h,m=[],v=!0,x=y(t),w=e;null!==(i.exec(""),s=i.exec(w));)if(w=s[3],m.push(s[1]),s[2]){h=s[3];break}if(m.length>1&&f.exec(e))if(2===m.length&&c.relative[m[0]])l=b(m[0]+m[1],t);else for(l=c.relative[m[0]]?[t]:u(m.shift(),t);m.length;)e=m.shift(),c.relative[e]&&(e+=m.shift()),l=b(e,l);else if(!r&&m.length>1&&9===t.nodeType&&!x&&c.match.ID.test(m[0])&&!c.match.ID.test(m[m.length-1])&&(s=u.find(m.shift(),t,x),t=s.expr?u.filter(s.expr,s.set)[0]:s.set[0]),t)for(s=r?{expr:m.pop(),set:p(r)}:u.find(m.pop(),1!==m.length||"~"!==m[0]&&"+"!==m[0]||!t.parentNode?t:t.parentNode,x),l=s.expr?u.filter(s.expr,s.set):s.set,m.length>0?d=p(l):v=!1;m.length;){var N=m.pop();s=N,c.relative[N]?s=m.pop():N="",null==s&&(s=t),c.relative[N](d,s,x)}else d=[];if(d||(d=l),d||u.error(N||e),"[object Array]"===a.call(d))if(v)if(t&&1===t.nodeType)for(e=0;null!=d[e];e++)d[e]&&(d[e]===!0||1===d[e].nodeType&&g(t,d[e]))&&n.push(l[e]);else for(e=0;null!=d[e];e++)d[e]&&1===d[e].nodeType&&n.push(l[e]);else n.push.apply(n,d);else p(d,n);return h&&(u(h,o,n,r),u.uniqueSort(n)),n};u.uniqueSort=function(e){if(m&&(s=l,e.sort(m),s))for(var t=1;t<e.length;t++)e[t]===e[t-1]&&e.splice(t--,1);return e},u.matches=function(e,t){return u(e,null,null,t)},u.find=function(e,t,n){var r,i;if(!e)return[];for(var o=0,a=c.order.length;a>o;o++){var s=c.order[o];if(i=c.leftMatch[s].exec(e)){var l=i[1];if(i.splice(1,1),"\\\\"!==l.substr(l.length-1)&&(i[1]=(i[1]||"").replace(/\\\\/g,""),r=c.find[s](i,t,n),null!=r)){e=e.replace(c.match[s],"");break}}}return r||(r=t.getElementsByTagName("*")),{set:r,expr:e}},u.filter=function(e,n,r,i){for(var o,a,s=e,l=[],f=n,d=n&&n[0]&&y(n[0]);e&&n.length;){for(var p in c.filter)if(null!=(o=c.leftMatch[p].exec(e))&&o[2]){var h,m,g=c.filter[p];if(m=o[1],a=!1,o.splice(1,1),"\\\\"!==m.substr(m.length-1)){if(f===l&&(l=[]),c.preFilter[p])if(o=c.preFilter[p](o,f,r,l,i,d)){if(o===!0)continue}else a=h=!0;if(o)for(var v=0;null!=(m=f[v]);v++)if(m){h=g(m,o,v,f);var b=i^!!h;r&&null!=h?b?a=!0:f[v]=!1:b&&(l.push(m),a=!0)}if(h!==t){if(r||(f=l),e=e.replace(c.match[p],""),!a)return[];break}}}if(e===s){if(null!=a)break;u.error(e)}s=e}return f},u.error=function(e){throw"Syntax error, unrecognized expression: "+e};var c=u.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)/,CLASS:/\\.((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)/,NAME:/\\[name=['"]*((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)['"]*\\]/,ATTR:/\\[\\s*((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)\\s*(?:(\\S?=)\\s*(['"]*)(.*?)\\3|)\\s*\\]/,TAG:/^((?:[\\w\\u00c0-\\uFFFF\\*-]|\\\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\\((even|odd|[\\dn+-]*)\\))?/,POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\))?(?=[^-]|$)/,PSEUDO:/:((?:[\\w\\u00c0-\\uFFFF-]|\\\\.)+)(?:\\((['"]?)((?:\\([^\\)]+\\)|[^\\(\\)]*)+)\\2\\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(e){return e.getAttribute("href")}},relative:{"+":function(e,t){var n="string"==typeof t,r=n&&!/\\W/.test(t);n=n&&!r,r&&(t=t.toLowerCase()),r=0;for(var i,o=e.length;o>r;r++)if(i=e[r]){for(;(i=i.previousSibling)&&1!==i.nodeType;);e[r]=n||i&&i.nodeName.toLowerCase()===t?i||!1:i===t}n&&u.filter(t,e,!0)},">":function(e,t){var n="string"==typeof t;if(n&&!/\\W/.test(t)){t=t.toLowerCase();for(var r=0,i=e.length;i>r;r++){var o=e[r];o&&(n=o.parentNode,e[r]=n.nodeName.toLowerCase()===t?n:!1)}}else{for(r=0,i=e.length;i>r;r++)(o=e[r])&&(e[r]=n?o.parentNode:o.parentNode===t);n&&u.filter(t,e,!0)}},"":function(e,t,i){var a=o++,s=r;if("string"==typeof t&&!/\\W/.test(t)){var l=t=t.toLowerCase();s=n}s("parentNode",t,a,e,l,i)},"~":function(e,t,i){var a=o++,s=r;if("string"==typeof t&&!/\\W/.test(t)){var l=t=t.toLowerCase();s=n}s("previousSibling",t,a,e,l,i)}},find:{ID:function(e,t,n){return"undefined"==typeof t.getElementById||n?void 0:(e=t.getElementById(e[1]))?[e]:[]},NAME:function(e,t){if("undefined"!=typeof t.getElementsByName){var n=[];t=t.getElementsByName(e[1]);
for(var r=0,i=t.length;i>r;r++)t[r].getAttribute("name")===e[1]&&n.push(t[r]);return 0===n.length?null:n}},TAG:function(e,t){return t.getElementsByTagName(e[1])}},preFilter:{CLASS:function(e,t,n,r,i,o){if(e=" "+e[1].replace(/\\\\/g,"")+" ",o)return e;o=0;for(var a;null!=(a=t[o]);o++)a&&(i^(a.className&&(" "+a.className+" ").replace(/[\\t\\n]/g," ").indexOf(e)>=0)?n||r.push(a):n&&(t[o]=!1));return!1},ID:function(e){return e[1].replace(/\\\\/g,"")},TAG:function(e){return e[1].toLowerCase()},CHILD:function(e){if("nth"===e[1]){var t=/(-?)(\\d*)n((?:\\+|-)?\\d*)/.exec("even"===e[2]&&"2n"||"odd"===e[2]&&"2n+1"||!/\\D/.test(e[2])&&"0n+"+e[2]||e[2]);e[2]=t[1]+(t[2]||1)-0,e[3]=t[3]-0}return e[0]=o++,e},ATTR:function(e,t,n,r,i,o){return t=e[1].replace(/\\\\/g,""),!o&&c.attrMap[t]&&(e[1]=c.attrMap[t]),"~="===e[2]&&(e[4]=" "+e[4]+" "),e},PSEUDO:function(e,t,n,r,o){if("not"===e[1]){if(!((i.exec(e[3])||"").length>1||/^\\w/.test(e[3])))return e=u.filter(e[3],t,n,!0^o),n||r.push.apply(r,e),!1;e[3]=u(e[3],null,null,t)}else if(c.match.POS.test(e[0])||c.match.CHILD.test(e[0]))return!0;return e},POS:function(e){return e.unshift(!0),e}},filters:{enabled:function(e){return e.disabled===!1&&"hidden"!==e.type},disabled:function(e){return e.disabled===!0},checked:function(e){return e.checked===!0},selected:function(e){return e.selected===!0},parent:function(e){return!!e.firstChild},empty:function(e){return!e.firstChild},has:function(e,t,n){return!!u(n[3],e).length},header:function(e){return/h\\d/i.test(e.nodeName)},text:function(e){return"text"===e.type},radio:function(e){return"radio"===e.type},checkbox:function(e){return"checkbox"===e.type},file:function(e){return"file"===e.type},password:function(e){return"password"===e.type},submit:function(e){return"submit"===e.type},image:function(e){return"image"===e.type},reset:function(e){return"reset"===e.type},button:function(e){return"button"===e.type||"button"===e.nodeName.toLowerCase()},input:function(e){return/input|select|textarea|button/i.test(e.nodeName)}},setFilters:{first:function(e,t){return 0===t},last:function(e,t,n,r){return t===r.length-1},even:function(e,t){return t%%2===0},odd:function(e,t){return t%%2===1},lt:function(e,t,n){return t<n[3]-0},gt:function(e,t,n){return t>n[3]-0},nth:function(e,t,n){return n[3]-0===t},eq:function(e,t,n){return n[3]-0===t}},filter:{PSEUDO:function(t,n,r,i){var o=n[1],a=c.filters[o];if(a)return a(t,r,n,i);if("contains"===o)return(t.textContent||t.innerText||e([t])||"").indexOf(n[3])>=0;if("not"===o){for(n=n[3],r=0,i=n.length;i>r;r++)if(n[r]===t)return!1;return!0}u.error("Syntax error, unrecognized expression: "+o)},CHILD:function(e,t){var n=t[1],r=e;switch(n){case"only":case"first":for(;r=r.previousSibling;)if(1===r.nodeType)return!1;if("first"===n)return!0;r=e;case"last":for(;r=r.nextSibling;)if(1===r.nodeType)return!1;return!0;case"nth":n=t[2];var i=t[3];if(1===n&&0===i)return!0;t=t[0];var o=e.parentNode;if(o&&(o.sizcache!==t||!e.nodeIndex)){var a=0;for(r=o.firstChild;r;r=r.nextSibling)1===r.nodeType&&(r.nodeIndex=++a);o.sizcache=t}return e=e.nodeIndex-i,0===n?0===e:e%%n===0&&e/n>=0}},ID:function(e,t){return 1===e.nodeType&&e.getAttribute("id")===t},TAG:function(e,t){return"*"===t&&1===e.nodeType||e.nodeName.toLowerCase()===t},CLASS:function(e,t){return(" "+(e.className||e.getAttribute("class"))+" ").indexOf(t)>-1},ATTR:function(e,t){var n=t[1];e=c.attrHandle[n]?c.attrHandle[n](e):null!=e[n]?e[n]:e.getAttribute(n),n=e+"";var r=t[2];return t=t[4],null==e?"!="===r:"="===r?n===t:"*="===r?n.indexOf(t)>=0:"~="===r?(" "+n+" ").indexOf(t)>=0:t?"!="===r?n!==t:"^="===r?0===n.indexOf(t):"$="===r?n.substr(n.length-t.length)===t:"|="===r?n===t||n.substr(0,t.length+1)===t+"-":!1:n&&e!==!1},POS:function(e,t,n,r){var i=c.setFilters[t[2]];return i?i(e,n,t,r):void 0}}},f=c.match.POS;for(var d in c.match)c.match[d]=new RegExp(c.match[d].source+/(?![^\\[]*\\])(?![^\\(]*\\))/.source),c.leftMatch[d]=new RegExp(/(^(?:.|\\r|\\n)*?)/.source+c.match[d].source.replace(/\\\\(\\d+)/g,function(e,t){return"\\\\"+(t-0+1)}));var p=function(e,t){return e=Array.prototype.slice.call(e,0),t?(t.push.apply(t,e),t):e};try{Array.prototype.slice.call(T.documentElement.childNodes,0)}catch(h){p=function(e,t){if(t=t||[],"[object Array]"===a.call(e))Array.prototype.push.apply(t,e);else if("number"==typeof e.length)for(var n=0,r=e.length;r>n;n++)t.push(e[n]);else for(n=0;e[n];n++)t.push(e[n]);return t}}var m;T.documentElement.compareDocumentPosition?m=function(e,t){return e.compareDocumentPosition&&t.compareDocumentPosition?(e=4&e.compareDocumentPosition(t)?-1:e===t?0:1,0===e&&(s=!0),e):(e==t&&(s=!0),e.compareDocumentPosition?-1:1)}:"sourceIndex"in T.documentElement?m=function(e,t){return e.sourceIndex&&t.sourceIndex?(e=e.sourceIndex-t.sourceIndex,0===e&&(s=!0),e):(e==t&&(s=!0),e.sourceIndex?-1:1)}:T.createRange&&(m=function(e,t){if(!e.ownerDocument||!t.ownerDocument)return e==t&&(s=!0),e.ownerDocument?-1:1;var n=e.ownerDocument.createRange(),r=t.ownerDocument.createRange();return n.setStart(e,0),n.setEnd(e,0),r.setStart(t,0),r.setEnd(t,0),e=n.compareBoundaryPoints(Range.START_TO_END,r),0===e&&(s=!0),e}),function(){var e=T.createElement("div"),n="script"+(new Date).getTime();e.innerHTML="<a name='"+n+"'/>";var r=T.documentElement;r.insertBefore(e,r.firstChild),T.getElementById(n)&&(c.find.ID=function(e,n,r){return"undefined"==typeof n.getElementById||r?void 0:(n=n.getElementById(e[1]))?n.id===e[1]||"undefined"!=typeof n.getAttributeNode&&n.getAttributeNode("id").nodeValue===e[1]?[n]:t:[]},c.filter.ID=function(e,t){var n="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return 1===e.nodeType&&n&&n.nodeValue===t}),r.removeChild(e),r=e=null}(),function(){var e=T.createElement("div");e.appendChild(T.createComment("")),e.getElementsByTagName("*").length>0&&(c.find.TAG=function(e,t){if(t=t.getElementsByTagName(e[1]),"*"===e[1]){e=[];for(var n=0;t[n];n++)1===t[n].nodeType&&e.push(t[n]);t=e}return t}),e.innerHTML="<a href='#'></a>",e.firstChild&&"undefined"!=typeof e.firstChild.getAttribute&&"#"!==e.firstChild.getAttribute("href")&&(c.attrHandle.href=function(e){return e.getAttribute("href",2)}),e=null}(),T.querySelectorAll&&function(){var e=u,t=T.createElement("div");if(t.innerHTML="<p class='TEST'></p>",!t.querySelectorAll||0!==t.querySelectorAll(".TEST").length){u=function(t,n,r,i){if(n=n||T,!i&&9===n.nodeType&&!y(n))try{return p(n.querySelectorAll(t),r)}catch(o){}return e(t,n,r,i)};for(var n in e)u[n]=e[n];t=null}}(),function(){var e=T.createElement("div");e.innerHTML="<div class='test e'></div><div class='test'></div>",e.getElementsByClassName&&0!==e.getElementsByClassName("e").length&&(e.lastChild.className="e",1!==e.getElementsByClassName("e").length&&(c.order.splice(1,0,"CLASS"),c.find.CLASS=function(e,t,n){return"undefined"==typeof t.getElementsByClassName||n?void 0:t.getElementsByClassName(e[1])},e=null))}();var g=T.compareDocumentPosition?function(e,t){return!!(16&e.compareDocumentPosition(t))}:function(e,t){return e!==t&&(e.contains?e.contains(t):!0)},y=function(e){return(e=(e?e.ownerDocument||e:0).documentElement)?"HTML"!==e.nodeName:!1},b=function(e,t){var n,r=[],i="";for(t=t.nodeType?[t]:t;n=c.match.PSEUDO.exec(e);)i+=n[0],e=e.replace(c.match.PSEUDO,"");e=c.relative[e]?e+"*":e,n=0;for(var o=t.length;o>n;n++)u(e,t[n],r);return u.filter(i,r)};v.find=u,v.expr=u.selectors,v.expr[":"]=v.expr.filters,v.unique=u.uniqueSort,v.text=e,v.isXMLDoc=y,v.contains=g}();var nt=/Until$/,rt=/^(?:parents|prevUntil|prevAll)/,it=/,/;O=Array.prototype.slice;var ot=function(e,t,n){if(v.isFunction(t))return v.grep(e,function(e,r){return!!t.call(e,r,e)===n});if(t.nodeType)return v.grep(e,function(e){return e===t===n});if("string"==typeof t){var r=v.grep(e,function(e){return 1===e.nodeType});if(N.test(t))return v.filter(t,r,!n);t=v.filter(t,r)}return v.grep(e,function(e){return v.inArray(e,t)>=0===n})};v.fn.extend({find:function(e){for(var t=this.pushStack("","find",e),n=0,r=0,i=this.length;i>r;r++)if(n=t.length,v.find(e,this[r],t),r>0)for(var o=n;o<t.length;o++)for(var a=0;n>a;a++)if(t[a]===t[o]){t.splice(o--,1);break}return t},has:function(e){var t=v(e);return this.filter(function(){for(var e=0,n=t.length;n>e;e++)if(v.contains(this,t[e]))return!0})},not:function(e){return this.pushStack(ot(this,e,!1),"not",e)},filter:function(e){return this.pushStack(ot(this,e,!0),"filter",e)},is:function(e){return!!e&&v.filter(e,this).length>0},closest:function(e,t){if(v.isArray(e)){var n,r,i=[],o=this[0],a={};if(o&&e.length){n=0;for(var s=e.length;s>n;n++)r=e[n],a[r]||(a[r]=v.expr.match.POS.test(r)?v(r,t||this.context):r);for(;o&&o.ownerDocument&&o!==t;){for(r in a)n=a[r],(n.jquery?n.index(o)>-1:v(o).is(n))&&(i.push({selector:r,elem:o}),delete a[r]);o=o.parentNode}}return i}var l=v.expr.match.POS.test(e)?v(e,t||this.context):null;return this.map(function(n,r){for(;r&&r.ownerDocument&&r!==t;){if(l?l.index(r)>-1:v(r).is(e))return r;r=r.parentNode}return null})},index:function(e){return e&&"string"!=typeof e?v.inArray(e.jquery?e[0]:e,this):v.inArray(this[0],e?v(e):this.parent().children())},add:function(e,t){return e="string"==typeof e?v(e,t||this.context):v.makeArray(e),t=v.merge(this.get(),e),this.pushStack(f(e[0])||f(t[0])?t:v.unique(t))},andSelf:function(){return this.add(this.prevObject)}}),v.each({parent:function(e){return(e=e.parentNode)&&11!==e.nodeType?e:null},parents:function(e){return v.dir(e,"parentNode")},parentsUntil:function(e,t,n){return v.dir(e,"parentNode",n)},next:function(e){return v.nth(e,2,"nextSibling")},prev:function(e){return v.nth(e,2,"previousSibling")},nextAll:function(e){return v.dir(e,"nextSibling")},prevAll:function(e){return v.dir(e,"previousSibling")},nextUntil:function(e,t,n){return v.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return v.dir(e,"previousSibling",n)},siblings:function(e){return v.sibling(e.parentNode.firstChild,e)},children:function(e){return v.sibling(e.firstChild)},contents:function(e){return v.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:v.makeArray(e.childNodes)}},function(e,t){v.fn[e]=function(n,r){var i=v.map(this,t,n);return nt.test(e)||(r=n),r&&"string"==typeof r&&(i=v.filter(r,i)),i=this.length>1?v.unique(i):i,(this.length>1||it.test(r))&&rt.test(e)&&(i=i.reverse()),this.pushStack(i,e,O.call(arguments).join(","))}}),v.extend({filter:function(e,t,n){return n&&(e=":not("+e+")"),v.find.matches(e,t)},dir:function(e,n,r){var i=[];for(e=e[n];e&&9!==e.nodeType&&(r===t||1!==e.nodeType||!v(e).is(r));)1===e.nodeType&&i.push(e),e=e[n];return i},nth:function(e,t,n){t=t||1;for(var r=0;e&&(1!==e.nodeType||++r!==t);e=e[n]);return e},sibling:function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});var at=/ jQuery\\d+="(?:\\d+|null)"/g,st=/^\\s+/,lt=/(<([\\w:]+)[^>]*?)\\/>/g,ut=/^(?:area|br|col|embed|hr|img|input|link|meta|param)$/i,ct=/<([\\w:]+)/,ft=/<tbody/i,dt=/<|&#?\\w+;/,pt=/<script|<object|<embed|<option|<style/i,ht=/checked\\s*(?:[^=]|=\\s*.checked.)/i,mt=function(e,t,n){return ut.test(n)?e:t+"></"+n+">"},gt={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};gt.optgroup=gt.option,gt.tbody=gt.tfoot=gt.colgroup=gt.caption=gt.thead,gt.th=gt.td,v.support.htmlSerialize||(gt._default=[1,"div<div>","</div>"]),v.fn.extend({text:function(e){return v.isFunction(e)?this.each(function(t){var n=v(this);n.text(e.call(this,t,n.text()))}):"object"!=typeof e&&e!==t?this.empty().append((this[0]&&this[0].ownerDocument||T).createTextNode(e)):v.text(this)},wrapAll:function(e){if(v.isFunction(e))return this.each(function(t){v(this).wrapAll(e.call(this,t))});if(this[0]){var t=v(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){for(var e=this;e.firstChild&&1===e.firstChild.nodeType;)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return this.each(v.isFunction(e)?function(t){v(this).wrapInner(e.call(this,t))}:function(){var t=v(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){return this.each(function(){v(this).wrapAll(e)})},unwrap:function(){return this.parent().each(function(){v.nodeName(this,"body")||v(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(e){1===this.nodeType&&this.appendChild(e)})},prepend:function(){return this.domManip(arguments,!0,function(e){1===this.nodeType&&this.insertBefore(e,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(e){this.parentNode.insertBefore(e,this)});if(arguments.length){var e=v(arguments[0]);return e.push.apply(e,this.toArray()),this.pushStack(e,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,!1,function(e){this.parentNode.insertBefore(e,this.nextSibling)});if(arguments.length){var e=this.pushStack(this,"after",arguments);return e.push.apply(e,v(arguments[0]).toArray()),e}},remove:function(e,t){for(var n,r=0;null!=(n=this[r]);r++)(!e||v.filter(e,[n]).length)&&(t||1!==n.nodeType||(v.cleanData(n.getElementsByTagName("*")),v.cleanData([n])),n.parentNode&&n.parentNode.removeChild(n));return this},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)for(1===e.nodeType&&v.cleanData(e.getElementsByTagName("*"));e.firstChild;)e.removeChild(e.firstChild);return this},clone:function(e){var t=this.map(function(){if(v.support.noCloneEvent||v.isXMLDoc(this))return this.cloneNode(!0);var e=this.outerHTML,t=this.ownerDocument;return e||(e=t.createElement("div"),e.appendChild(this.cloneNode(!0)),e=e.innerHTML),v.clean([e.replace(at,"").replace(/=([^="'>\\s]+\\/)>/g,'="$1">').replace(st,"")],t)[0]});return e===!0&&(d(this,t),d(this.find("*"),t.find("*"))),t},html:function(e){if(e===t)return this[0]&&1===this[0].nodeType?this[0].innerHTML.replace(at,""):null;if("string"!=typeof e||pt.test(e)||!v.support.leadingWhitespace&&st.test(e)||gt[(ct.exec(e)||["",""])[1].toLowerCase()])v.isFunction(e)?this.each(function(t){var n=v(this),r=n.html();n.empty().append(function(){return e.call(this,t,r)})}):this.empty().append(e);else{e=e.replace(lt,mt);try{for(var n=0,r=this.length;r>n;n++)1===this[n].nodeType&&(v.cleanData(this[n].getElementsByTagName("*")),this[n].innerHTML=e)}catch(i){this.empty().append(e)}}return this},replaceWith:function(e){return this[0]&&this[0].parentNode?v.isFunction(e)?this.each(function(t){var n=v(this),r=n.html();n.replaceWith(e.call(this,t,r))}):("string"!=typeof e&&(e=v(e).detach()),this.each(function(){var t=this.nextSibling,n=this.parentNode;v(this).remove(),t?v(t).before(e):v(n).append(e)})):this.pushStack(v(v.isFunction(e)?e():e),"replaceWith",e)},detach:function(e){return this.remove(e,!0)},domManip:function(e,n,i){function o(e){return v.nodeName(e,"table")?e.getElementsByTagName("tbody")[0]||e.appendChild(e.ownerDocument.createElement("tbody")):e}var a,s,l,u=e[0],c=[];if(!v.support.checkClone&&3===arguments.length&&"string"==typeof u&&ht.test(u))return this.each(function(){v(this).domManip(e,n,i,!0)});if(v.isFunction(u))return this.each(function(r){var o=v(this);e[0]=u.call(this,r,n?o.html():t),o.domManip(e,n,i)});if(this[0]){if(a=u&&u.parentNode,a=v.support.parentNode&&a&&11===a.nodeType&&a.childNodes.length===this.length?{fragment:a}:p(e,this,c),l=a.fragment,s=1===l.childNodes.length?l=l.firstChild:l.firstChild){n=n&&v.nodeName(s,"tr");for(var f=0,d=this.length;d>f;f++)i.call(n?o(this[f],s):this[f],f>0||a.cacheable||this.length>1?l.cloneNode(!0):l)}c.length&&v.each(c,r)}return this}}),v.fragments={},v.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){v.fn[e]=function(n){var r=[];n=v(n);var i=1===this.length&&this[0].parentNode;if(i&&11===i.nodeType&&1===i.childNodes.length&&1===n.length)return n[t](this[0]),this;i=0;for(var o=n.length;o>i;i++){var a=(i>0?this.clone(!0):this).get();v.fn[t].apply(v(n[i]),a),r=r.concat(a)}return this.pushStack(r,e,n.selector)}}),v.extend({clean:function(e,t,n,r){t=t||T,"undefined"==typeof t.createElement&&(t=t.ownerDocument||t[0]&&t[0].ownerDocument||T);for(var i,o=[],a=0;null!=(i=e[a]);a++)if("number"==typeof i&&(i+=""),i){if("string"!=typeof i||dt.test(i)){if("string"==typeof i){i=i.replace(lt,mt);var s=(ct.exec(i)||["",""])[1].toLowerCase(),l=gt[s]||gt._default,u=l[0],c=t.createElement("div");for(c.innerHTML=l[1]+i+l[2];u--;)c=c.lastChild;if(!v.support.tbody)for(u=ft.test(i),s="table"!==s||u?"<table>"!==l[1]||u?[]:c.childNodes:c.firstChild&&c.firstChild.childNodes,l=s.length-1;l>=0;--l)v.nodeName(s[l],"tbody")&&!s[l].childNodes.length&&s[l].parentNode.removeChild(s[l]);!v.support.leadingWhitespace&&st.test(i)&&c.insertBefore(t.createTextNode(st.exec(i)[0]),c.firstChild),i=c.childNodes}}else i=t.createTextNode(i);i.nodeType?o.push(i):o=v.merge(o,i)}if(n)for(a=0;o[a];a++)!r||!v.nodeName(o[a],"script")||o[a].type&&"text/javascript"!==o[a].type.toLowerCase()?(1===o[a].nodeType&&o.splice.apply(o,[a+1,0].concat(v.makeArray(o[a].getElementsByTagName("script")))),n.appendChild(o[a])):r.push(o[a].parentNode?o[a].parentNode.removeChild(o[a]):o[a]);return o},cleanData:function(e){for(var t,n,r,i=v.cache,o=v.event.special,a=v.support.deleteExpando,s=0;null!=(r=e[s]);s++)if(n=r[v.expando]){if(t=i[n],t.events)for(var l in t.events)o[l]?v.event.remove(r,l):G(r,l,t.handle);a?delete r[v.expando]:r.removeAttribute&&r.removeAttribute(v.expando),delete i[n]}}});var yt=/z-?index|font-?weight|opacity|zoom|line-?height/i,vt=/alpha\\([^)]*\\)/,bt=/opacity=([^)]*)/,xt=/float/i,Tt=/-([a-z])/gi,wt=/([A-Z])/g,Nt=/^-?\\d+(?:px)?$/i,St=/^-?\\d/,Et={position:"absolute",visibility:"hidden",display:"block"},Ct=["Left","Right"],At=["Top","Bottom"],Ft=T.defaultView&&T.defaultView.getComputedStyle,jt=v.support.cssFloat?"cssFloat":"styleFloat",Lt=function(e,t){return t.toUpperCase()};v.fn.css=function(e,n){return i(this,e,n,!0,function(e,n,r){return r===t?v.curCSS(e,n):("number"!=typeof r||yt.test(n)||(r+="px"),void v.style(e,n,r))})},v.extend({style:function(e,n,r){if(!e||3===e.nodeType||8===e.nodeType)return t;("width"===n||"height"===n)&&parseFloat(r)<0&&(r=t);var i=e.style||e,o=r!==t;return v.support.opacity||"opacity"!==n?(xt.test(n)&&(n=jt),n=n.replace(Tt,Lt),o&&(i[n]=r),i[n]):(o&&(i.zoom=1,n=parseInt(r,10)+""=="NaN"?"":"alpha(opacity="+100*r+")",e=i.filter||v.curCSS(e,"filter")||"",i.filter=vt.test(e)?e.replace(vt,n):n),i.filter&&i.filter.indexOf("opacity=")>=0?parseFloat(bt.exec(i.filter)[1])/100+"":"")},css:function(e,t,n,r){function i(){o="width"===t?e.offsetWidth:e.offsetHeight,"border"!==r&&v.each(a,function(){r||(o-=parseFloat(v.curCSS(e,"padding"+this,!0))||0),"margin"===r?o+=parseFloat(v.curCSS(e,"margin"+this,!0))||0:o-=parseFloat(v.curCSS(e,"border"+this+"Width",!0))||0})}if("width"===t||"height"===t){var o,a="width"===t?Ct:At;return 0!==e.offsetWidth?i():v.swap(e,Et,i),Math.max(0,Math.round(o))}return v.curCSS(e,t,n)},curCSS:function(e,t,n){var r,i=e.style;if(!v.support.opacity&&"opacity"===t&&e.currentStyle)return r=bt.test(e.currentStyle.filter||"")?parseFloat(RegExp.$1)/100+"":"",""===r?"1":r;if(xt.test(t)&&(t=jt),!n&&i&&i[t])r=i[t];else if(Ft){if(xt.test(t)&&(t="float"),t=t.replace(wt,"-$1").toLowerCase(),i=e.ownerDocument.defaultView,!i)return null;(e=i.getComputedStyle(e,null))&&(r=e.getPropertyValue(t)),"opacity"===t&&""===r&&(r="1")}else if(e.currentStyle&&(n=t.replace(Tt,Lt),r=e.currentStyle[t]||e.currentStyle[n],!Nt.test(r)&&St.test(r))){t=i.left;var o=e.runtimeStyle.left;e.runtimeStyle.left=e.currentStyle.left,i.left="fontSize"===n?"1em":r||0,r=i.pixelLeft+"px",i.left=t,e.runtimeStyle.left=o}return r},swap:function(e,t,n){var r={};for(var i in t)r[i]=e.style[i],e.style[i]=t[i];n.call(e);for(i in t)e.style[i]=r[i]}}),v.expr&&v.expr.filters&&(v.expr.filters.hidden=function(e){var t=e.offsetWidth,n=e.offsetHeight,r="tr"===e.nodeName.toLowerCase();return 0!==t||0!==n||r?t>0&&n>0&&!r?!1:"none"===v.curCSS(e,"display"):!0},v.expr.filters.visible=function(e){return!v.expr.filters.hidden(e)});var Dt=o(),kt=/<script(.|\\s)*?\\/script>/gi,Ot=/select|textarea/i,Mt=/color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week/i,Bt=/=\\?(&|$)/,It=/\\?/,Pt=/(\\?|&)_=.*?(&|$)/,qt=/^(\\w+:)?\\/\\/([^\\/?#]+)/,Ht=/%%20/g,Rt=v.fn.load;v.fn.extend({load:function(e,t,n){if("string"!=typeof e)return Rt.call(this,e);if(!this.length)return this;var r=e.indexOf(" ");if(r>=0){var i=e.slice(r,e.length);e=e.slice(0,r)}r="GET",t&&(v.isFunction(t)?(n=t,t=null):"object"==typeof t&&(t=v.param(t,v.ajaxSettings.traditional),r="POST"));var o=this;return v.ajax({url:e,type:r,dataType:"html",data:t,complete:function(e,t){("success"===t||"notmodified"===t)&&o.html(i?v("<div />").append(e.responseText.replace(kt,"")).find(i):e.responseText),n&&o.each(n,[e.responseText,t,e])}}),this},serialize:function(){return v.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?v.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||Ot.test(this.nodeName)||Mt.test(this.type))}).map(function(e,t){return e=v(this).val(),null==e?null:v.isArray(e)?v.map(e,function(e){return{name:t.name,value:e}}):{name:t.name,value:e}}).get()}}),v.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(e,t){v.fn[t]=function(e){return this.bind(t,e)}}),v.extend({get:function(e,t,n,r){return v.isFunction(t)&&(r=r||n,n=t,t=null),v.ajax({type:"GET",url:e,data:t,success:n,dataType:r})},getScript:function(e,t){return v.get(e,null,t,"script")},getJSON:function(e,t,n){return v.get(e,t,n,"json")},post:function(e,t,n,r){return v.isFunction(t)&&(r=r||n,n=t,t={}),v.ajax({type:"POST",url:e,data:t,success:n,dataType:r})},ajaxSetup:function(e){v.extend(v.ajaxSettings,e)},ajaxSettings:{url:location.href,global:!0,type:"GET",contentType:"application/x-www-form-urlencoded",processData:!0,async:!0,xhr:!e.XMLHttpRequest||"file:"===e.location.protocol&&e.ActiveXObject?function(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}:function(){return new e.XMLHttpRequest},accepts:{xml:"application/xml, text/xml",html:"text/html",script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},lastModified:{},etag:{},ajax:function(n){function r(){c.success&&c.success.call(f,u,l,x),c.global&&a("ajaxSuccess",[x,c])}function i(){c.complete&&c.complete.call(f,x,l),c.global&&a("ajaxComplete",[x,c]),c.global&&!--v.active&&v.event.trigger("ajaxStop")}function a(e,t){(c.context?v(c.context):v.event).trigger(e,t)}var s,l,u,c=v.extend(!0,{},v.ajaxSettings,n),f=n&&n.context||c,d=c.type.toUpperCase();if(c.data&&c.processData&&"string"!=typeof c.data&&(c.data=v.param(c.data,c.traditional)),"jsonp"===c.dataType&&("GET"===d?Bt.test(c.url)||(c.url+=(It.test(c.url)?"&":"?")+(c.jsonp||"callback")+"=?"):c.data&&Bt.test(c.data)||(c.data=(c.data?c.data+"&":"")+(c.jsonp||"callback")+"=?"),c.dataType="json"),"json"===c.dataType&&(c.data&&Bt.test(c.data)||Bt.test(c.url))&&(s=c.jsonpCallback||"jsonp"+Dt++,c.data&&(c.data=(c.data+"").replace(Bt,"="+s+"$1")),c.url=c.url.replace(Bt,"="+s+"$1"),c.dataType="script",e[s]=e[s]||function(n){u=n,r(),i(),e[s]=t;try{delete e[s]}catch(o){}m&&m.removeChild(g)}),"script"===c.dataType&&null===c.cache&&(c.cache=!1),c.cache===!1&&"GET"===d){var p=o(),h=c.url.replace(Pt,"$1_="+p+"$2");c.url=h+(h===c.url?(It.test(c.url)?"&":"?")+"_="+p:"")}if(c.data&&"GET"===d&&(c.url+=(It.test(c.url)?"&":"?")+c.data),c.global&&!v.active++&&v.event.trigger("ajaxStart"),p=(p=qt.exec(c.url))&&(p[1]&&p[1]!==location.protocol||p[2]!==location.host),"script"===c.dataType&&"GET"===d&&p){var m=T.getElementsByTagName("head")[0]||T.documentElement,g=T.createElement("script");if(g.src=c.url,c.scriptCharset&&(g.charset=c.scriptCharset),!s){var y=!1;g.onload=g.onreadystatechange=function(){y||this.readyState&&"loaded"!==this.readyState&&"complete"!==this.readyState||(y=!0,r(),i(),g.onload=g.onreadystatechange=null,m&&g.parentNode&&m.removeChild(g))}}return m.insertBefore(g,m.firstChild),t}var b=!1,x=c.xhr();if(x){c.username?x.open(d,c.url,c.async,c.username,c.password):x.open(d,c.url,c.async);try{(c.data||n&&n.contentType)&&x.setRequestHeader("Content-Type",c.contentType),c.ifModified&&(v.lastModified[c.url]&&x.setRequestHeader("If-Modified-Since",v.lastModified[c.url]),v.etag[c.url]&&x.setRequestHeader("If-None-Match",v.etag[c.url])),p||x.setRequestHeader("X-Requested-With","XMLHttpRequest"),x.setRequestHeader("Accept",c.dataType&&c.accepts[c.dataType]?c.accepts[c.dataType]+", */*":c.accepts._default)}catch(w){}if(c.beforeSend&&c.beforeSend.call(f,x,c)===!1)return c.global&&!--v.active&&v.event.trigger("ajaxStop"),x.abort(),!1;c.global&&a("ajaxSend",[x,c]);var N=x.onreadystatechange=function(e){if(x&&0!==x.readyState&&"abort"!==e){if(!b&&x&&(4===x.readyState||"timeout"===e)){b=!0,x.onreadystatechange=v.noop,l="timeout"===e?"timeout":v.httpSuccess(x)?c.ifModified&&v.httpNotModified(x,c.url)?"notmodified":"success":"error";var t;if("success"===l)try{u=v.httpData(x,c.dataType,c)}catch(n){l="parsererror",t=n}"success"===l||"notmodified"===l?s||r():v.handleError(c,x,l,t),i(),"timeout"===e&&x.abort(),c.async&&(x=null)}}else b||i(),b=!0,x&&(x.onreadystatechange=v.noop)};try{var S=x.abort;x.abort=function(){x&&S.call(x),N("abort")}}catch(E){}c.async&&c.timeout>0&&setTimeout(function(){x&&!b&&N("timeout")},c.timeout);try{x.send("POST"===d||"PUT"===d||"DELETE"===d?c.data:null)}catch(C){v.handleError(c,x,null,C),i()}return c.async||N(),x}},handleError:function(e,t,n,r){e.error&&e.error.call(e.context||e,t,n,r),e.global&&(e.context?v(e.context):v.event).trigger("ajaxError",[t,e,r])},active:0,httpSuccess:function(e){try{return!e.status&&"file:"===location.protocol||e.status>=200&&e.status<300||304===e.status||1223===e.status||0===e.status}catch(t){}return!1},httpNotModified:function(e,t){var n=e.getResponseHeader("Last-Modified"),r=e.getResponseHeader("Etag");return n&&(v.lastModified[t]=n),r&&(v.etag[t]=r),304===e.status||0===e.status},httpData:function(e,t,n){var r=e.getResponseHeader("content-type")||"",i="xml"===t||!t&&r.indexOf("xml")>=0;return e=i?e.responseXML:e.responseText,i&&"parsererror"===e.documentElement.nodeName&&v.error("parsererror"),n&&n.dataFilter&&(e=n.dataFilter(e,t)),"string"==typeof e&&("json"===t||!t&&r.indexOf("json")>=0?e=v.parseJSON(e):("script"===t||!t&&r.indexOf("javascript")>=0)&&v.globalEval(e)),e},param:function(e,n){function r(e,t){v.isArray(t)?v.each(t,function(t,o){n||/\\[\\]$/.test(e)?i(e,o):r(e+"["+("object"==typeof o||v.isArray(o)?t:"")+"]",o)}):n||null==t||"object"!=typeof t?i(e,t):v.each(t,function(t,n){r(e+"["+t+"]",n)})}function i(e,t){t=v.isFunction(t)?t():t,o[o.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)}var o=[];if(n===t&&(n=v.ajaxSettings.traditional),v.isArray(e)||e.jquery)v.each(e,function(){i(this.name,this.value)});else for(var a in e)r(a,e[a]);return o.join("&").replace(Ht,"+")}});var $t,_t={},zt=/toggle|show|hide/,Wt=/^([+-]=)?([\\d+-.]+)(.*)$/,Xt=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];v.fn.extend({show:function(e,t){if(e||0===e)return this.animate(h("show",3),e,t);for(e=0,t=this.length;t>e;e++){var n=v.data(this[e],"olddisplay");if(this[e].style.display=n||"","none"===v.css(this[e],"display")){n=this[e].nodeName;var r;if(_t[n])r=_t[n];else{var i=v("<"+n+" />").appendTo("body");r=i.css("display"),"none"===r&&(r="block"),i.remove(),_t[n]=r}v.data(this[e],"olddisplay",r)}}for(e=0,t=this.length;t>e;e++)this[e].style.display=v.data(this[e],"olddisplay")||"";return this},hide:function(e,t){if(e||0===e)return this.animate(h("hide",3),e,t);for(e=0,t=this.length;t>e;e++){var n=v.data(this[e],"olddisplay");!n&&"none"!==n&&v.data(this[e],"olddisplay",v.css(this[e],"display"))}for(e=0,t=this.length;t>e;e++)this[e].style.display="none";return this},_toggle:v.fn.toggle,toggle:function(e,t){var n="boolean"==typeof e;return v.isFunction(e)&&v.isFunction(t)?this._toggle.apply(this,arguments):null==e||n?this.each(function(){var t=n?e:v(this).is(":hidden");v(this)[t?"show":"hide"]()}):this.animate(h("toggle",3),e,t),this},fadeTo:function(e,t,n){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:t},e,n)},animate:function(e,t,n,r){var i=v.speed(t,n,r);return v.isEmptyObject(e)?this.each(i.complete):this[i.queue===!1?"each":"queue"](function(){var t,n=v.extend({},i),r=1===this.nodeType&&v(this).is(":hidden"),o=this;for(t in e){var a=t.replace(Tt,Lt);if(t!==a&&(e[a]=e[t],delete e[t],t=a),"hide"===e[t]&&r||"show"===e[t]&&!r)return n.complete.call(this);"height"!==t&&"width"!==t||!this.style||(n.display=v.css(this,"display"),n.overflow=this.style.overflow),v.isArray(e[t])&&((n.specialEasing=n.specialEasing||{})[t]=e[t][1],e[t]=e[t][0])}return null!=n.overflow&&(this.style.overflow="hidden"),n.curAnim=v.extend({},e),v.each(e,function(t,i){var a=new v.fx(o,n,t);if(zt.test(i))a["toggle"===i?r?"show":"hide":i](e);else{var s=Wt.exec(i),l=a.cur(!0)||0;if(s){i=parseFloat(s[2]);var u=s[3]||"px";"px"!==u&&(o.style[t]=(i||1)+u,l=(i||1)/a.cur(!0)*l,o.style[t]=l+u),s[1]&&(i=("-="===s[1]?-1:1)*i+l),a.custom(l,i,u)}else a.custom(l,i,"")}}),!0})},stop:function(e,t){var n=v.timers;return e&&this.queue([]),this.each(function(){for(var e=n.length-1;e>=0;e--)n[e].elem===this&&(t&&n[e](!0),n.splice(e,1))}),t||this.dequeue(),this}}),v.each({slideDown:h("show",1),slideUp:h("hide",1),slideToggle:h("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"}},function(e,t){v.fn[e]=function(e,n){return this.animate(t,e,n)}}),v.extend({speed:function(e,t,n){var r=e&&"object"==typeof e?e:{complete:n||!n&&t||v.isFunction(e)&&e,duration:e,easing:n&&t||t&&!v.isFunction(t)&&t};return r.duration=v.fx.off?0:"number"==typeof r.duration?r.duration:v.fx.speeds[r.duration]||v.fx.speeds._default,r.old=r.complete,r.complete=function(){r.queue!==!1&&v(this).dequeue(),v.isFunction(r.old)&&r.old.call(this)},r},easing:{linear:function(e,t,n,r){return n+r*e},swing:function(e,t,n,r){return(-Math.cos(e*Math.PI)/2+.5)*r+n}},timers:[],fx:function(e,t,n){this.options=t,this.elem=e,this.prop=n,t.orig||(t.orig={})}}),v.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this),(v.fx.step[this.prop]||v.fx.step._default)(this),"height"!==this.prop&&"width"!==this.prop||!this.elem.style||(this.elem.style.display="block")},cur:function(e){return null==this.elem[this.prop]||this.elem.style&&null!=this.elem.style[this.prop]?(e=parseFloat(v.css(this.elem,this.prop,e)))&&e>-1e4?e:parseFloat(v.curCSS(this.elem,this.prop))||0:this.elem[this.prop]},custom:function(e,t,n){function r(e){return i.step(e)}this.startTime=o(),this.start=e,this.end=t,this.unit=n||this.unit||"px",this.now=this.start,this.pos=this.state=0;var i=this;r.elem=this.elem,r()&&v.timers.push(r)&&!$t&&($t=setInterval(v.fx.tick,13))},show:function(){this.options.orig[this.prop]=v.style(this.elem,this.prop),this.options.show=!0,this.custom("width"===this.prop||"height"===this.prop?1:0,this.cur()),v(this.elem).show()},hide:function(){this.options.orig[this.prop]=v.style(this.elem,this.prop),this.options.hide=!0,this.custom(this.cur(),0)},step:function(e){var t=o(),n=!0;if(e||t>=this.options.duration+this.startTime){this.now=this.end,this.pos=this.state=1,this.update(),this.options.curAnim[this.prop]=!0;for(var r in this.options.curAnim)this.options.curAnim[r]!==!0&&(n=!1);if(n){if(null!=this.options.display&&(this.elem.style.overflow=this.options.overflow,e=v.data(this.elem,"olddisplay"),this.elem.style.display=e?e:this.options.display,"none"===v.css(this.elem,"display")&&(this.elem.style.display="block")),this.options.hide&&v(this.elem).hide(),this.options.hide||this.options.show)for(var i in this.options.curAnim)v.style(this.elem,i,this.options.orig[i]);
this.options.complete.call(this.elem)}return!1}return i=t-this.startTime,this.state=i/this.options.duration,e=this.options.easing||(v.easing.swing?"swing":"linear"),this.pos=v.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||e](this.state,i,0,1,this.options.duration),this.now=this.start+(this.end-this.start)*this.pos,this.update(),!0}},v.extend(v.fx,{tick:function(){for(var e=v.timers,t=0;t<e.length;t++)e[t]()||e.splice(t--,1);e.length||v.fx.stop()},stop:function(){clearInterval($t),$t=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(e){v.style(e.elem,"opacity",e.now)},_default:function(e){e.elem.style&&null!=e.elem.style[e.prop]?e.elem.style[e.prop]=("width"===e.prop||"height"===e.prop?Math.max(0,e.now):e.now)+e.unit:e.elem[e.prop]=e.now}}}),v.expr&&v.expr.filters&&(v.expr.filters.animated=function(e){return v.grep(v.timers,function(t){return e===t.elem}).length}),v.fn.offset="getBoundingClientRect"in T.documentElement?function(e){var t=this[0];if(e)return this.each(function(t){v.offset.setOffset(this,e,t)});if(!t||!t.ownerDocument)return null;if(t===t.ownerDocument.body)return v.offset.bodyOffset(t);var n=t.getBoundingClientRect(),r=t.ownerDocument;return t=r.body,r=r.documentElement,{top:n.top+(self.pageYOffset||v.support.boxModel&&r.scrollTop||t.scrollTop)-(r.clientTop||t.clientTop||0),left:n.left+(self.pageXOffset||v.support.boxModel&&r.scrollLeft||t.scrollLeft)-(r.clientLeft||t.clientLeft||0)}}:function(e){var t=this[0];if(e)return this.each(function(t){v.offset.setOffset(this,e,t)});if(!t||!t.ownerDocument)return null;if(t===t.ownerDocument.body)return v.offset.bodyOffset(t);v.offset.initialize();var n,r=t.offsetParent,i=t,o=t.ownerDocument,a=o.documentElement,s=o.body;i=(o=o.defaultView)?o.getComputedStyle(t,null):t.currentStyle;for(var l=t.offsetTop,u=t.offsetLeft;(t=t.parentNode)&&t!==s&&t!==a&&(!v.offset.supportsFixedPosition||"fixed"!==i.position);)n=o?o.getComputedStyle(t,null):t.currentStyle,l-=t.scrollTop,u-=t.scrollLeft,t===r&&(l+=t.offsetTop,u+=t.offsetLeft,!v.offset.doesNotAddBorder||v.offset.doesAddBorderForTableAndCells&&/^t(able|d|h)$/i.test(t.nodeName)||(l+=parseFloat(n.borderTopWidth)||0,u+=parseFloat(n.borderLeftWidth)||0),i=r,r=t.offsetParent),v.offset.subtractsBorderForOverflowNotVisible&&"visible"!==n.overflow&&(l+=parseFloat(n.borderTopWidth)||0,u+=parseFloat(n.borderLeftWidth)||0),i=n;return("relative"===i.position||"static"===i.position)&&(l+=s.offsetTop,u+=s.offsetLeft),v.offset.supportsFixedPosition&&"fixed"===i.position&&(l+=Math.max(a.scrollTop,s.scrollTop),u+=Math.max(a.scrollLeft,s.scrollLeft)),{top:l,left:u}},v.offset={initialize:function(){var e,t,n,r=T.body,i=T.createElement("div"),o=parseFloat(v.curCSS(r,"marginTop",!0))||0;v.extend(i.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",height:"1px",visibility:"hidden"}),i.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>",r.insertBefore(i,r.firstChild),e=i.firstChild,t=e.firstChild,n=e.nextSibling.firstChild.firstChild,this.doesNotAddBorder=5!==t.offsetTop,this.doesAddBorderForTableAndCells=5===n.offsetTop,t.style.position="fixed",t.style.top="20px",this.supportsFixedPosition=20===t.offsetTop||15===t.offsetTop,t.style.position=t.style.top="",e.style.overflow="hidden",e.style.position="relative",this.subtractsBorderForOverflowNotVisible=-5===t.offsetTop,this.doesNotIncludeMarginInBodyOffset=r.offsetTop!==o,r.removeChild(i),v.offset.initialize=v.noop},bodyOffset:function(e){var t=e.offsetTop,n=e.offsetLeft;return v.offset.initialize(),v.offset.doesNotIncludeMarginInBodyOffset&&(t+=parseFloat(v.curCSS(e,"marginTop",!0))||0,n+=parseFloat(v.curCSS(e,"marginLeft",!0))||0),{top:t,left:n}},setOffset:function(e,t,n){/static/.test(v.curCSS(e,"position"))&&(e.style.position="relative");var r=v(e),i=r.offset(),o=parseInt(v.curCSS(e,"top",!0),10)||0,a=parseInt(v.curCSS(e,"left",!0),10)||0;v.isFunction(t)&&(t=t.call(e,n,i)),n={top:t.top-i.top+o,left:t.left-i.left+a},"using"in t?t.using.call(e,n):r.css(n)}},v.fn.extend({position:function(){if(!this[0])return null;var e=this[0],t=this.offsetParent(),n=this.offset(),r=/^body|html$/i.test(t[0].nodeName)?{top:0,left:0}:t.offset();return n.top-=parseFloat(v.curCSS(e,"marginTop",!0))||0,n.left-=parseFloat(v.curCSS(e,"marginLeft",!0))||0,r.top+=parseFloat(v.curCSS(t[0],"borderTopWidth",!0))||0,r.left+=parseFloat(v.curCSS(t[0],"borderLeftWidth",!0))||0,{top:n.top-r.top,left:n.left-r.left}},offsetParent:function(){return this.map(function(){for(var e=this.offsetParent||T.body;e&&!/^body|html$/i.test(e.nodeName)&&"static"===v.css(e,"position");)e=e.offsetParent;return e})}}),v.each(["Left","Top"],function(e,n){var r="scroll"+n;v.fn[r]=function(n){var i,o=this[0];return o?n!==t?this.each(function(){(i=m(this))?i.scrollTo(e?v(i).scrollLeft():n,e?n:v(i).scrollTop()):this[r]=n}):(i=m(o))?"pageXOffset"in i?i[e?"pageYOffset":"pageXOffset"]:v.support.boxModel&&i.document.documentElement[r]||i.document.body[r]:o[r]:null}}),v.each(["Height","Width"],function(e,n){var r=n.toLowerCase();v.fn["inner"+n]=function(){return this[0]?v.css(this[0],r,!1,"padding"):null},v.fn["outer"+n]=function(e){return this[0]?v.css(this[0],r,!1,e?"margin":"border"):null},v.fn[r]=function(e){var i=this[0];return i?v.isFunction(e)?this.each(function(t){var n=v(this);n[r](e.call(this,t,n[r]()))}):"scrollTo"in i&&i.document?"CSS1Compat"===i.document.compatMode&&i.document.documentElement["client"+n]||i.document.body["client"+n]:9===i.nodeType?Math.max(i.documentElement["client"+n],i.body["scroll"+n],i.documentElement["scroll"+n],i.body["offset"+n],i.documentElement["offset"+n]):e===t?v.css(i,r):this.css(r,"string"==typeof e?e:e+"px"):null==e?null:this}}),e.jQuery=e.$=v}(window);
</script>
<script type="text/javascript">
!function($){$.extend({tablesorter:new function(){function benchmark(e,t){log(e+","+((new Date).getTime()-t.getTime())+"ms")}function log(e){"undefined"!=typeof console&&"undefined"!=typeof console.debug?console.log(e):alert(e)}function buildParserCache(e,t){if(e.config.debug)var r="";if(0!=e.tBodies.length){var n=e.tBodies[0].rows;if(n[0])for(var o=[],a=n[0].cells,i=a.length,s=0;i>s;s++){var d=!1;$.metadata&&$(t[s]).metadata()&&$(t[s]).metadata().sorter?d=getParserById($(t[s]).metadata().sorter):e.config.headers[s]&&e.config.headers[s].sorter&&(d=getParserById(e.config.headers[s].sorter)),d||(d=detectParserForColumn(e,n,-1,s)),e.config.debug&&(r+="column:"+s+" parser:"+d.id+"\\n"),o.push(d)}return e.config.debug&&log(r),o}}function detectParserForColumn(e,t,r,n){for(var o=parsers.length,a=!1,i=!1,s=!0;""==i&&s;)r++,t[r]?(a=getNodeFromRowAndCellIndex(t,r,n),i=trimAndGetNodeText(e.config,a),e.config.debug&&log("Checking if value was empty on row:"+r)):s=!1;for(var d=1;o>d;d++)if(parsers[d].is(i,e,a))return parsers[d];return parsers[0]}function getNodeFromRowAndCellIndex(e,t,r){return e[t].cells[r]}function trimAndGetNodeText(e,t){return $.trim(getElementText(e,t))}function getParserById(e){for(var t=parsers.length,r=0;t>r;r++)if(parsers[r].id.toLowerCase()==e.toLowerCase())return parsers[r];return!1}function buildCache(e){if(e.config.debug)var t=new Date;for(var r=e.tBodies[0]&&e.tBodies[0].rows.length||0,n=e.tBodies[0].rows[0]&&e.tBodies[0].rows[0].cells.length||0,o=e.config.parsers,a={row:[],normalized:[]},i=0;r>i;++i){var s=$(e.tBodies[0].rows[i]),d=[];if(s.hasClass(e.config.cssChildRow))a.row[a.row.length-1]=a.row[a.row.length-1].add(s);else{a.row.push(s);for(var c=0;n>c;++c)d.push(o[c].format(getElementText(e.config,s[0].cells[c]),e,s[0].cells[c]));d.push(a.normalized.length),a.normalized.push(d),d=null}}return e.config.debug&&benchmark("Building cache for "+r+" rows:",t),a}function getElementText(e,t){var r="";return t?(e.supportsTextContent||(e.supportsTextContent=t.textContent||!1),r="simple"==e.textExtraction?e.supportsTextContent?t.textContent:t.childNodes[0]&&t.childNodes[0].hasChildNodes()?t.childNodes[0].innerHTML:t.innerHTML:"function"==typeof e.textExtraction?e.textExtraction(t):$(t).text()):""}function appendToTable(e,t){if(e.config.debug)var r=new Date;for(var n=t,o=n.row,a=n.normalized,i=a.length,s=a[0].length-1,d=$(e.tBodies[0]),c=[],l=0;i>l;l++){var u=a[l][s];if(c.push(o[u]),!e.config.appender)for(var f=o[u].length,h=0;f>h;h++)d[0].appendChild(o[u][h])}e.config.appender&&e.config.appender(e,c),c=null,e.config.debug&&benchmark("Rebuilt table:",r),applyWidget(e),setTimeout(function(){$(e).trigger("sortEnd")},0)}function buildHeaders(e){if(e.config.debug)var t=new Date;var r=($.metadata?!0:!1,computeTableHeaderCellIndexes(e));return $tableHeaders=$(e.config.selectorHeaders,e).each(function(t){if(this.column=r[this.parentNode.rowIndex+"-"+this.cellIndex],this.order=formatSortingOrder(e.config.sortInitialOrder),this.count=this.order,(checkHeaderMetadata(this)||checkHeaderOptions(e,t))&&(this.sortDisabled=!0),checkHeaderOptionsSortingLocked(e,t)&&(this.order=this.lockedOrder=checkHeaderOptionsSortingLocked(e,t)),!this.sortDisabled){var n=$(this).addClass(e.config.cssHeader);e.config.onRenderHeader&&e.config.onRenderHeader.apply(n)}e.config.headerList[t]=this}),e.config.debug&&(benchmark("Built headers:",t),log($tableHeaders)),$tableHeaders}function computeTableHeaderCellIndexes(e){for(var t=[],r={},n=e.getElementsByTagName("THEAD")[0],o=n.getElementsByTagName("TR"),a=0;a<o.length;a++)for(var i=o[a].cells,s=0;s<i.length;s++){var d,c=i[s],l=c.parentNode.rowIndex,u=l+"-"+c.cellIndex,f=c.rowSpan||1,h=c.colSpan||1;"undefined"==typeof t[l]&&(t[l]=[]);for(var g=0;g<t[l].length+1;g++)if("undefined"==typeof t[l][g]){d=g;break}r[u]=d;for(var g=l;l+f>g;g++){"undefined"==typeof t[g]&&(t[g]=[]);for(var m=t[g],p=d;d+h>p;p++)m[p]="x"}}return r}function checkCellColSpan(e,t,r){for(var n=[],o=e.tHead.rows,a=o[r].cells,i=0;i<a.length;i++){var s=a[i];s.colSpan>1?n=n.concat(checkCellColSpan(e,headerArr,r++)):(1==e.tHead.length||s.rowSpan>1||!o[r+1])&&n.push(s)}return n}function checkHeaderMetadata(e){return $.metadata&&$(e).metadata().sorter===!1?!0:!1}function checkHeaderOptions(e,t){return e.config.headers[t]&&e.config.headers[t].sorter===!1?!0:!1}function checkHeaderOptionsSortingLocked(e,t){return e.config.headers[t]&&e.config.headers[t].lockedOrder?e.config.headers[t].lockedOrder:!1}function applyWidget(e){for(var t=e.config.widgets,r=t.length,n=0;r>n;n++)getWidgetById(t[n]).format(e)}function getWidgetById(e){for(var t=widgets.length,r=0;t>r;r++)if(widgets[r].id.toLowerCase()==e.toLowerCase())return widgets[r]}function formatSortingOrder(e){return"Number"!=typeof e?"desc"==e.toLowerCase()?1:0:1==e?1:0}function isValueInArray(e,t){for(var r=t.length,n=0;r>n;n++)if(t[n][0]==e)return!0;return!1}function setHeadersCss(e,t,r,n){t.removeClass(n[0]).removeClass(n[1]);var o=[];t.each(function(){this.sortDisabled||(o[this.column]=$(this))});for(var a=r.length,i=0;a>i;i++)o[r[i][0]].addClass(n[r[i][1]])}function fixColumnWidth(e){var t=e.config;if(t.widthFixed){var r=$("<colgroup>");$("tr:first td",e.tBodies[0]).each(function(){r.append($("<col>").css("width",$(this).width()))}),$(e).prepend(r)}}function updateHeaderSortCount(e,t){for(var r=e.config,n=t.length,o=0;n>o;o++){var a=t[o],i=r.headerList[a[0]];i.count=a[1],i.count++}}function multisort(table,sortList,cache){if(table.config.debug)var sortTime=new Date;for(var dynamicExp="var sortWrapper = function(a,b) {",l=sortList.length,i=0;l>i;i++){var c=sortList[i][0],order=sortList[i][1],s="text"==table.config.parsers[c].type?0==order?makeSortFunction("text","asc",c):makeSortFunction("text","desc",c):0==order?makeSortFunction("numeric","asc",c):makeSortFunction("numeric","desc",c),e="e"+i;dynamicExp+="var "+e+" = "+s,dynamicExp+="if("+e+") { return "+e+"; } ",dynamicExp+="else { "}var orgOrderCol=cache.normalized[0].length-1;dynamicExp+="return a["+orgOrderCol+"]-b["+orgOrderCol+"];";for(var i=0;l>i;i++)dynamicExp+="}; ";return dynamicExp+="return 0; ",dynamicExp+="}; ",table.config.debug&&benchmark("Evaling expression:"+dynamicExp,new Date),eval(dynamicExp),cache.normalized.sort(sortWrapper),table.config.debug&&benchmark("Sorting on "+sortList.toString()+" and dir "+order+" time:",sortTime),cache}function makeSortFunction(e,t,r){var n="a["+r+"]",o="b["+r+"]";return"text"==e&&"asc"==t?"("+n+" == "+o+" ? 0 : ("+n+" === null ? Number.POSITIVE_INFINITY : ("+o+" === null ? Number.NEGATIVE_INFINITY : ("+n+" < "+o+") ? -1 : 1 )));":"text"==e&&"desc"==t?"("+n+" == "+o+" ? 0 : ("+n+" === null ? Number.POSITIVE_INFINITY : ("+o+" === null ? Number.NEGATIVE_INFINITY : ("+o+" < "+n+") ? -1 : 1 )));":"numeric"==e&&"asc"==t?"("+n+" === null && "+o+" === null) ? 0 :("+n+" === null ? Number.POSITIVE_INFINITY : ("+o+" === null ? Number.NEGATIVE_INFINITY : "+n+" - "+o+"));":"numeric"==e&&"desc"==t?"("+n+" === null && "+o+" === null) ? 0 :("+n+" === null ? Number.POSITIVE_INFINITY : ("+o+" === null ? Number.NEGATIVE_INFINITY : "+o+" - "+n+"));":void 0}function makeSortText(e){return"((a["+e+"] < b["+e+"]) ? -1 : ((a["+e+"] > b["+e+"]) ? 1 : 0));"}function makeSortTextDesc(e){return"((b["+e+"] < a["+e+"]) ? -1 : ((b["+e+"] > a["+e+"]) ? 1 : 0));"}function makeSortNumeric(e){return"a["+e+"]-b["+e+"];"}function makeSortNumericDesc(e){return"b["+e+"]-a["+e+"];"}function sortText(e,t){return table.config.sortLocaleCompare?e.localeCompare(t):t>e?-1:e>t?1:0}function sortTextDesc(e,t){return table.config.sortLocaleCompare?t.localeCompare(e):e>t?-1:t>e?1:0}function sortNumeric(e,t){return e-t}function sortNumericDesc(e,t){return t-e}function getCachedSortType(e,t){return e[t].type}var parsers=[],widgets=[];this.defaults={cssHeader:"header",cssAsc:"headerSortUp",cssDesc:"headerSortDown",cssChildRow:"expand-child",sortInitialOrder:"asc",sortMultiSortKey:"shiftKey",sortForce:null,sortAppend:null,sortLocaleCompare:!0,textExtraction:"simple",parsers:{},widgets:[],widgetZebra:{css:["even","odd"]},headers:{},widthFixed:!1,cancelSelection:!0,sortList:[],headerList:[],dateFormat:"us",decimal:"/.|,/g",onRenderHeader:null,selectorHeaders:"thead th",debug:!1},this.benchmark=benchmark,this.construct=function(e){return this.each(function(){if(this.tHead&&this.tBodies){var t,r,n,o;this.config={},o=$.extend(this.config,$.tablesorter.defaults,e),t=$(this),$.data(this,"tablesorter",o),r=buildHeaders(this),this.config.parsers=buildParserCache(this,r),n=buildCache(this);var a=[o.cssDesc,o.cssAsc];fixColumnWidth(this),r.click(function(e){var i=t[0].tBodies[0]&&t[0].tBodies[0].rows.length||0;if(!this.sortDisabled&&i>0){t.trigger("sortStart");var s=($(this),this.column);if(this.order=this.count++%%2,this.lockedOrder&&(this.order=this.lockedOrder),e[o.sortMultiSortKey])if(isValueInArray(s,o.sortList))for(var d=0;d<o.sortList.length;d++){var c=o.sortList[d],l=o.headerList[c[0]];c[0]==s&&(l.count=c[1],l.count++,c[1]=l.count%%2)}else o.sortList.push([s,this.order]);else{if(o.sortList=[],null!=o.sortForce)for(var u=o.sortForce,d=0;d<u.length;d++)u[d][0]!=s&&o.sortList.push(u[d]);o.sortList.push([s,this.order])}return setTimeout(function(){setHeadersCss(t[0],r,o.sortList,a),appendToTable(t[0],multisort(t[0],o.sortList,n))},1),!1}}).mousedown(function(){return o.cancelSelection?(this.onselectstart=function(){return!1},!1):void 0}),t.bind("update",function(){var e=this;setTimeout(function(){e.config.parsers=buildParserCache(e,r),n=buildCache(e)},1)}).bind("updateCell",function(e,t){var r=this.config,o=[t.parentNode.rowIndex-1,t.cellIndex];n.normalized[o[0]][o[1]]=r.parsers[o[1]].format(getElementText(r,t),t)}).bind("sorton",function(e,t){$(this).trigger("sortStart"),o.sortList=t;var i=o.sortList;updateHeaderSortCount(this,i),setHeadersCss(this,r,i,a),appendToTable(this,multisort(this,i,n))}).bind("appendCache",function(){appendToTable(this,n)}).bind("applyWidgetId",function(e,t){getWidgetById(t).format(this)}).bind("applyWidgets",function(){applyWidget(this)}),$.metadata&&$(this).metadata()&&$(this).metadata().sortlist&&(o.sortList=$(this).metadata().sortlist),o.sortList.length>0&&t.trigger("sorton",[o.sortList]),applyWidget(this)}})},this.addParser=function(e){for(var t=parsers.length,r=!0,n=0;t>n;n++)parsers[n].id.toLowerCase()==e.id.toLowerCase()&&(r=!1);r&&parsers.push(e)},this.addWidget=function(e){widgets.push(e)},this.formatFloat=function(e){var t=parseFloat(e);return isNaN(t)?0:t},this.formatInt=function(e){var t=parseInt(e);return isNaN(t)?0:t},this.isDigit=function(e){return/^[-+]?\\d*$/.test($.trim(e.replace(/[,.']/g,"")))},this.clearTableBody=function(e){function t(){for(;this.firstChild;)this.removeChild(this.firstChild)}$.browser.msie?t.apply(e.tBodies[0]):e.tBodies[0].innerHTML=""}}}),$.fn.extend({tablesorter:$.tablesorter.construct});var ts=$.tablesorter;ts.addParser({id:"text",is:function(){return!0},format:function(e){return $.trim(e.toLocaleLowerCase())},type:"text"}),ts.addParser({id:"digit",is:function(e,t){var r=t.config;return $.tablesorter.isDigit(e,r)},format:function(e){return $.tablesorter.formatFloat(e)},type:"numeric"}),ts.addParser({id:"ipAddress",is:function(e){return/^\\d{2,3}[\\.]\\d{2,3}[\\.]\\d{2,3}[\\.]\\d{2,3}$/.test(e)},format:function(e){for(var t=e.split("."),r="",n=t.length,o=0;n>o;o++){var a=t[o];r+=2==a.length?"0"+a:a}return $.tablesorter.formatFloat(r)},type:"numeric"}),ts.addParser({id:"url",is:function(e){return/^(https?|ftp|file):\\/\\/$/.test(e)},format:function(e){return jQuery.trim(e.replace(new RegExp(/(https?|ftp|file):\\/\\//),""))},type:"text"}),ts.addParser({id:"isoDate",is:function(e){return/^\\d{4}[\\/-]\\d{1,2}[\\/-]\\d{1,2}$/.test(e)},format:function(e){return $.tablesorter.formatFloat(""!=e?new Date(e.replace(new RegExp(/-/g),"/")).getTime():"0")},type:"numeric"}),ts.addParser({id:"percent",is:function(e){return/\\%%$/.test($.trim(e))},format:function(e){return $.tablesorter.formatFloat(e.replace(new RegExp(/%%/g),""))},type:"numeric"}),ts.addParser({id:"usLongDate",is:function(e){return e.match(new RegExp(/^[A-Za-z]{3,10}\\.? [0-9]{1,2}, ([0-9]{4}|'?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\\s(AM|PM)))$/))},format:function(e){return $.tablesorter.formatFloat(new Date(e).getTime())},type:"numeric"}),ts.addParser({id:"shortDate",is:function(e){return/\\d{1,2}[\\/\\-]\\d{1,2}[\\/\\-]\\d{2,4}/.test(e)},format:function(e,t){var r=t.config;return e=e.replace(/\\-/g,"/"),"us"==r.dateFormat?e=e.replace(/(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{4})/,"$3/$1/$2"):"uk"==r.dateFormat?e=e.replace(/(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{4})/,"$3/$2/$1"):("dd/mm/yy"==r.dateFormat||"dd-mm-yy"==r.dateFormat)&&(e=e.replace(/(\\d{1,2})[\\/\\-](\\d{1,2})[\\/\\-](\\d{2})/,"$1/$2/$3")),$.tablesorter.formatFloat(new Date(e).getTime())},type:"numeric"}),ts.addParser({id:"time",is:function(e){return/^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\\s(am|pm)))$/.test(e)},format:function(e){return $.tablesorter.formatFloat(new Date("2000/01/01 "+e).getTime())},type:"numeric"}),ts.addParser({id:"metadata",is:function(){return!1},format:function(e,t,r){var n=t.config,o=n.parserMetadataName?n.parserMetadataName:"sortValue";return $(r).metadata()[o]},type:"numeric"}),ts.addWidget({id:"zebra",format:function(e){if(e.config.debug)var t=new Date;var r,n,o=-1;$("tr:visible",e.tBodies[0]).each(function(){r=$(this),r.hasClass(e.config.cssChildRow)||o++,n=o%%2==0,r.removeClass(e.config.widgetZebra.css[n?0:1]).addClass(e.config.widgetZebra.css[n?1:0])}),e.config.debug&&$.tablesorter.benchmark("Applying Zebra widget",t)}})}(jQuery);
</script>
<script type="text/javascript">
$(document).ready(function() 
    { 
        $(".sortable").tablesorter(); 
    } 
); 
</script>
<style>
body{background-color:#fff;color:#000;}
hr{background-color:#000;border:0;color:#000;}
hr.heavy{height:5px;}
hr.light{height:1px;}
img{border:0;display:block;}
img.right{margin:0 0 0 auto;}
img.center{border:0;margin:0 auto;}
table th,table td{padding:4px;}
.center,header{text-align:center;}
table.center {margin-left:auto; margin-right:auto;}
.right{text-align:right;}
.left{text-align:left;}
.tableborder,.tableborder td,.tableborder th{border:1px solid #000;}
.underline{text-decoration:underline;}
/* tables */
table.sortable {
  font-family:arial;
  background-color: #CDCDCD;
  margin:10px 0pt 15px;
  font-size: 8pt;
  /*width: 100%%;*/
  text-align: left;
}
table.sortable td {
  border: 0px solid #FFF;
}
table.sortable thead tr th, table.sortable tfoot tr th {
  background-color: #e6EEEE;
  border: 1px solid #FFF;
  font-size: 8pt;
  padding: 4px;
  margin-right: 100px;
}
table.sortable thead tr .header {
  cursor: pointer;
}
table.sortable thead tr .header:after {
  content: "\\00A0 \\00A0 \\2716";
}
table.sortable tbody td {
  color: #3D3D3D;
  padding: 4px;
  background-color: #FFF;
  vertical-align: top;
}
table.sortable tbody tr.odd td {
  background-color:#F0F0F6;
}
/*table.sortable thead tr .headerSortUp {
  background-image: url(asc.gif);
}
table.sortable thead tr .headerSortDown {
  background-image: url(desc.gif);
}*/
table.sortable thead tr .headerSortUp:after {
  content:"\\00A0 \\00A0 \\25B2";
}
table.sortable thead tr .headerSortDown:after {
  content:"\\00A0 \\00A0 \\25BC";
}
table.sortable thead tr .headerSortDown, table.sortable thead tr .headerSortUp {
background-color: #8dbdd8;
}
</style>
</head>
<body>
<header>
<hgroup>
<h1>%(HEADER1)s</h1>
<h2>%(HEADER2)s</h2>
<h3>%(HEADER3)s</h3>
</hgroup>
</header>
<article>
""",

    'html5css': """\
<!DOCTYPE html>
<html>
<head>
<meta charset="%(ENCODING)s">
<title>%(HEADER1)s</title>
<meta name="generator" content="http://txt2tags.org">
<link rel="stylesheet" href="%(STYLE)s">
</head>
<body>
<header>
<hgroup>
<h1>%(HEADER1)s</h1>
<h2>%(HEADER2)s</h2>
<h3>%(HEADER3)s</h3>
</hgroup>
</header>
<article>
""",

    'htmls': """\
<!DOCTYPE html>
<html>
<head>
<meta charset="%(ENCODING)s">
<title>%(HEADER1)s</title>
<meta name="generator" content="http://txt2tags.org">
<link rel="stylesheet" href="%(STYLE)s">
<style>
body{background-color:#fff;color:#000;}
hr{background-color:#000;border:0;color:#000;}
hr.heavy{height:5px;}
hr.light{height:1px;}
img{border:0;display:block;}
img.right{margin:0 0 0 auto;}
table,img.center{border:0;margin:0 auto;}
table th,table td{padding:4px;}
.center,header{text-align:center;}
.right{text-align:right;}
.tableborder,.tableborder td,.tableborder th{border:1px solid #000;}
.underline{text-decoration:underline;}
</style>
</head>
<body>
<article>
""",

    'xhtml': """\
<?xml version="1.0"
      encoding="%(ENCODING)s"
?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"\
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>%(HEADER1)s</title>
<meta name="generator" content="http://txt2tags.org" />
<link rel="stylesheet" type="text/css" href="%(STYLE)s" />
</head>
<body bgcolor="white" text="black">
<div align="center">
<h1>%(HEADER1)s</h1>
<h2>%(HEADER2)s</h2>
<h3>%(HEADER3)s</h3>
</div>
""",

    'xhtmlcss': """\
<?xml version="1.0"
      encoding="%(ENCODING)s"
?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"\
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>%(HEADER1)s</title>
<meta name="generator" content="http://txt2tags.org" />
<link rel="stylesheet" type="text/css" href="%(STYLE)s" />
</head>
<body>

<div class="header" id="header">
<h1>%(HEADER1)s</h1>
<h2>%(HEADER2)s</h2>
<h3>%(HEADER3)s</h3>
</div>
""",

    'xhtmls': """\
<?xml version="1.0"
      encoding="%(ENCODING)s"
?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"\
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>%(HEADER1)s</title>
<meta name="generator" content="http://txt2tags.org" />
<link rel="stylesheet" type="text/css" href="%(STYLE)s" />
<style type="text/css">body {background-color:#FFFFFF ; color:#000000}</style>
</head>
<body>
<div style="text-align:center">
<h1>%(HEADER1)s</h1>
<h2>%(HEADER2)s</h2>
<h3>%(HEADER3)s</h3>
</div>
""",

    'xhtmlscss': """\
<?xml version="1.0"
      encoding="%(ENCODING)s"
?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"\
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>%(HEADER1)s</title>
<meta name="generator" content="http://txt2tags.org" />
<link rel="stylesheet" type="text/css" href="%(STYLE)s" />
</head>
<body>

<div class="header" id="header">
<h1>%(HEADER1)s</h1>
<h2>%(HEADER2)s</h2>
<h3>%(HEADER3)s</h3>
</div>
""",

    'dbk': """\
<?xml version="1.0"
      encoding="%(ENCODING)s"
?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"\
 "docbook/dtd/xml/4.5/docbookx.dtd">
<article lang="en">
  <articleinfo>
    <title>%(HEADER1)s</title>
    <authorgroup>
      <author><othername>%(HEADER2)s</othername></author>
    </authorgroup>
    <date>%(HEADER3)s</date>
  </articleinfo>
""",

    'man': """\
.TH "%(HEADER1)s" 1 "%(HEADER3)s" "%(HEADER2)s"
""",

    'utmac': """\
.DT "%(HEADER1)s"
.DA "%(HEADER2)s"
.DI "%(HEADER3)s"
.H1 "%(HEADER1)s"
.H* "%(HEADER2)s"
.
.\\" txt2tags shortcuts
.ds url \\W'\\\\$2'\\\\$1\\W
.ds mail \\W'mailto:\\\\$2'\\\\$1\\W
.ds underl \\Z'\\\\$*'\\v'.25m'\\l"\\w'\\\\$*'u"\\v'-.25m'
.ds strike \\Z'\\\\$*'\\v'-.25m'\\l"\w'\\\\$*'u"\\v'.25m'
.\\"ds underl \\X'SetColor blue'\\\\$1\\X'SetColor black'
.\\"ds strike \\X'SetColor red'\\\\$1\\X'SetColor black'
.\
""",


# TODO style to <HR>
    'pm6': """\
<PMTags1.0 win><C-COLORTABLE ("Preto" 1 0 0 0)
><@Normal=
  <FONT "Times New Roman"><CCOLOR "Preto"><SIZE 11>
  <HORIZONTAL 100><LETTERSPACE 0><CTRACK 127><CSSIZE 70><C+SIZE 58.3>
  <C-POSITION 33.3><C+POSITION 33.3><P><CBASELINE 0><CNOBREAK 0><CLEADING -0.05>
  <GGRID 0><GLEFT 7.2><GRIGHT 0><GFIRST 0><G+BEFORE 7.2><G+AFTER 0>
  <GALIGNMENT "justify"><GMETHOD "proportional"><G& "ENGLISH">
  <GPAIRS 12><G%% 120><GKNEXT 0><GKWIDOW 0><GKORPHAN 0><GTABS $>
  <GHYPHENATION 2 34 0><GWORDSPACE 75 100 150><GSPACE -5 0 25>
><@Bullet=<@-PARENT "Normal"><FONT "Abadi MT Condensed Light">
  <GLEFT 14.4><G+BEFORE 2.15><G%% 110><GTABS(25.2 l "")>
><@PreFormat=<@-PARENT "Normal"><FONT "Lucida Console"><SIZE 8><CTRACK 0>
  <GLEFT 0><G+BEFORE 0><GALIGNMENT "left"><GWORDSPACE 100 100 100><GSPACE 0 0 0>
><@Title1=<@-PARENT "Normal"><FONT "Arial"><SIZE 14><B>
  <GCONTENTS><GLEFT 0><G+BEFORE 0><GALIGNMENT "left">
><@Title2=<@-PARENT "Title1"><SIZE 12><G+BEFORE 3.6>
><@Title3=<@-PARENT "Title1"><SIZE 10><GLEFT 7.2><G+BEFORE 7.2>
><@Title4=<@-PARENT "Title3">
><@Title5=<@-PARENT "Title3">
><@Quote=<@-PARENT "Normal"><SIZE 10><I>>

%(HEADER1)s
%(HEADER2)s
%(HEADER3)s
""",
    'vimwiki': """\
%%title %(HEADER1)s
## by %(HEADER2)s in %(HEADER3)s
%%toc %(HEADER1)s
""",
    'mgp': """\
#!/usr/X11R6/bin/mgp -t 90
%%deffont "normal"    xfont  "utopia-medium-r", charset "iso8859-1"
%%deffont "normal-i"  xfont  "utopia-medium-i", charset "iso8859-1"
%%deffont "normal-b"  xfont  "utopia-bold-r"  , charset "iso8859-1"
%%deffont "normal-bi" xfont  "utopia-bold-i"  , charset "iso8859-1"
%%deffont "mono"      xfont "courier-medium-r", charset "iso8859-1"
%%default 1 size 5
%%default 2 size 8, fore "yellow", font "normal-b", center
%%default 3 size 5, fore "white",  font "normal", left, prefix "  "
%%tab 1 size 4, vgap 30, prefix "     ", icon arc "red" 40, leftfill
%%tab 2 prefix "            ", icon arc "orange" 40, leftfill
%%tab 3 prefix "                   ", icon arc "brown" 40, leftfill
%%tab 4 prefix "                          ", icon arc "darkmagenta" 40, leftfill
%%tab 5 prefix "                                ", icon arc "magenta" 40, leftfill
%%%%------------------------- end of headers -----------------------------
%%page





%%size 10, center, fore "yellow"
%(HEADER1)s

%%font "normal-i", size 6, fore "white", center
%(HEADER2)s

%%font "mono", size 7, center
%(HEADER3)s
""",

    'moin': """\
'''%(HEADER1)s'''

''%(HEADER2)s''

%(HEADER3)s
""",

    'gwiki': """\
*%(HEADER1)s*

%(HEADER2)s

_%(HEADER3)s_
""",

    'adoc': """\
= %(HEADER1)s
%(HEADER2)s
%(HEADER3)s
""",

    'doku': """\
===== %(HEADER1)s =====

**//%(HEADER2)s//**

//%(HEADER3)s//
""",

    'pmw': """\
(:Title %(HEADER1)s:)

(:Description %(HEADER2)s:)

(:Summary %(HEADER3)s:)
""",

    'wiki': """\
'''%(HEADER1)s'''

%(HEADER2)s

''%(HEADER3)s''
""",

    'red': """\
h1. %(HEADER1)s

Author: %(HEADER2)s
Date: %(HEADER3)s
""",

    'tex': \
r"""\documentclass{article}
\usepackage{graphicx}
\usepackage{paralist} %% needed for compact lists
\usepackage[normalem]{ulem} %% needed by strike
\usepackage[urlcolor=blue,colorlinks=true]{hyperref}
\usepackage[%(ENCODING)s]{inputenc}  %% char encoding
\usepackage{%(STYLE)s}  %% user defined

\title{%(HEADER1)s}
\author{%(HEADER2)s}
\begin{document}
\date{%(HEADER3)s}
\maketitle
\clearpage
""",
    'texs': \
r"""\documentclass{article}
\usepackage{graphicx}
\usepackage[urlcolor=black,colorlinks=true]{hyperref}
\usepackage[%(ENCODING)s]{inputenc}  %% char encoding
\usepackage{%(STYLE)s}  %% user defined

\begin{document}
""",

    'lout': """\
@SysInclude { doc }
@Document
  @InitialFont { Times Base 12p }  # Times, Courier, Helvetica, ...
  @PageOrientation { Portrait }    # Portrait, Landscape
  @ColumnNumber { 1 }              # Number of columns (2, 3, ...)
  @PageHeaders { Simple }          # None, Simple, Titles, NoTitles
  @InitialLanguage { English }     # German, French, Portuguese, ...
  @OptimizePages { Yes }           # Yes/No smart page break feature
//
@Text @Begin
@Display @Heading { %(HEADER1)s }
@Display @I { %(HEADER2)s }
@Display { %(HEADER3)s }
#@NP                               # Break page after Headers
""",

# @SysInclude { tbl }                   # Tables support
# setup: @MakeContents { Yes }          # show TOC
# setup: @SectionGap                    # break page at each section

    'creole': """\
%(HEADER1)s
%(HEADER2)s
%(HEADER3)s
""",

    'md': """\
%(HEADER1)s
%(HEADER2)s
%(HEADER3)s
""",

    'bbcode': """\
%(HEADER1)s
%(HEADER2)s
%(HEADER3)s
""",

    'spip': """\
{{{%(HEADER1)s}}}

{{%(HEADER2)s}}

{%(HEADER3)s}

""",

    'rtf': \
r"""{\rtf1\ansi\ansicpg1252\deff0
{\fonttbl
{\f0\froman Times;}
{\f1\fswiss Arial;}
{\f2\fmodern Courier;}
}
{\colortbl;\red0\green0\blue255;}
{\stylesheet
{\s1\sbasedon222\snext1\f0\fs24\cf0 Normal;}
{\s2\sbasedon1\snext2{\*\txttags paragraph}\f0\fs24\qj\sb0\sa0\sl480\slmult1\li0\ri0\fi360 Body Text;}
{\s3\sbasedon2\snext3{\*\txttags verbatim}\f2\fs20\ql\sb0\sa240\sl240\slmult1\li720\ri720\fi0 Verbatim;}
{\s4\sbasedon2\snext4{\*\txttags quote}\f0\fs24\qj\sb0\sa0\sl480\slmult1\li720\ri720\fi0 Block Quote;}
{\s10\sbasedon1\snext10\keepn{\*\txttags maintitle}\f1\fs24\qc\sb0\sa0\sl480\slmult1\li0\ri0\fi0 Title;}
{\s11\sbasedon1\snext2\keepn{\*\txttags title1}\f1\fs24\qc\sb240\sa240\sl480\slmult1\li0\ri0\fi0\b Heading 1;}
{\s12\sbasedon11\snext2\keepn{\*\txttags title2}\f1\fs24\ql\sb240\sa240\sl480\slmult1\li0\ri0\fi0\b Heading 2;}
{\s13\sbasedon11\snext2\keepn{\*\txttags title3}\f1\fs24\ql\sb240\sa240\sl480\slmult1\li360\ri0\fi0\b Heading 3;}
{\s14\sbasedon11\snext2\keepn{\*\txttags title4}\f1\fs24\ql\sb240\sa240\sl480\slmult1\li360\ri0\fi0\b\i Heading 4;}
{\s15\sbasedon11\snext2\keepn{\*\txttags title5}\f1\fs24\ql\sb240\sa240\sl480\slmult1\li360\ri0\fi0\i Heading 5;}
{\s21\sbasedon2\snext21{\*\txttags list}\f0\fs24\qj\sb0\sa0\sl480\slmult1{\*\txttags list indent}\li720\ri0\fi-360 List;}
}
{\*\listtable
{\list\listtemplateid1
{\listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\'95;}{\levelnumbers;}{\*\txttags list indent}\li720\ri0\fi-360}
{\listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\'95;}{\levelnumbers;}{\*\txttags list indent}\li1080\ri0\fi-360}
{\listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\'95;}{\levelnumbers;}{\*\txttags list indent}\li1440\ri0\fi-360}
{\listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\'95;}{\levelnumbers;}{\*\txttags list indent}\li1800\ri0\fi-360}
{\listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\'95;}{\levelnumbers;}{\*\txttags list indent}\li2160\ri0\fi-360}
{\listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\'95;}{\levelnumbers;}{\*\txttags list indent}\li2520\ri0\fi-360}
{\listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\'95;}{\levelnumbers;}{\*\txttags list indent}\li2880\ri0\fi-360}
{\listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\'95;}{\levelnumbers;}{\*\txttags list indent}\li3240\ri0\fi-360}
{\listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\'95;}{\levelnumbers;}{\*\txttags list indent}\li3600\ri0\fi-360}
\listid1}
{\list\listtemplateid2
{\listlevel\levelnfc0\leveljc0\levelstartat1\levelfollow0{\leveltext \'02\'00.;}{\levelnumbers\'01;}{\*\txttags list indent}\li720\ri0\fi-360}
{\listlevel\levelnfc0\leveljc0\levelstartat1\levelfollow0{\leveltext \'02\'01.;}{\levelnumbers\'01;}{\*\txttags list indent}\li1080\ri0\fi-360}
{\listlevel\levelnfc0\leveljc0\levelstartat1\levelfollow0{\leveltext \'02\'02.;}{\levelnumbers\'01;}{\*\txttags list indent}\li1440\ri0\fi-360}
{\listlevel\levelnfc0\leveljc0\levelstartat1\levelfollow0{\leveltext \'02\'03.;}{\levelnumbers\'01;}{\*\txttags list indent}\li1800\ri0\fi-360}
{\listlevel\levelnfc0\leveljc0\levelstartat1\levelfollow0{\leveltext \'02\'04.;}{\levelnumbers\'01;}{\*\txttags list indent}\li2160\ri0\fi-360}
{\listlevel\levelnfc0\leveljc0\levelstartat1\levelfollow0{\leveltext \'02\'05.;}{\levelnumbers\'01;}{\*\txttags list indent}\li2520\ri0\fi-360}
{\listlevel\levelnfc0\leveljc0\levelstartat1\levelfollow0{\leveltext \'02\'06.;}{\levelnumbers\'01;}{\*\txttags list indent}\li2880\ri0\fi-360}
{\listlevel\levelnfc0\leveljc0\levelstartat1\levelfollow0{\leveltext \'02\'07.;}{\levelnumbers\'01;}{\*\txttags list indent}\li3240\ri0\fi-360}
{\listlevel\levelnfc0\leveljc0\levelstartat1\levelfollow0{\leveltext \'02\'08.;}{\levelnumbers\'01;}{\*\txttags list indent}\li3600\ri0\fi-360}
\listid2}
{\list\listtemplateid3
{\listlevel\levelnfc0\leveljc1\levelstartat1\levelfollow1{\leveltext \'02\'00.;}{\levelnumbers\'01;}}
{\listlevel\levelnfc0\leveljc1\levelstartat1\levelfollow1{\leveltext \'04\'00.\'01.;}{\levelnumbers\'01\'03;}}
{\listlevel\levelnfc0\leveljc1\levelstartat1\levelfollow1{\leveltext \'06\'00.\'01.\'02.;}{\levelnumbers\'01\'03\'05;}}
{\listlevel\levelnfc0\leveljc1\levelstartat1\levelfollow1{\leveltext \'08\'00.\'01.\'02.\'03.;}{\levelnumbers\'01\'03\'05\'07;}}
{\listlevel\levelnfc0\leveljc1\levelstartat1\levelfollow1{\leveltext \'10\'00.\'01.\'02.\'03.\'04.;}{\levelnumbers\'01\'03\'05\'07\'09;}}
{\listlevel\levelnfc0\leveljc1\levelstartat1\levelfollow1{\leveltext \'02\'05.;}{\levelnumbers\'01;}}
{\listlevel\levelnfc0\leveljc1\levelstartat1\levelfollow1{\leveltext \'02\'06.;}{\levelnumbers\'01;}}
{\listlevel\levelnfc0\leveljc1\levelstartat1\levelfollow1{\leveltext \'02\'07.;}{\levelnumbers\'01;}}
{\listlevel\levelnfc0\leveljc1\levelstartat1\levelfollow0{\leveltext \'02\'08.;}{\levelnumbers\'01;}}
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info
{\title %(HEADER1)s }
{\author %(HEADER2)s }
}
\deflang1033\widowctrl\hyphauto\uc1\fromtext
\paperw12240\paperh15840
\margl1440\margr1440\margt1440\margb1440
\sectd
{\header\pard\qr\plain\f0 Page \chpgn\par}
{\pard\plain\s10\keepn{\*\txttags maintitle}\f1\fs24\qc\sb2880\sa0\sl480\slmult1\li0\ri0\fi0 %(HEADER1)s\par}
{\pard\plain\s10\keepn{\*\txttags maintitle}\f1\fs24\qc\sb0\sa0\sl480\slmult1\li0\ri0\fi0 %(HEADER2)s\par}
{\pard\plain\s10\keepn{\*\txttags maintitle}\f1\fs24\qc\sb0\sa0\sl480\slmult1\li0\ri0\fi0 %(HEADER3)s\par}
""",
    'wp': """\
%(HEADER1)s
%(HEADER2)s
%(HEADER3)s
""",
    'wpcss': """\
%(HEADER1)s
%(HEADER2)s
%(HEADER3)s
""",
    'tml': """\
---+!! %(HEADER1)s
*%(HEADER2)s* %%BR%% __%(HEADER3)s__
""",
## MOM ##
#
# "mom" is a sort of "LaTeX" for groff and has a lot of macro
# commands and variables to customize for specific needs.
# These few lines of commands are sufficient anyway for a good
# postscript typesetted document (and so also pdf): the author
# of "mom" is a professional typographer so the typesetting
# defaults are pleasant and sane.  See mom's author site:
# http://www.schaffter.ca/mom/mom-01.html that's a good
# example of documentation too!
# NB: \# are commented lines in groff.
# I put here a lot of options, commented or not, to let you
# see the possibilities but there many more...
# NB: use "-k" option for groff if input/output is UTF-8
#
# usage: groff -k -m mom sample.mom > sample.ps
#
    'mom': """\
\# Cover and title
.TITLE "%(HEADER1)s"
.AUTHOR "%(HEADER2)s"
\#.DOCTITLE \" ONLY to collate different files (sections, chapters etc.)
.SUBTITLE "%(HEADER3)s"
\#
\# printstyle: typeset or typewrite it's MANDATORY!
.PRINTSTYLE TYPESET
\#.PRINTSTYLE TYPEWRITE
\#
\# doctype: default, chapter, user-defined, letter (commented is "default")
\#.DOCTYPE DEFAULT
\#
\# copystyle: draft or final
.COPYSTYLE FINAL
\#.COPYSTYLE DRAFT
\#
\# Default values for some strings
\# They're valid in every printstyle or copystyle
\# Here are MY defaults (italian)
\# For a more general use I think they should be groff commented
\#
\#.CHAPTER_STRING "Capitolo"
\#.ATTRIBUTE_STRING "di"
\#.TOC_HEADER_STRING "Indice"
\#.ENDNOTE_TITLE "Note"
\#
\# section break char "#" for 1 time (LINEBREAK)
\#.LINEBREAK_CHAR # 1
\# a null end string
.FINIS_STRING ""
\#
\# Typesetting values
\# These are all MY preferences! Comment out for default.
\#
.PAPER A4
\# Left margin (c=centimeters)
\#.L_MARGIN 2.8c
\# Length of line (it's for 62 chars a line for point size 12 in typewrite style)
\#.LL 15.75c
\# Palatino groff font, better than Times for reading. IMHO
.FAMILY P
.PT_SIZE 12
\# line spacing
.LS 18
\# left aligned (mom macro defaults to "both aligned")
.QUAD L
\# No hyphenation
.HY OFF
\# Header and footer sizes
.HEADER_SIZE -1
.FOOTER_SIZE -1
.PAGENUM_SIZE -2
\#
\# Other options
\#
\# Indent space for "quote" and "blockquote" (defaults are good too!)
\#.QUOTE_INDENT 2
\#.BLOCKQUOTE_INDENT 2
\#
\# Footnotes
\#
\# Next gives you superscript numbers (use STAR for symbols, it's default)
\# use additional argument NO_SUPERSCRIPT for typewrite printstyle
\#.FOOTNOTE_MARKER_STYLE NUMBER
\# Cover title at about 1/3 from top
\#.DOCHEADER_ADVANCE 7.5c
\#
\# Double quotes italian style! aka << and >> It works only for "typeset" printstyle
\#.SMARTQUOTES IT
\# Next cmd is MANDATORY.
.START
""",

}

for target in TARGETS_LIST:
    HEADER_TEMPLATE[target] = getattr(getattr(targets, target), 'HEADER', '')
    HEADER_TEMPLATE[target + 'css'] = getattr(getattr(targets, target), 'HEADERCSS', '')

# Generated files are easier to edit with the DZSlides engine at the end, but breaks W3C validator.
AAPW_FOOT = """\
</html>
<style>
  html { background-color: black; }
  body { background-color: white; }
  /* A section is a slide. It's size is 800x600, and this will never change */
  section {
      font-family: monospace;
      font-size: 18px;
  }

/*  footer {
    position: absolute;
    bottom: 10px;
    right: 20px;
  } */

  /* Transition effect */
  /* Feel free to change the transition effect for original
     animations. See here:
     https://developer.mozilla.org/en/CSS/CSS_transitions
     How to use CSS3 Transitions: */
  section {
      -moz-transition: top 400ms linear 0s;
      -webkit-transition: top 400ms linear 0s;
      -ms-transition: top 400ms linear 0s;
      transition: top 400ms linear 0s;
  }

  /* Before */
  section { left: -150%; }
  /* Now */
  section[aria-selected] { left: 0; }
  /* After */
  section[aria-selected] ~ section { left: +150%; }

  /* Incremental elements */

  /* By default, visible */
  .incremental > * { opacity: 1; }

  /* The current item */
  .incremental > *[aria-selected] { color: red; opacity: 1; }

  /* The items to-be-selected */
  .incremental > *[aria-selected] ~ * { opacity: 0.2; }

</style>

 <!-- {{{{ dzslides core
#
#
#     __  __  __       .  __   ___  __
#    |  \  / /__` |    | |  \ |__  /__`
#    |__/ /_ .__/ |___ | |__/ |___ .__/ core :(
#
#
# The following block of code is not supposed to be edited.
# But if you want to change the behavior of these slides,
# feel free to hack it!
#
-->

<!-- Default Style -->
<style>
  * { margin: 0; padding: 0; }
  details { display: none; }
  body {
    width: 800px; height: 600px;
    margin-left: -400px; margin-top: -300px;
    position: absolute; top: 50%; left: 50%;
    overflow: hidden;
  }
  section {
    position: absolute;
    pointer-events: none;
    width: 100%; height: 100%;
  }
  section[aria-selected] { pointer-events: auto; }
  html { overflow: hidden; }
  body { display: none; }
  body.loaded { display: block; }
  .incremental {visibility: hidden; }
  .incremental[active] {visibility: visible; }
</style>

<script>
  var Dz = {
    remoteWindows: [],
    idx: -1,
    step: 0,
    slides: null,
    params: {
      autoplay: "1"
    }
  };

  Dz.init = function() {
    document.body.className = "loaded";
    this.slides = $$("body > section");
    this.setupParams();
    this.onhashchange();
    this.setupTouchEvents();
    this.onresize();
  }
  
  Dz.setupParams = function() {
    var p = window.location.search.substr(1).split('&');
    p.forEach(function(e, i, a) {
      var keyVal = e.split('=');
      Dz.params[keyVal[0]] = decodeURIComponent(keyVal[1]);
    });
  }

  Dz.onkeydown = function(aEvent) {
    // Don't intercept keyboard shortcuts
    if (aEvent.altKey
      || aEvent.ctrlKey
      || aEvent.metaKey
      || aEvent.shiftKey) {
      return;
    }
    if ( aEvent.keyCode == 37 // left arrow
      || aEvent.keyCode == 38 // up arrow
      || aEvent.keyCode == 33 // page up
    ) {
      aEvent.preventDefault();
      this.back();
    }
    if ( aEvent.keyCode == 39 // right arrow
      || aEvent.keyCode == 40 // down arrow
      || aEvent.keyCode == 34 // page down
    ) {
      aEvent.preventDefault();
      this.forward();
    }
    if (aEvent.keyCode == 35) { // end
      aEvent.preventDefault();
      this.goEnd();
    }
    if (aEvent.keyCode == 36) { // home
      aEvent.preventDefault();
      this.goStart();
    }
    if (aEvent.keyCode == 32) { // space
      aEvent.preventDefault();
      this.toggleContent();
    }
  }

  /* Touch Events */

  Dz.setupTouchEvents = function() {
    var orgX, newX;
    var tracking = false;

    var db = document.body;
    db.addEventListener("touchstart", start.bind(this), false);
    db.addEventListener("touchmove", move.bind(this), false);

    function start(aEvent) {
      aEvent.preventDefault();
      tracking = true;
      orgX = aEvent.changedTouches[0].pageX;
    }

    function move(aEvent) {
      if (!tracking) return;
      newX = aEvent.changedTouches[0].pageX;
      if (orgX - newX > 100) {
        tracking = false;
        this.forward();
      } else {
        if (orgX - newX < -100) {
          tracking = false;
          this.back();
        }
      }
    }
  }

  /* Adapt the size of the slides to the window */

  Dz.onresize = function() {
    var db = document.body;
    var sx = db.clientWidth / window.innerWidth;
    var sy = db.clientHeight / window.innerHeight;
    var transform = "scale(" + (1/Math.max(sx, sy)) + ")";

    db.style.MozTransform = transform;
    db.style.WebkitTransform = transform;
    db.style.OTransform = transform;
    db.style.msTransform = transform;
    db.style.transform = transform;
  }


  Dz.getDetails = function(aIdx) {
    var s = $("section:nth-of-type(" + aIdx + ")");
    var d = s.$("details");
    return d ? d.innerHTML : "";
  }

  Dz.onmessage = function(aEvent) {
    var argv = aEvent.data.split(" "), argc = argv.length;
    argv.forEach(function(e, i, a) { a[i] = decodeURIComponent(e) });
    var win = aEvent.source;
    if (argv[0] === "REGISTER" && argc === 1) {
      this.remoteWindows.push(win);
      this.postMsg(win, "REGISTERED", document.title, this.slides.length);
      this.postMsg(win, "CURSOR", this.idx + "." + this.step);
      return;
    }
    if (argv[0] === "BACK" && argc === 1)
      this.back();
    if (argv[0] === "FORWARD" && argc === 1)
      this.forward();
    if (argv[0] === "START" && argc === 1)
      this.goStart();
    if (argv[0] === "END" && argc === 1)
      this.goEnd();
    if (argv[0] === "TOGGLE_CONTENT" && argc === 1)
      this.toggleContent();
    if (argv[0] === "SET_CURSOR" && argc === 2)
      window.location.hash = "#" + argv[1];
    if (argv[0] === "GET_CURSOR" && argc === 1)
      this.postMsg(win, "CURSOR", this.idx + "." + this.step);
    if (argv[0] === "GET_NOTES" && argc === 1)
      this.postMsg(win, "NOTES", this.getDetails(this.idx));
  }

  Dz.toggleContent = function() {
    // If a Video is present in this new slide, play it.
    // If a Video is present in the previous slide, stop it.
    var s = $("section[aria-selected]");
    if (s) {
      var video = s.$("video");
      if (video) {
        if (video.ended || video.paused) {
          video.play();
        } else {
          video.pause();
        }
      }
    }
  }

  Dz.setCursor = function(aIdx, aStep) {
    // If the user change the slide number in the URL bar, jump
    // to this slide.
    aStep = (aStep != 0 && typeof aStep !== "undefined") ? "." + aStep : ".0";
    window.location.hash = "#" + aIdx + aStep;
  }

  Dz.onhashchange = function() {
    var cursor = window.location.hash.split("#"),
        newidx = 1,
        newstep = 0;
    if (cursor.length == 2) {
      newidx = ~~cursor[1].split(".")[0];
      newstep = ~~cursor[1].split(".")[1];
      if (newstep > Dz.slides[newidx - 1].$$('.incremental > *').length) {
        newstep = 0;
        newidx++;
      }
    }
    if (newidx != this.idx) {
      this.setSlide(newidx);
    }
    if (newstep != this.step) {
      this.setIncremental(newstep);
    }
    for (var i = 0; i < this.remoteWindows.length; i++) {
      this.postMsg(this.remoteWindows[i], "CURSOR", this.idx + "." + this.step);
    }
  }

  Dz.back = function() {
    if (this.idx == 1 && this.step == 0) {
      return;
    }
    if (this.step == 0) {
      this.setCursor(this.idx - 1,
                     this.slides[this.idx - 2].$$('.incremental > *').length);
    } else {
      this.setCursor(this.idx, this.step - 1);
    }
  }

  Dz.forward = function() {
    if (this.idx >= this.slides.length &&
        this.step >= this.slides[this.idx - 1].$$('.incremental > *').length) {
        return;
    }
    if (this.step >= this.slides[this.idx - 1].$$('.incremental > *').length) {
      this.setCursor(this.idx + 1, 0);
    } else {
      this.setCursor(this.idx, this.step + 1);
    }
  }

  Dz.goStart = function() {
    this.setCursor(1, 0);
  }

  Dz.goEnd = function() {
    var lastIdx = this.slides.length;
    var lastStep = this.slides[lastIdx - 1].$$('.incremental > *').length;
    this.setCursor(lastIdx, lastStep);
  }

  Dz.setSlide = function(aIdx) {
    this.idx = aIdx;
    var old = $("section[aria-selected]");
    var next = $("section:nth-of-type("+ this.idx +")");
    if (old) {
      old.removeAttribute("aria-selected");
      var video = old.$("video");
      if (video) {
        video.pause();
      }
    }
    if (next) {
      next.setAttribute("aria-selected", "true");
      var video = next.$("video");
      if (video && !!+this.params.autoplay) {
        video.play();
      }
    } else {
      // That should not happen
      this.idx = -1;
      // console.warn("Slide doesn't exist.");
    }
  }

  Dz.setIncremental = function(aStep) {
    this.step = aStep;
    var old = this.slides[this.idx - 1].$('.incremental > *[aria-selected]');
    if (old) {
      old.removeAttribute('aria-selected');
    }
    var incrementals = this.slides[this.idx - 1].$$('.incremental');
    if (this.step <= 0) {
      incrementals.forEach(function(aNode) {
        aNode.removeAttribute('active');
      });
      return;
    }
    var next = this.slides[this.idx - 1].$$('.incremental > *')[this.step - 1];
    if (next) {
      next.setAttribute('aria-selected', true);
      next.parentNode.setAttribute('active', true);
      var found = false;
      incrementals.forEach(function(aNode) {
        if (aNode != next.parentNode)
          if (found)
            aNode.removeAttribute('active');
          else
            aNode.setAttribute('active', true);
        else
          found = true;
      });
    } else {
      setCursor(this.idx, 0);
    }
    return next;
  }
  
  Dz.postMsg = function(aWin, aMsg) { // [arg0, [arg1...]]
    aMsg = [aMsg];
    for (var i = 2; i < arguments.length; i++)
      aMsg.push(encodeURIComponent(arguments[i]));
    aWin.postMessage(aMsg.join(" "), "*");
  }

  function init() {
    Dz.init();
    window.onkeydown = Dz.onkeydown.bind(Dz);
    window.onresize = Dz.onresize.bind(Dz);
    window.onhashchange = Dz.onhashchange.bind(Dz);
    window.onmessage = Dz.onmessage.bind(Dz);
  }

  window.onload = init;
</script>


<script> // Helpers
  if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {

      // closest thing possible to the ECMAScript 5 internal IsCallable
      // function 
      if (typeof this !== "function")
      throw new TypeError(
        "Function.prototype.bind - what is trying to be fBound is not callable"
      );

      var aArgs = Array.prototype.slice.call(arguments, 1),
          fToBind = this,
          fNOP = function () {},
          fBound = function () {
            return fToBind.apply( this instanceof fNOP ? this : oThis || window,
                   aArgs.concat(Array.prototype.slice.call(arguments)));
          };

      fNOP.prototype = this.prototype;
      fBound.prototype = new fNOP();

      return fBound;
    };
  }

  var $ = (HTMLElement.prototype.$ = function(aQuery) {
    return this.querySelector(aQuery);
  }).bind(document);

  var $$ = (HTMLElement.prototype.$$ = function(aQuery) {
    return this.querySelectorAll(aQuery);
  }).bind(document);

  NodeList.prototype.forEach = function(fun) {
    if (typeof fun !== "function") throw new TypeError();
    for (var i = 0; i < this.length; i++) {
      fun.call(this, this[i]);
    }
  }

</script>
"""

##############################################################################


def getTags(config):
    "Returns all the known tags for the specified target"

    keys = """
    title1              numtitle1
    title2              numtitle2
    title3              numtitle3
    title4              numtitle4
    title5              numtitle5
    title1Open          title1Close
    title2Open          title2Close
    title3Open          title3Close
    title4Open          title4Close
    title5Open          title5Close
    blocktitle1Open     blocktitle1Close
    blocktitle2Open     blocktitle2Close
    blocktitle3Open     blocktitle3Close

    paragraphOpen       paragraphClose
    blockVerbOpen       blockVerbClose  blockVerbLine
    blockQuoteOpen      blockQuoteClose blockQuoteLine
    blockVerbSep
    blockCommentOpen    blockCommentClose

    fontMonoOpen        fontMonoClose
    fontBoldOpen        fontBoldClose
    fontItalicOpen      fontItalicClose
    fontUnderlineOpen   fontUnderlineClose
    fontStrikeOpen      fontStrikeClose

    listOpen            listClose
    listOpenCompact     listCloseCompact
    listItemOpen        listItemClose     listItemLine
    numlistOpen         numlistClose
    numlistOpenCompact  numlistCloseCompact
    numlistItemOpen     numlistItemClose  numlistItemLine
    deflistOpen         deflistClose
    deflistOpenCompact  deflistCloseCompact
    deflistItem1Open    deflistItem1Close
    deflistItem2Open    deflistItem2Close deflistItem2LinePrefix

    bar1                bar2
    url                 urlMark      urlMarkAnchor   urlImg
    email               emailMark
    img                 imgAlignLeft  imgAlignRight  imgAlignCenter
                       _imgAlignLeft _imgAlignRight _imgAlignCenter

    tableOpen           tableClose
    _tableBorder        _tableAlignLeft      _tableAlignCenter
    tableRowOpen        tableRowClose        tableRowSep
    tableTitleRowOpen   tableTitleRowClose
    tableCellOpen       tableCellClose       tableCellSep
    tableTitleCellOpen  tableTitleCellClose  tableTitleCellSep
    _tableColAlignLeft  _tableColAlignRight  _tableColAlignCenter
    tableCellAlignLeft  tableCellAlignRight  tableCellAlignCenter
    _tableCellAlignLeft _tableCellAlignRight _tableCellAlignCenter
    _tableCellColSpan   tableColAlignSep
    _tableCellColSpanChar                    _tableCellBorder
    _tableCellMulticolOpen
    _tableCellMulticolClose
    tableCellHead       tableTitleCellHead

    bodyOpen            bodyClose
    cssOpen             cssClose
    tocOpen             tocClose             TOC
    anchor
    comment
    pageBreak
    EOD
    """.split()

    # TIP: \a represents the current text inside the mark
    # TIP: ~A~, ~B~ and ~C~ are expanded to other tags parts

    alltags = {

    'aat': {
        'title1'               : '\a'                     ,
        'title2'               : '\a'                     ,
        'title3'               : '\a'                     ,
        'title4'               : '\a'                     ,
        'title5'               : '\a'                     ,
        'blockQuoteLine'       : '        '               ,
        'listItemOpen'         : AA['bullet'] + ' '       ,
        'numlistItemOpen'      : '\a. '                   ,
        'bar1'                 : aa_line(AA['bar1'], config['width']),
        'bar2'                 : aa_line(AA['bar2'], config['width']),
        'url'                  : '\a'                     ,
        'urlMark'              : '\a[\a]'                 ,
        'email'                : '\a'                     ,
        'emailMark'            : '\a[\a]'                 ,
        'img'                  : '[\a]'                   ,
        'imgEmbed'             : '\a'                     ,
        'fontBoldOpen'         : '*'                      ,
        'fontBoldClose'        : '*'                      ,
        'fontItalicOpen'       : '/'                      ,
        'fontItalicClose'      : '/'                      ,
        'fontUnderlineOpen'    : '_'                      ,
        'fontUnderlineClose'   : '_'                      ,
        'fontStrikeOpen'       : '-'                      ,
        'fontStrikeClose'      : '-'                      ,
    },

    'rst': {
        'title1'               : '\a'                     ,
        'title2'               : '\a'                     ,
        'title3'               : '\a'                     ,
        'title4'               : '\a'                     ,
        'title5'               : '\a'                     ,
        'blockVerbOpen'        : '::\n'                   ,
        'blockQuoteLine'       : '    '                   ,
        'listItemOpen'         : RST['bullet'] + ' '      ,
        'numlistItemOpen'      : '\a. '                   ,
        'bar1'                 : aa_line(RST['bar1'], 10) ,
        'url'                  : '\a'                     ,
        'urlMark'              : '`\a <\a>`_'             ,
        'email'                : '\a'                     ,
        'emailMark'            : '`\a <\a>`_'             ,
        'img'                  : '\n\n.. image:: \a\n   :align: ~A~\n\nENDIMG',
        'urlImg'               : '\n   :target: '         ,
        '_imgAlignLeft'        : 'left'                   ,
        '_imgAlignCenter'      : 'center'                 ,
        '_imgAlignRight'       : 'right'                  ,
        'fontMonoOpen'         : '``'                     ,
        'fontMonoClose'        : '``'                     ,
        'fontBoldOpen'         : '**'                     ,
        'fontBoldClose'        : '**'                     ,
        'fontItalicOpen'       : '*'                      ,
        'fontItalicClose'      : '*'                      ,
        'comment'              : '.. \a'                  ,
        'TOC'                  : '\n.. contents::'        ,
    },

    'txt': {
        'title1'               : '  \a'      ,
        'title2'               : '\t\a'      ,
        'title3'               : '\t\t\a'    ,
        'title4'               : '\t\t\t\a'  ,
        'title5'               : '\t\t\t\t\a',
        'blockQuoteLine'       : '\t'        ,
        'listItemOpen'         : '- '        ,
        'numlistItemOpen'      : '\a. '      ,
        'bar1'                 : '\a'        ,
        'url'                  : '\a'        ,
        'urlMark'              : '\a (\a)'   ,
        'email'                : '\a'        ,
        'emailMark'            : '\a (\a)'   ,
        'img'                  : '[\a]'      ,
    },

    'csv': {
        'tableCellSep' : CSV['separator'] ,
        'tableCellOpen' : CSV.get('quotechar') or '' ,
        'tableCellClose' : CSV.get('quotechar') or '' ,
    },
    'csvs': {
        #TIP csvs inherits all csv tags
    },

    'db': {
    },

    'txt2t': {
        'title1' : '         = \a =~A~' ,
        'title2' : '        == \a ==~A~' ,
        'title3' : '       === \a ===~A~' ,
        'title4' : '      ==== \a ====~A~' ,
        'title5' : '     ===== \a =====~A~' ,
        'numtitle1' : '         + \a +~A~' ,
        'numtitle2' : '        ++ \a ++~A~' ,
        'numtitle3' : '       +++ \a +++~A~' ,
        'numtitle4' : '      ++++ \a ++++~A~' ,
        'numtitle5' : '     +++++ \a +++++~A~' ,
        'anchor' : '[\a]',
        'blockVerbOpen' : '```' ,
        'blockVerbClose' : '```' ,
        'blockQuoteLine' : '\t' ,
        'blockCommentOpen' : '%%%' ,
        'blockCommentClose' : '%%%' ,
        'fontMonoOpen' : '``' ,
        'fontMonoClose' : '``' ,
        'fontBoldOpen' : '**' ,
        'fontBoldClose' : '**' ,
        'fontItalicOpen' : '//' ,
        'fontItalicClose' : '//' ,
        'fontUnderlineOpen' : '__' ,
        'fontUnderlineClose' : '__' ,
        'fontStrikeOpen' : '--' ,
        'fontStrikeClose' : '--' ,
        'listItemOpen' : '- ' ,
        'numlistItemOpen' : '+ ' ,
        'deflistItem1Open' : ': ' ,
        'listClose': '-',
        'numlistClose': '+',
        'deflistClose': ':',
        'bar1' : '-------------------------' ,
        'bar2' : '=========================' ,
        'url' : '\a' ,
        'urlMark' : '[\a \a]' ,
        #'urlMarkAnchor' : '' ,
        'email' : '\a' ,
        'emailMark' : '[\a \a]' ,
        'img' : '[\a]' ,
        '_tableBorder' : '|' ,
        '_tableAlignLeft' : '' ,
        '_tableAlignCenter' : '   ' ,
        'tableRowOpen' : '~A~' ,
        'tableRowClose' : '~B~' ,
#        'tableRowSep' : '' ,
        'tableTitleRowOpen' : '~A~|' ,
        'tableCellOpen' : '| ' ,
        'tableCellClose' : ' ~S~' ,
#        'tableCellSep' : '' ,
        'tableCellAlignLeft' : '\a  ' ,
        'tableCellAlignRight' : '  \a' ,
        'tableCellAlignCenter' : '  \a  ' ,
#        '_tableCellColSpan' : '' ,
        '_tableCellColSpanChar' : '|' ,
        'comment' : '% \a' ,
    },

    'ods': {
        'tableOpen'            : '<table:table table:name="' + _('Sheet') + 'n_table">',
        'tableClose'           : '</table:table>'                  ,
        'tableRowOpen'         : '<table:table-row>'               ,
        'tableRowClose'        : '</table:table-row>'              ,
        'tableCellOpen'        : '<table:table-cell><text:p>'      ,
        'tableCellClose'       : '</text:p></table:table-cell>'    ,
        'EOD'                  : '</office:spreadsheet></office:body></office:document>',
    },

    'html': {
        'paragraphOpen'        : '<P>'            ,
        'paragraphClose'       : '</P>'           ,
        'title1'               : '<H1~A~>\a</H1>' ,
        'title2'               : '<H2~A~>\a</H2>' ,
        'title3'               : '<H3~A~>\a</H3>' ,
        'title4'               : '<H4~A~>\a</H4>' ,
        'title5'               : '<H5~A~>\a</H5>' ,
        'anchor'               : ' ID="\a"',
        'blockVerbOpen'        : '<PRE>'          ,
        'blockVerbClose'       : '</PRE>'         ,
        'blockQuoteOpen'       : '<BLOCKQUOTE>'   ,
        'blockQuoteClose'      : '</BLOCKQUOTE>'  ,
        'fontMonoOpen'         : '<CODE>'         ,
        'fontMonoClose'        : '</CODE>'        ,
        'fontBoldOpen'         : '<B>'            ,
        'fontBoldClose'        : '</B>'           ,
        'fontItalicOpen'       : '<I>'            ,
        'fontItalicClose'      : '</I>'           ,
        'fontUnderlineOpen'    : '<U>'            ,
        'fontUnderlineClose'   : '</U>'           ,
        'fontStrikeOpen'       : '<S>'            ,
        'fontStrikeClose'      : '</S>'           ,
        'listOpen'             : '<UL>'           ,
        'listClose'            : '</UL>'          ,
        'listItemOpen'         : '<LI>'           ,
        'numlistOpen'          : '<OL>'           ,
        'numlistClose'         : '</OL>'          ,
        'numlistItemOpen'      : '<LI>'           ,
        'deflistOpen'          : '<DL>'           ,
        'deflistClose'         : '</DL>'          ,
        'deflistItem1Open'     : '<DT>'           ,
        'deflistItem1Close'    : '</DT>'          ,
        'deflistItem2Open'     : '<DD>'           ,
        'bar1'                 : '<HR NOSHADE SIZE=1>'        ,
        'bar2'                 : '<HR NOSHADE SIZE=5>'        ,
        'url'                  : '<A HREF="\a">\a</A>'        ,
        'urlMark'              : '<A HREF="\a">\a</A>'        ,
        'email'                : '<A HREF="mailto:\a">\a</A>' ,
        'emailMark'            : '<A HREF="mailto:\a">\a</A>' ,
        'img'                  : '<IMG~A~ SRC="\a" BORDER="0" ALT="">',
        'imgEmbed'             : '<IMG~A~ SRC="\a" BORDER="0" ALT="">',
        '_imgAlignLeft'        : ' ALIGN="left"'  ,
        '_imgAlignCenter'      : ' ALIGN="middle"',
        '_imgAlignRight'       : ' ALIGN="right"' ,
        'tableOpen'            : '<TABLE~A~~B~ CELLPADDING="4">',
        'tableClose'           : '</TABLE>'       ,
        'tableRowOpen'         : '<TR>'           ,
        'tableRowClose'        : '</TR>'          ,
        'tableCellOpen'        : '<TD~A~~S~>'     ,
        'tableCellClose'       : '</TD>'          ,
        'tableTitleCellOpen'   : '<TH~S~>'        ,
        'tableTitleCellClose'  : '</TH>'          ,
        '_tableBorder'         : ' BORDER="1"'    ,
        '_tableAlignCenter'    : ' ALIGN="center"',
        '_tableCellAlignRight' : ' ALIGN="right"' ,
        '_tableCellAlignCenter': ' ALIGN="center"',
        '_tableCellColSpan'    : ' COLSPAN="\a"'  ,
        'cssOpen'              : '<STYLE TYPE="text/css">',
        'cssClose'             : '</STYLE>'       ,
        'comment'              : '<!-- \a -->'    ,
        'EOD'                  : '</BODY></HTML>'
    },

    #TIP wp inherits all HTML tags
    'wp': {
        # Exclusions to let the WordPress code cleaner
        'bodyOpen'             : '',
        'bodyClose'            : '',
        'paragraphOpen'        : '',
        'paragraphClose'       : '',
        'comment'              : '',
        'EOD'                  : '',
        # All list items must be closed
        'listItemClose'        : '</li>'          ,
        'numlistItemClose'     : '</li>'          ,
        'deflistItem2Close'    : '</dd>'          ,
        # WP likes tags this way
        'bar1'                 : '<hr>',
        'bar2'                 : '<hr>',
        'fontBoldOpen'         : '<strong>'       ,
        'fontBoldClose'        : '</strong>'      ,
        'fontItalicOpen'       : '<em>'           ,
        'fontItalicClose'      : '</em>'          ,
    },

    #TIP xhtml inherits all HTML definitions (lowercased)
    #TIP http://www.w3.org/TR/xhtml1/#guidelines
    #TIP http://www.htmlref.com/samples/Chapt17/17_08.htm
    'xhtml': {
        'listItemClose'        : '</li>'          ,
        'numlistItemClose'     : '</li>'          ,
        'deflistItem2Close'    : '</dd>'          ,
        'bar1'                 : '<hr class="light" />',
        'bar2'                 : '<hr class="heavy" />',
        'img'                  : '<img~A~ src="\a" border="0" alt=""/>',
        'imgEmbed'             : '<img~A~ SRC="\a" border="0" alt=""/>'
    },

    'xhtmls': {
        'fontBoldOpen'         : '<strong>'       ,
        'fontBoldClose'        : '</strong>'      ,
        'fontItalicOpen'       : '<em>'           ,
        'fontItalicClose'      : '</em>'          ,
        'fontUnderlineOpen'    : '<span style="text-decoration:underline">',
        'fontUnderlineClose'   : '</span>'        ,
        'fontStrikeOpen'       : '<span style="text-decoration:line-through">',  # use <del> instead ?
        'fontStrikeClose'      : '</span>'        ,
        'listItemClose'        : '</li>'          ,
        'numlistItemClose'     : '</li>'          ,
        'deflistItem2Close'    : '</dd>'          ,
        'bar1'                 : '<hr class="light" />',
        'bar2'                 : '<hr class="heavy" />',
        'img'                  : '<img style="display: block;~a~" src="\a" alt=""/>',
        'imgEmbed'             : '<img~a~ src="\a" alt=""/>',
        '_imgAlignLeft'        : 'margin: 0 auto 0 0;'  ,
        '_imgAlignCenter'      : 'margin: 0 auto 0 auto;',
        '_imgAlignRight'       : 'margin: 0 0 0 auto;' ,
        '_tableAlignCenter'    : ' style="margin-left: auto; margin-right: auto;"',
        '_tableCellAlignRight' : ' style="text-align:right"' ,
        '_tableCellAlignCenter': ' style="text-align:center"',
    },
    'html5': {
        'title1Open'           : '<section~A~>\n<h1>\a</h1>' ,
        'title1Close'          : '</section>'                ,
        'title2Open'           : '<section~A~>\n<h2>\a</h2>' ,
        'title2Close'          : '</section>'                ,
        'title3Open'           : '<section~A~>\n<h3>\a</h3>' ,
        'title3Close'          : '</section>'                ,
        'title4Open'           : '<section~A~>\n<h4>\a</h4>' ,
        'title4Close'          : '</section>'                ,
        'title5Open'           : '<section~A~>\n<h5>\a</h5>' ,
        'title5Close'          : '</section>'                ,
        'fontBoldOpen'         : '<strong>'       ,
        'fontBoldClose'        : '</strong>'      ,
        'fontItalicOpen'       : '<em>'           ,
        'fontItalicClose'      : '</em>'          ,
        'fontUnderlineOpen'    : '<span class="underline">',
        'fontUnderlineClose'   : '</span>'        ,
        'fontStrikeOpen'       : '<del>'          ,
        'fontStrikeClose'      : '</del>'         ,
        'listItemClose'        : '</li>'          ,
        'numlistItemClose'     : '</li>'          ,
        'deflistItem2Close'    : '</dd>'          ,
        'bar1'                 : '<hr class="light">'        ,
        'bar2'                 : '<hr class="heavy">'        ,
        'img'                  : '<img~a~ src="\a" alt="">'  ,
        'imgEmbed'             : '<img~a~ src="\a" alt="">'  ,
        '_imgAlignLeft'        : ' class="left"'  ,
        '_imgAlignCenter'      : ' class="center"',
        '_imgAlignRight'       : ' class="right"' ,
        'tableOpen'            : '<table~a~ class="~b~ ~s~">'  ,
        '_tableBorder'         : 'tableborder'      ,
        '_tableAlignCenter'    : ' style="margin-left: auto; margin-right: auto;"',
        '_tableSortable'       : 'sortable',
        '_tableCellAlignRight' : ' class="right"' ,
        '_tableCellAlignCenter': ' class="center"',
        'tableTitleRowOpen'    : '<thead>'                           ,
        'tableTitleRowClose'   : '</thead>'                          ,
        'cssOpen'              : '<style>'        ,
        'tocOpen'              : '<nav>'          ,
        'tocClose'             : '</nav>'         ,
        'EOD'                  : '</article></body></html>'
    },
    'htmls': {
        #TIP htmls inherits all html5 tags
    },

    'sgml': {
        'paragraphOpen'        : '<p>'                ,
        'title1'               : '<sect>\a~A~<p>'     ,
        'title2'               : '<sect1>\a~A~<p>'    ,
        'title3'               : '<sect2>\a~A~<p>'    ,
        'title4'               : '<sect3>\a~A~<p>'    ,
        'title5'               : '<sect4>\a~A~<p>'    ,
        'anchor'               : '<label id="\a">'    ,
        'blockVerbOpen'        : '<tscreen><verb>'    ,
        'blockVerbClose'       : '</verb></tscreen>'  ,
        'blockQuoteOpen'       : '<quote>'            ,
        'blockQuoteClose'      : '</quote>'           ,
        'fontMonoOpen'         : '<tt>'               ,
        'fontMonoClose'        : '</tt>'              ,
        'fontBoldOpen'         : '<bf>'               ,
        'fontBoldClose'        : '</bf>'              ,
        'fontItalicOpen'       : '<em>'               ,
        'fontItalicClose'      : '</em>'              ,
        'fontUnderlineOpen'    : '<bf><em>'           ,
        'fontUnderlineClose'   : '</em></bf>'         ,
        'listOpen'             : '<itemize>'          ,
        'listClose'            : '</itemize>'         ,
        'listItemOpen'         : '<item>'             ,
        'numlistOpen'          : '<enum>'             ,
        'numlistClose'         : '</enum>'            ,
        'numlistItemOpen'      : '<item>'             ,
        'deflistOpen'          : '<descrip>'          ,
        'deflistClose'         : '</descrip>'         ,
        'deflistItem1Open'     : '<tag>'              ,
        'deflistItem1Close'    : '</tag>'             ,
        'bar1'                 : '<!-- \a -->'        ,
        'url'                  : '<htmlurl url="\a" name="\a">'        ,
        'urlMark'              : '<htmlurl url="\a" name="\a">'        ,
        'email'                : '<htmlurl url="mailto:\a" name="\a">' ,
        'emailMark'            : '<htmlurl url="mailto:\a" name="\a">' ,
        'img'                  : '<figure><ph vspace=""><img src="\a"></figure>',
        'tableOpen'            : '<table><tabular ca="~C~">'           ,
        'tableClose'           : '</tabular></table>' ,
        'tableRowSep'          : '<rowsep>'           ,
        'tableCellSep'         : '<colsep>'           ,
        '_tableColAlignLeft'   : 'l'                  ,
        '_tableColAlignRight'  : 'r'                  ,
        '_tableColAlignCenter' : 'c'                  ,
        'comment'              : '<!-- \a -->'        ,
        'TOC'                  : '<toc>'              ,
        'EOD'                  : '</article>'
    },

    'dbk': {
        'paragraphOpen'        : '<para>'                            ,
        'paragraphClose'       : '</para>'                           ,
        'title1Open'           : '~A~<sect1><title>\a</title>'       ,
        'title1Close'          : '</sect1>'                          ,
        'title2Open'           : '~A~  <sect2><title>\a</title>'     ,
        'title2Close'          : '  </sect2>'                        ,
        'title3Open'           : '~A~    <sect3><title>\a</title>'   ,
        'title3Close'          : '    </sect3>'                      ,
        'title4Open'           : '~A~      <sect4><title>\a</title>' ,
        'title4Close'          : '      </sect4>'                    ,
        'title5Open'           : '~A~        <sect5><title>\a</title>',
        'title5Close'          : '        </sect5>'                  ,
        'anchor'               : '<anchor id="\a"/>\n'               ,
        'blockVerbOpen'        : '<programlisting>'                  ,
        'blockVerbClose'       : '</programlisting>'                 ,
        'blockQuoteOpen'       : '<blockquote><para>'                ,
        'blockQuoteClose'      : '</para></blockquote>'              ,
        'fontMonoOpen'         : '<code>'                            ,
        'fontMonoClose'        : '</code>'                           ,
        'fontBoldOpen'         : '<emphasis role="bold">'            ,
        'fontBoldClose'        : '</emphasis>'                       ,
        'fontItalicOpen'       : '<emphasis>'                        ,
        'fontItalicClose'      : '</emphasis>'                       ,
        'fontUnderlineOpen'    : '<emphasis role="underline">'       ,
        'fontUnderlineClose'   : '</emphasis>'                       ,
        # 'fontStrikeOpen'       : '<emphasis role="strikethrough">'   ,  # Don't know
        # 'fontStrikeClose'      : '</emphasis>'                       ,
        'listOpen'             : '<itemizedlist>'                    ,
        'listClose'            : '</itemizedlist>'                   ,
        'listItemOpen'         : '<listitem><para>'                  ,
        'listItemClose'        : '</para></listitem>'                ,
        'numlistOpen'          : '<orderedlist numeration="arabic">' ,
        'numlistClose'         : '</orderedlist>'                    ,
        'numlistItemOpen'      : '<listitem><para>'                  ,
        'numlistItemClose'     : '</para></listitem>'                ,
        'deflistOpen'          : '<variablelist>'                    ,
        'deflistClose'         : '</variablelist>'                   ,
        'deflistItem1Open'     : '<varlistentry><term>'              ,
        'deflistItem1Close'    : '</term>'                           ,
        'deflistItem2Open'     : '<listitem><para>'                  ,
        'deflistItem2Close'    : '</para></listitem></varlistentry>' ,
        # 'bar1'                 : '<>'                                ,  # Don't know
        # 'bar2'                 : '<>'                                ,  # Don't know
        'url'                  : '<ulink url="\a">\a</ulink>'        ,
        'urlMark'              : '<ulink url="\a">\a</ulink>'        ,
        'email'                : '<email>\a</email>'                 ,
        'emailMark'            : '<email>\a</email>'                 ,
        'img'                  : '<mediaobject><imageobject><imagedata fileref="\a"/></imageobject></mediaobject>',
        # '_imgAlignLeft'        : ''                                 ,  # Don't know
        # '_imgAlignCenter'      : ''                                 ,  # Don't know
        # '_imgAlignRight'       : ''                                 ,  # Don't know
        'tableOpen'            : '<informaltable><tgroup cols="n_cols"><tbody>',
        'tableClose'           : '</tbody></tgroup></informaltable>' ,
        'tableRowOpen'         : '<row>'                             ,
        'tableRowClose'        : '</row>'                            ,
        'tableCellOpen'        : '<entry>'                           ,
        'tableCellClose'       : '</entry>'                          ,
        'tableTitleRowOpen'    : '<thead>'                           ,
        'tableTitleRowClose'   : '</thead>'                          ,
        '_tableBorder'         : ' frame="all"'                      ,
        '_tableAlignCenter'    : ' align="center"'                   ,
        '_tableCellAlignRight' : ' align="right"'                    ,
        '_tableCellAlignCenter': ' align="center"'                   ,
        '_tableCellColSpan'    : ' COLSPAN="\a"'                     ,
        'TOC'                  : '<index/>'                          ,
        'comment'              : '<!-- \a -->'                       ,
        'EOD'                  : '</article>'
    },

    'tex': {
        'title1'               : '~A~\section*{\a}'     ,
        'title2'               : '~A~\\subsection*{\a}'   ,
        'title3'               : '~A~\\subsubsection*{\a}',
        # title 4/5: DIRTY: para+BF+\\+\n
        'title4'               : '~A~\\paragraph{}\\textbf{\a}\\\\\n',
        'title5'               : '~A~\\paragraph{}\\textbf{\a}\\\\\n',
        'numtitle1'            : '\n~A~\section{\a}'      ,
        'numtitle2'            : '~A~\\subsection{\a}'    ,
        'numtitle3'            : '~A~\\subsubsection{\a}' ,
        'anchor'               : '\\hypertarget{\a}{}\n'  ,
        'blockVerbOpen'        : '\\begin{verbatim}'   ,
        'blockVerbClose'       : '\\end{verbatim}'     ,
        'blockQuoteOpen'       : '\\begin{quotation}'  ,
        'blockQuoteClose'      : '\\end{quotation}'    ,
        'fontMonoOpen'         : '\\texttt{'           ,
        'fontMonoClose'        : '}'                   ,
        'fontBoldOpen'         : '\\textbf{'           ,
        'fontBoldClose'        : '}'                   ,
        'fontItalicOpen'       : '\\textit{'           ,
        'fontItalicClose'      : '}'                   ,
        'fontUnderlineOpen'    : '\\underline{'        ,
        'fontUnderlineClose'   : '}'                   ,
        'fontStrikeOpen'       : '\\sout{'             ,
        'fontStrikeClose'      : '}'                   ,
        'listOpen'             : '\\begin{itemize}'    ,
        'listClose'            : '\\end{itemize}'      ,
        'listOpenCompact'      : '\\begin{compactitem}',
        'listCloseCompact'     : '\\end{compactitem}'  ,
        'listItemOpen'         : '\\item '             ,
        'numlistOpen'          : '\\begin{enumerate}'  ,
        'numlistClose'         : '\\end{enumerate}'    ,
        'numlistOpenCompact'   : '\\begin{compactenum}',
        'numlistCloseCompact'  : '\\end{compactenum}'  ,
        'numlistItemOpen'      : '\\item '             ,
        'deflistOpen'          : '\\begin{description}',
        'deflistClose'         : '\\end{description}'  ,
        'deflistOpenCompact'   : '\\begin{compactdesc}',
        'deflistCloseCompact'  : '\\end{compactdesc}'  ,
        'deflistItem1Open'     : '\\item['             ,
        'deflistItem1Close'    : ']'                   ,
        'bar1'                 : '\\hrulefill{}'       ,
        'bar2'                 : '\\rule{\linewidth}{1mm}',
        'url'                  : '\\htmladdnormallink{\a}{\a}',
        'urlMark'              : '\\htmladdnormallink{\a}{\a}',
        'email'                : '\\htmladdnormallink{\a}{mailto:\a}',
        'emailMark'            : '\\htmladdnormallink{\a}{mailto:\a}',
        'img'                  : '\\includegraphics{\a}',
        'tableOpen'            : '\\begin{center}\\begin{tabular}{|~C~|}',
        'tableClose'           : '\\end{tabular}\\end{center}',
        'tableRowOpen'         : '\\hline ' ,
        'tableRowClose'        : ' \\\\'    ,
        'tableCellSep'         : ' & '      ,
        '_tableColAlignLeft'   : 'l'        ,
        '_tableColAlignRight'  : 'r'        ,
        '_tableColAlignCenter' : 'c'        ,
        '_tableCellAlignLeft'  : 'l'        ,
        '_tableCellAlignRight' : 'r'        ,
        '_tableCellAlignCenter': 'c'        ,
        '_tableCellColSpan'    : '\a'       ,
        '_tableCellMulticolOpen'  : '\\multicolumn{\a}{|~C~|}{',
        '_tableCellMulticolClose' : '}',
        'tableColAlignSep'     : '|'        ,
        'comment'              : '% \a'     ,
        'TOC'                  : '\\tableofcontents',
        'pageBreak'            : '\\clearpage',
        'EOD'                  : '\\end{document}'
    },
    'texs': {
        #TIP texs inherits all tex tags
    },

    'lout': {
        'paragraphOpen'        : '@LP'                     ,
        'blockTitle1Open'      : '@BeginSections'          ,
        'blockTitle1Close'     : '@EndSections'            ,
        'blockTitle2Open'      : ' @BeginSubSections'      ,
        'blockTitle2Close'     : ' @EndSubSections'        ,
        'blockTitle3Open'      : '  @BeginSubSubSections'  ,
        'blockTitle3Close'     : '  @EndSubSubSections'    ,
        'title1Open'           : '~A~@Section @Title { \a } @Begin',
        'title1Close'          : '@End @Section'           ,
        'title2Open'           : '~A~ @SubSection @Title { \a } @Begin',
        'title2Close'          : ' @End @SubSection'       ,
        'title3Open'           : '~A~  @SubSubSection @Title { \a } @Begin',
        'title3Close'          : '  @End @SubSubSection'   ,
        'title4Open'           : '~A~@LP @LeftDisplay @B { \a }',
        'title5Open'           : '~A~@LP @LeftDisplay @B { \a }',
        'anchor'               : '@Tag { \a }\n'       ,
        'blockVerbOpen'        : '@LP @ID @F @RawVerbatim @Begin',
        'blockVerbClose'       : '@End @RawVerbatim'   ,
        'blockQuoteOpen'       : '@QD {'               ,
        'blockQuoteClose'      : '}'                   ,
        # enclosed inside {} to deal with joined**words**
        'fontMonoOpen'         : '{@F {'               ,
        'fontMonoClose'        : '}}'                  ,
        'fontBoldOpen'         : '{@B {'               ,
        'fontBoldClose'        : '}}'                  ,
        'fontItalicOpen'       : '{@II {'              ,
        'fontItalicClose'      : '}}'                  ,
        'fontUnderlineOpen'    : '{@Underline{'        ,
        'fontUnderlineClose'   : '}}'                  ,
        # the full form is more readable, but could be BL EL LI NL TL DTI
        'listOpen'             : '@BulletList'         ,
        'listClose'            : '@EndList'            ,
        'listItemOpen'         : '@ListItem{'          ,
        'listItemClose'        : '}'                   ,
        'numlistOpen'          : '@NumberedList'       ,
        'numlistClose'         : '@EndList'            ,
        'numlistItemOpen'      : '@ListItem{'          ,
        'numlistItemClose'     : '}'                   ,
        'deflistOpen'          : '@TaggedList'         ,
        'deflistClose'         : '@EndList'            ,
        'deflistItem1Open'     : '@DropTagItem {'      ,
        'deflistItem1Close'    : '}'                   ,
        'deflistItem2Open'     : '{'                   ,
        'deflistItem2Close'    : '}'                   ,
        'bar1'                 : '@DP @FullWidthRule'  ,
        'url'                  : '{blue @Colour { \a }}'      ,
        'urlMark'              : '\a ({blue @Colour { \a }})' ,
        'email'                : '{blue @Colour { \a }}'      ,
        'emailMark'            : '\a ({blue Colour{ \a }})'   ,
        'img'                  : '~A~@IncludeGraphic { \a }'  ,  # eps only!
        '_imgAlignLeft'        : '@LeftDisplay '              ,
        '_imgAlignRight'       : '@RightDisplay '             ,
        '_imgAlignCenter'      : '@CentredDisplay '           ,
        # lout tables are *way* complicated, no support for now
        #'tableOpen'            : '~A~@Tbl~B~\naformat{ @Cell A | @Cell B } {',
        #'tableClose'           : '}'     ,
        #'tableRowOpen'         : '@Rowa\n'       ,
        #'tableTitleRowOpen'    : '@HeaderRowa'       ,
        #'tableCenterAlign'     : '@CentredDisplay '         ,
        #'tableCellOpen'        : '\a {'                     ,  # A, B, ...
        #'tableCellClose'       : '}'                        ,
        #'_tableBorder'         : '\nrule {yes}'             ,
        'comment'              : '# \a'                     ,
        # @MakeContents must be on the config file
        'TOC'                  : '@DP @ContentsGoesHere @DP',
        'pageBreak'            : '@NP'                      ,
        'EOD'                  : '@End @Text'
    },

    # http://moinmo.in/HelpOnMoinWikiSyntax
    'moin': {
        'title1'                : '= \a ='        ,
        'title2'                : '== \a =='      ,
        'title3'                : '=== \a ==='    ,
        'title4'                : '==== \a ===='  ,
        'title5'                : '===== \a =====',
        'blockVerbOpen'         : '{{{'           ,
        'blockVerbClose'        : '}}}'           ,
        'blockQuoteLine'        : '  '            ,
        'fontMonoOpen'          : '{{{'           ,
        'fontMonoClose'         : '}}}'           ,
        'fontBoldOpen'          : "'''"           ,
        'fontBoldClose'         : "'''"           ,
        'fontItalicOpen'        : "''"            ,
        'fontItalicClose'       : "''"            ,
        'fontUnderlineOpen'     : '__'            ,
        'fontUnderlineClose'    : '__'            ,
        'fontStrikeOpen'        : '--('           ,
        'fontStrikeClose'       : ')--'           ,
        'listItemOpen'          : ' * '           ,
        'numlistItemOpen'       : ' \a. '         ,
        'deflistItem1Open'      : ' '             ,
        'deflistItem1Close'     : '::'            ,
        'deflistItem2LinePrefix': ' :: '          ,
        'bar1'                  : '----'          ,
        'bar2'                  : '--------'      ,
        'url'                   : '[[\a]]'          ,
        'urlMark'               : '[[\a|\a]]'       ,
        'email'                 : '\a'          ,
        'emailMark'             : '[[mailto:\a|\a]]'       ,
        'img'                   : '{{\a}}'          ,
        'tableRowOpen'          : '||'            ,  # || one || two ||
        'tableCellOpen'         : '~S~~A~ '       ,
        'tableCellClose'        : ' ||'           ,
        '_tableCellAlignRight'  : '<)>'           ,  # ||<)> right ||
        '_tableCellAlignCenter' : '<:>'           ,  # ||<:> center ||
        '_tableCellColSpanChar' : '||'            ,  # || cell |||| 2 cells spanned ||
        # Another option for span is ||<-2> two cells spanned ||
        # But mixing span+align is harder with the current code:
        # ||<-2:> two cells spanned and centered ||
        # ||<-2)> two cells spanned and right aligned ||
        # Just appending attributes doesn't work:
        # ||<-2><:> no no no ||
        'comment'               : '/* \a */'      ,
        'TOC'                   : '<<TableOfContents>>'
    },

    # http://code.google.com/p/support/wiki/WikiSyntax
    'gwiki': {
        'title1'               : '= \a ='        ,
        'title2'               : '== \a =='      ,
        'title3'               : '=== \a ==='    ,
        'title4'               : '==== \a ===='  ,
        'title5'               : '===== \a =====',
        'blockVerbOpen'        : '{{{'           ,
        'blockVerbClose'       : '}}}'           ,
        'blockQuoteLine'       : '  '            ,
        'fontMonoOpen'         : '{{{'           ,
        'fontMonoClose'        : '}}}'           ,
        'fontBoldOpen'         : '*'             ,
        'fontBoldClose'        : '*'             ,
        'fontItalicOpen'       : '_'             ,  # underline == italic
        'fontItalicClose'      : '_'             ,
        'fontStrikeOpen'       : '~~'            ,
        'fontStrikeClose'      : '~~'            ,
        'listItemOpen'         : ' * '           ,
        'numlistItemOpen'      : ' # '           ,
        'url'                  : '\a'            ,
        'urlMark'              : '[\a \a]'       ,
        'email'                : 'mailto:\a'     ,
        'emailMark'            : '[mailto:\a \a]',
        'img'                  : '[\a]'          ,
        'tableRowOpen'         : '|| '           ,
        'tableRowClose'        : ' ||'           ,
        'tableCellSep'         : ' || '          ,
    },

    # http://asciidoc.org/asciidoc.css-embedded.html
    'adoc': {
        'title1'               : '== \a'         ,
        'title2'               : '=== \a'        ,
        'title3'               : '==== \a'       ,
        'title4'               : '===== \a'      ,
        'title5'               : '===== \a'      ,
        'blockVerbOpen'        : '----'          ,
        'blockVerbClose'       : '----'          ,
        'deflistItem1Close'    : '::'            ,
        'deflistClose'         : ''              ,
        'deflistItem2Open'     : '	'            ,
        'deflistItem2LinePrefix': '	'            ,
        'fontMonoOpen'         : '+'             ,
        'fontMonoClose'        : '+'             ,
        'fontBoldOpen'         : '*'             ,
        'fontBoldClose'        : '*'             ,
        'fontItalicOpen'       : '_'             ,
        'fontItalicClose'      : '_'             ,
        'listItemOpen'         : ' '             ,
        'listItemLine'         : '*'             ,
        'numlistItemOpen'      : '1. '           ,
        'url'                  : '\a'            ,
        'urlMark'              : '\a[\a]'        ,
        'email'                : 'mailto:\a'     ,
        'emailMark'            : 'mailto:\a[\a]' ,
        'img'                  : 'image::\a[]'   ,
    },

    # http://www.dokuwiki.org/syntax
    # http://www.dokuwiki.org/playground:playground
    # Hint: <br> is \\ $
    # Hint: You can add footnotes ((This is a footnote))
    'doku': {
        'title1'               : '===== \a =====',
        'title2'               : '==== \a ===='  ,
        'title3'               : '=== \a ==='    ,
        'title4'               : '== \a =='      ,
        'title5'               : '= \a ='        ,
        # DokuWiki uses '  ' identation to mark verb blocks (see indentverbblock)
        'blockQuoteLine'       : '>'             ,
        'fontMonoOpen'         : "''"            ,
        'fontMonoClose'        : "''"            ,
        'fontBoldOpen'         : "**"            ,
        'fontBoldClose'        : "**"            ,
        'fontItalicOpen'       : "//"            ,
        'fontItalicClose'      : "//"            ,
        'fontUnderlineOpen'    : "__"            ,
        'fontUnderlineClose'   : "__"            ,
        'fontStrikeOpen'       : '<del>'         ,
        'fontStrikeClose'      : '</del>'        ,
        'listItemOpen'         : '  * '          ,
        'numlistItemOpen'      : '  - '          ,
        'bar1'                 : '----'          ,
        'url'                  : '[[\a]]'        ,
        'urlMark'              : '[[\a|\a]]'     ,
        'email'                : '[[\a]]'        ,
        'emailMark'            : '[[\a|\a]]'     ,
        'img'                  : '{{\a}}'        ,
        'imgAlignLeft'         : '{{\a }}'       ,
        'imgAlignRight'        : '{{ \a}}'       ,
        'imgAlignCenter'       : '{{ \a }}'      ,
        'tableTitleRowOpen'    : '^ '            ,
        'tableTitleRowClose'   : ' ^'            ,
        'tableTitleCellSep'    : ' ^ '           ,
        'tableRowOpen'         : '| '            ,
        'tableRowClose'        : ' |'            ,
        'tableCellSep'         : ' | '           ,
        # DokuWiki has no attributes. The content must be aligned!
        # '_tableCellAlignRight' : '<)>'           ,  # ??
        # '_tableCellAlignCenter': '<:>'           ,  # ??
        # DokuWiki colspan is the same as txt2tags' with multiple |||
        # 'comment'             : '## \a'         ,  # ??
        # TOC is automatic
    },

    # http://www.pmwiki.org/wiki/PmWiki/TextFormattingRules
    # http://www.pmwiki.org/wiki/Main/WikiSandbox
    'pmw': {
        'title1'               : '~A~! \a '      ,
        'title2'               : '~A~!! \a '     ,
        'title3'               : '~A~!!! \a '    ,
        'title4'               : '~A~!!!! \a '   ,
        'title5'               : '~A~!!!!! \a '  ,
        'blockQuoteOpen'       : '->'            ,
        'blockQuoteClose'      : '\n'            ,
        # In-text font
        'fontLargeOpen'        : "[+"            ,
        'fontLargeClose'       : "+]"            ,
        'fontLargerOpen'       : "[++"           ,
        'fontLargerClose'      : "++]"           ,
        'fontSmallOpen'        : "[-"            ,
        'fontSmallClose'       : "-]"            ,
        'fontLargerOpen'       : "[--"           ,
        'fontLargerClose'      : "--]"           ,
        'fontMonoOpen'         : "@@"            ,
        'fontMonoClose'        : "@@"            ,
        'fontBoldOpen'         : "'''"           ,
        'fontBoldClose'        : "'''"           ,
        'fontItalicOpen'       : "''"            ,
        'fontItalicClose'      : "''"            ,
        'fontUnderlineOpen'    : "{+"            ,
        'fontUnderlineClose'   : "+}"            ,
        'fontStrikeOpen'       : '{-'            ,
        'fontStrikeClose'      : '-}'            ,
        # Lists
        'listItemLine'          : '*'            ,
        'numlistItemLine'       : '#'            ,
        'deflistItem1Open'      : ': '           ,
        'deflistItem1Close'     : ':'            ,
        'deflistItem2LineOpen'  : '::'           ,
        'deflistItem2LineClose' : ':'            ,
        # Verbatim block
        'blockVerbOpen'        : '[@'            ,
        'blockVerbClose'       : '@]'            ,
        'bar1'                 : '----'          ,
        # URL, email and anchor
        'url'                   : '\a'           ,
        'urlMark'               : '[[\a -> \a]]' ,
        'email'                 : '\a'           ,
        'emailMark'             : '[[\a -> mailto:\a]]',
        'anchor'                : '[[#\a]]\n'    ,
        # Image markup
        'img'                   : '\a'           ,
        #'imgAlignLeft'         : '{{\a }}'       ,
        #'imgAlignRight'        : '{{ \a}}'       ,
        #'imgAlignCenter'       : '{{ \a }}'      ,
        # Table attributes
        'tableTitleRowOpen'    : '||! '          ,
        'tableTitleRowClose'   : '||'            ,
        'tableTitleCellSep'    : ' ||!'          ,
        'tableRowOpen'         : '||'            ,
        'tableRowClose'        : '||'            ,
        'tableCellSep'         : ' ||'           ,
    },

    # http://en.wikipedia.org/wiki/Help:Editing
    # http://www.mediawiki.org/wiki/Sandbox
    'wiki': {
        'title1'                : '== \a =='        ,
        'title2'                : '=== \a ==='      ,
        'title3'                : '==== \a ===='    ,
        'title4'                : '===== \a ====='  ,
        'title5'                : '====== \a ======',
        'blockVerbOpen'         : '<pre>'           ,
        'blockVerbClose'        : '</pre>'          ,
        'blockQuoteOpen'        : '<blockquote>'    ,
        'blockQuoteClose'       : '</blockquote>'   ,
        'fontMonoOpen'          : '<tt>'            ,
        'fontMonoClose'         : '</tt>'           ,
        'fontBoldOpen'          : "'''"             ,
        'fontBoldClose'         : "'''"             ,
        'fontItalicOpen'        : "''"              ,
        'fontItalicClose'       : "''"              ,
        'fontUnderlineOpen'     : '<u>'             ,
        'fontUnderlineClose'    : '</u>'            ,
        'fontStrikeOpen'        : '<s>'             ,
        'fontStrikeClose'       : '</s>'            ,
        #XXX Mixed lists not working: *#* list inside numlist inside list
        'listItemLine'          : '*'               ,
        'numlistItemLine'       : '#'               ,
        'deflistItem1Open'      : '; '              ,
        'deflistItem2LinePrefix': ': '              ,
        'bar1'                  : '----'            ,
        'url'                   : '[\a]'            ,
        'urlMark'               : '[\a \a]'         ,
        'urlMarkAnchor'         : '[[\a|\a]]'       ,
        'email'                 : 'mailto:\a'       ,
        'emailMark'             : '[mailto:\a \a]'  ,
        # [[Image:foo.png|right|Optional alt/caption text]] (right, left, center, none)
        'img'                   : '[[Image:\a~A~]]' ,
        '_imgAlignLeft'         : '|left'           ,
        '_imgAlignCenter'       : '|center'         ,
        '_imgAlignRight'        : '|right'          ,
        # {| border="1" cellspacing="0" cellpadding="4" align="center"
        'tableOpen'             : '{|~A~~B~'        ,
        'tableClose'            : '|}'              ,
        'tableRowOpen'          : '|-'              ,
        'tableTitleRowOpen'     : '|-'              ,
        # Note: using one cell per line syntax
        'tableCellOpen'         : '\n|~A~~S~~Z~ '   ,
        'tableTitleCellOpen'    : '\n!~A~~S~~Z~ '   ,
        '_tableBorder'          : ' border="1"'     ,
        '_tableAlignCenter'     : ' align="center"' ,
        '_tableCellAlignRight'  : ' align="right"'  ,
        '_tableCellAlignCenter' : ' align="center"' ,
        '_tableCellColSpan'     : ' colspan="\a"'   ,
        '_tableAttrDelimiter'   : ' |'              ,
        'comment'               : '<!-- \a -->'     ,
        'TOC'                   : '__TOC__'         ,
    },

    # http://demo.redmine.org/help/wiki_syntax.html
    # http://demo.redmine.org/help/wiki_syntax_detailed.html
    # Sandbox: http://demo.redmine.org - create account, add new project
    'red': {
        'title1'                : 'h1. \a'   ,
        'title2'                : 'h2. \a'   ,
        'title3'                : 'h3. \a'   ,
        'title4'                : 'h4. \a'   ,
        'title5'                : 'h5. \a'   ,
        'fontBoldOpen'          : '*'        ,
        'fontBoldClose'         : '*'        ,
        'fontItalicOpen'        : '_'        ,
        'fontItalicClose'       : '_'        ,
        'fontStrikeOpen'        : '-'        ,
        'fontStrikeClose'       : '-'        ,
        'fontUnderlineOpen'     : "+"        ,
        'fontUnderlineClose'    : "+"        ,
        'blockVerbOpen'         : '<pre>'    ,
        'blockVerbClose'        : '</pre>'   ,
        'blockQuoteLine'        : 'bq. '     ,  # XXX It's a *paragraph* prefix. (issues 64, 65)
        'fontMonoOpen'          : '@'        ,
        'fontMonoClose'         : '@'        ,
        'listItemLine'          : '*'        ,
        'numlistItemLine'       : '#'        ,
        'deflistItem1Open'      : '* '       ,
        'url'                   : '\a'       ,
        'urlMark'               : '"\a":\a'  ,  # "Google":http://www.google.com
        'email'                 : '\a'       ,
        'emailMark'             : '"\a":\a'  ,
        'img'                   : '!~A~\a!'  ,
        '_imgAlignLeft'         : ''         ,  # !image.png! (no align == left)
        '_imgAlignCenter'       : '='        ,  # !=image.png!
        '_imgAlignRight'        : '>'        ,  # !>image.png!
        'tableTitleCellOpen'    : '_.'       ,  # Table header is |_.header|
        'tableTitleCellSep'     : '|'        ,
        'tableCellOpen'         : '~S~~A~. ' ,
        'tableCellSep'          : '|'        ,
        'tableRowOpen'          : '|'        ,
        'tableRowClose'         : '|'        ,
        '_tableCellColSpan'     : '\\\a'     ,
        'bar1'                  : '---'      ,
        'bar2'                  : '---'      ,
        'TOC'                   : '{{toc}}'  ,
    },
    'vimwiki': {
        'title1'                : '= \a ='        ,
        'title2'                : '== \a =='        ,
        'title3'                : '=== \a ==='      ,
        'title4'                : '==== \a ===='    ,
        'title5'                : '===== \a ====='  ,
        'blockVerbOpen'         : '{{{'           ,
        'blockVerbClose'        : '}}}'          ,
        'blockQuoteOpen'        : '{{{'    ,
        'blockQuoteClose'       : '}}}'   ,
        'fontMonoOpen'          : '`'            ,
        'fontMonoClose'         : '`'           ,
        'fontBoldOpen'          : ' *'             ,
        'fontBoldClose'         : '* '           ,
        'fontItalicOpen'        : ' _'              ,
        'fontItalicClose'       : '_ '              ,
        #'fontUnderlineOpen'     : '<u>'             ,
        #'fontUnderlineClose'    : '</u>'            ,
        'fontStrikeOpen'        : ' ~~'             ,
        'fontStrikeClose'       : '~~ '            ,
        'listItemOpen'         : '- '            ,
        'listItemLine'         : '\t'            ,
        'numlistItemOpen'      : '# '            ,
        'numlistItemLine'       : '\t'               ,
        'bar1'                  : '----'            ,
        'url'                   : '[\a]'            ,
        'urlMark'               : '[\a \a]'         ,
        'email'                 : 'mailto:\a'       ,
        'emailMark'             : '[mailto:\a \a]'  ,
        'img'                  : '[\a]'          ,
        #'_imgAlignLeft'         : '|left'           ,
        #'_imgAlignCenter'       : '|center'         ,
        #'_imgAlignRight'        : '|right'          ,
        'tableRowOpen'          : '| '          ,
        'tableRowClose'          : ' |'          ,
        #'tableTitleRowOpen'     : '|-\n! '          ,
        'tableCellSep'          : ' | '            ,
        #'tableTitleCellSep'     : ' | '            ,
        #'_tableBorder'          : ' border="1"'     ,
        #'_tableAlignCenter'     : ' align="center"' ,
        'comment'               : '%% \a'     ,
        'TOC'                   : '%toc'         ,
    },
    # http://www.inference.phy.cam.ac.uk/mackay/mgp/SYNTAX
    # http://en.wikipedia.org/wiki/MagicPoint
    'mgp': {
        'paragraphOpen'         : '%font "normal", size 5'     ,
        'title1'                : '%page\n\n\a\n'              ,
        'title2'                : '%page\n\n\a\n'              ,
        'title3'                : '%page\n\n\a\n'              ,
        'title4'                : '%page\n\n\a\n'              ,
        'title5'                : '%page\n\n\a\n'              ,
        'blockVerbOpen'         : '%font "mono"'               ,
        'blockVerbClose'        : '%font "normal"'             ,
        'blockQuoteOpen'        : '%prefix "       "'          ,
        'blockQuoteClose'       : '%prefix "  "'               ,
        'fontMonoOpen'          : '\n%cont, font "mono"\n'     ,
        'fontMonoClose'         : '\n%cont, font "normal"\n'   ,
        'fontBoldOpen'          : '\n%cont, font "normal-b"\n' ,
        'fontBoldClose'         : '\n%cont, font "normal"\n'   ,
        'fontItalicOpen'        : '\n%cont, font "normal-i"\n' ,
        'fontItalicClose'       : '\n%cont, font "normal"\n'   ,
        'fontUnderlineOpen'     : '\n%cont, fore "cyan"\n'     ,
        'fontUnderlineClose'    : '\n%cont, fore "white"\n'    ,
        'listItemLine'          : '\t'                         ,
        'numlistItemLine'       : '\t'                         ,
        'numlistItemOpen'       : '\a. '                       ,
        'deflistItem1Open'      : '\t\n%cont, font "normal-b"\n',
        'deflistItem1Close'     : '\n%cont, font "normal"\n'   ,
        'bar1'                  : '%bar "white" 5'             ,
        'bar2'                  : '%pause'                     ,
        'url'                   : '\n%cont, fore "cyan"\n\a'    +\
                                  '\n%cont, fore "white"\n'    ,
        'urlMark'               : '\a \n%cont, fore "cyan"\n\a' +\
                                  '\n%cont, fore "white"\n'    ,
        'email'                 : '\n%cont, fore "cyan"\n\a'    +\
                                  '\n%cont, fore "white"\n'    ,
        'emailMark'             : '\a \n%cont, fore "cyan"\n\a' +\
                                  '\n%cont, fore "white"\n'    ,
        'img'                   : '~A~\n%newimage "\a"\n%left\n',
        '_imgAlignLeft'         : '\n%left'                    ,
        '_imgAlignRight'        : '\n%right'                   ,
        '_imgAlignCenter'       : '\n%center'                  ,
        'comment'               : '%% \a'                      ,
        'pageBreak'             : '%page\n\n\n'                ,
        'EOD'                   : '%%EOD'
    },

    # man groff_man ; man 7 groff
    'man': {
        'paragraphOpen'         : '.P'     ,
        'title1'                : '.SH \a' ,
        'title2'                : '.SS \a' ,
        'title3'                : '.SS \a' ,
        'title4'                : '.SS \a' ,
        'title5'                : '.SS \a' ,
        'blockVerbOpen'         : '.nf'    ,
        'blockVerbClose'        : '.fi\n'  ,
        'blockQuoteOpen'        : '.RS'    ,
        'blockQuoteClose'       : '.RE'    ,
        'fontBoldOpen'          : '\\fB'   ,
        'fontBoldClose'         : '\\fR'   ,
        'fontItalicOpen'        : '\\fI'   ,
        'fontItalicClose'       : '\\fR'   ,
        'listOpen'              : '.RS'    ,
        'listItemOpen'          : '.IP \(bu 3\n',
        'listClose'             : '.RE\n.IP',
        'numlistOpen'           : '.RS'    ,
        'numlistItemOpen'       : '.IP \a. 3\n',
        'numlistClose'          : '.RE\n.IP',
        'deflistItem1Open'      : '.TP\n'  ,
        'bar1'                  : '\n\n'   ,
        'url'                   : '\a'     ,
        'urlMark'               : '\a (\a)',
        'email'                 : '\a'     ,
        'emailMark'             : '\a (\a)',
        'img'                   : '\a'     ,
        'tableOpen'             : '.TS\n~A~~B~tab(^); ~C~.',
        'tableClose'            : '.TE'     ,
        'tableRowOpen'          : ' '       ,
        'tableCellSep'          : '^'       ,
        '_tableAlignCenter'     : 'center, ',
        '_tableBorder'          : 'allbox, ',
        '_tableColAlignLeft'    : 'l'       ,
        '_tableColAlignRight'   : 'r'       ,
        '_tableColAlignCenter'  : 'c'       ,
        'comment'               : '.\\" \a'
    },

    # see http://utroff.org
    'utmac': {
        'paragraphOpen'         : '.PP'      ,
        'title1'                : '.\n.H2 \a',
        'title2'                : '.\n.H3 \a',
        'title3'                : '.\n.H4 \a',
        'title4'                : '.PP\n\\*B\a\\*R\n.br\n',
        'title5'                : '.PP\n\\*B\a\\*R',
        'blockVerbOpen'         : '.PX'      ,
        'blockQuoteOpen'        : '.PQ'      ,
        'fontBoldOpen'          : '\\*B'     ,
        'fontBoldClose'         : '\\*R'     ,
        'fontItalicOpen'        : '\\*I'     ,
        'fontItalicClose'       : '\\*R'     ,
        'fontUnderlineOpen'    : '\\*[underl ',
        'fontUnderlineClose'   : ']',
        'fontStrikeOpen'       : '\\*[strike ',
        'fontStrikeClose'      : ']'         ,
        'listItemOpen'          : '.PI \n'   ,
        'numlistItemOpen'       : '.PI \a\n' ,
        'deflistItem1Open'      : '.PI '     ,
        'bar1'                  : '.sp 2v'   ,
        'bar2'                  : '.bp'      ,
        'anchor'                : '\a\\A"\a"',
        'url'                   : '\\*[url "\a" "\a"]',
        'urlMark'               : '\\*[url "\a" "\a"]',
        'email'                 : '\\*[mail "\a" "\a"]',
        'emailMark'             : '\\*[mail "\a" "\a"]',
        'img'                   : '\n.\\" \a'  ,
        'tableOpen'             : '.TS\n~A~~B~tab(^); ~C~.',
        'tableClose'            : '.TE'      ,
        'tableRowOpen'          : ' '        ,
        'tableCellSep'          : '^'        ,
        '_tableAlignCenter'     : 'center, ' ,
        '_tableBorder'          : 'allbox, ' ,
        '_tableColAlignLeft'    : 'l'        ,
        '_tableColAlignRight'   : 'r'        ,
        '_tableColAlignCenter'  : 'c'        ,
        'comment'               : '.\\" \a'  ,
        'blockCommentOpen'      : '.ig'      ,
        'blockCommentClose'     : '..'       ,
        'pageBreak'             : '.bp'      ,
        'TOC'                   : '.XT'      ,
    },
    
    # http://www.spip-contrib.net/Les-raccourcis-typographiques-en
    # http://www.spip-contrib.net/Carnet-Bac-a-Sable
    # some tags are not implemented by spip tags, but spip accept html tags.
    'spip': {
        'title1'                : '{{{ \a }}}' ,
        'title2'                : '<h4>\a</h4>',
        'title3'                : '<h5>\a</h5>',
        'blockVerbOpen'         : '<cadre>'    ,
        'blockVerbClose'        : '</cadre>'   ,
        'blockQuoteOpen'        : '<quote>'    ,
        'blockQuoteClose'       : '</quote>'   ,
        'fontMonoOpen'          : '<code>'     ,
        'fontMonoClose'         : '</code>'    ,
        'fontBoldOpen'          : '{{'         ,
        'fontBoldClose'         : '}}'         ,
        'fontItalicOpen'        : '{'          ,
        'fontItalicClose'       : '}'          ,
        'fontUnderlineOpen'     : '<u>'        ,
        'fontUnderlineClose'    : '</u>'       ,
        'fontStrikeOpen'        : '<del>'      ,
        'fontStrikeClose'       : '</del>'     ,
        'listItemOpen'          : '-'          ,  # -* list, -** sublist, -*** subsublist
        'listItemLine'          : '*'          ,
        'numlistItemOpen'       : '-'          ,  # -# list, -## sublist, -### subsublist
        'numlistItemLine'       : '#'          ,
        'bar1'                  : '----'       ,
        'url'                   : '[->\a]'     ,
        'urlMark'               : '[\a->\a]'   ,
        'email'                 : '[->\a]'     ,
        'emailMark'             : '[\a->\a]'   ,
        'img'                   : '<img src="\a" />',
        'imgAlignLeft'          : '<img src="\a" align="left" />',
        'imgAlignRight'         : '<img src="\a" align="right" />',
        'imgAlignCenter'        : '<img src="\a" align="center" />',
        'tableTitleRowOpen'     : '| {{'       ,
        'tableTitleRowClose'    : '}} |'       ,
        'tableTitleCellSep'     : '}} | {{'    ,
        'tableRowOpen'          : '| '         ,
        'tableRowClose'         : ' |'         ,
        'tableCellSep'          : ' | '        ,
        # TOC is automatic whith title1 when plugin "couteau suisse" is activate and the option "table des matieres" activate.
    },
    'pm6': {
        'paragraphOpen'         : '<@Normal:>'    ,
        'title1'                : '<@Title1:>\a',
        'title2'                : '<@Title2:>\a',
        'title3'                : '<@Title3:>\a',
        'title4'                : '<@Title4:>\a',
        'title5'                : '<@Title5:>\a',
        'blockVerbOpen'         : '<@PreFormat:>' ,
        'blockQuoteLine'        : '<@Quote:>'     ,
        'fontMonoOpen'          : '<FONT "Lucida Console"><SIZE 9>' ,
        'fontMonoClose'         : '<SIZE$><FONT$>',
        'fontBoldOpen'          : '<B>'           ,
        'fontBoldClose'         : '<P>'           ,
        'fontItalicOpen'        : '<I>'           ,
        'fontItalicClose'       : '<P>'           ,
        'fontUnderlineOpen'     : '<U>'           ,
        'fontUnderlineClose'    : '<P>'           ,
        'listOpen'              : '<@Bullet:>'    ,
        'listItemOpen'          : '\x95\t'        ,  # \x95 == ~U
        'numlistOpen'           : '<@Bullet:>'    ,
        'numlistItemOpen'       : '\x95\t'        ,
        'bar1'                  : '\a'            ,
        'url'                   : '<U>\a<P>'      ,  # underline
        'urlMark'               : '\a <U>\a<P>'   ,
        'email'                 : '\a'            ,
        'emailMark'             : '\a \a'         ,
        'img'                   : '\a'
    },
    # http://www.wikicreole.org/wiki/AllMarkup
    'creole': {
        'title1'               : '= \a ='        ,
        'title2'               : '== \a =='      ,
        'title3'               : '=== \a ==='    ,
        'title4'               : '==== \a ===='  ,
        'title5'               : '===== \a =====',
        'blockVerbOpen'        : '{{{'           ,
        'blockVerbClose'       : '}}}'           ,
        'blockQuoteLine'       : '  '            ,
    #   'fontMonoOpen'         : '##'            ,  # planned for 2.0,
    #   'fontMonoClose'        : '##'            ,  # meanwhile we disable it
        'fontBoldOpen'         : '**'            ,
        'fontBoldClose'        : '**'            ,
        'fontItalicOpen'       : '//'            ,
        'fontItalicClose'      : '//'            ,
        'fontUnderlineOpen'    : '//'            ,  # no underline in 1.0, planned for 2.0,
        'fontUnderlineClose'   : '//'            ,  # meanwhile we can use italic (emphasized)
    #   'fontStrikeOpen'       : '--'            ,  # planned for 2.0,
    #   'fontStrikeClose'      : '--'            ,  # meanwhile we disable it
        'listItemLine'          : '*'            ,
        'numlistItemLine'       : '#'            ,
        'deflistItem2LinePrefix': ':'            ,
        'bar1'                  : '----'         ,
        'url'                  : '[[\a]]'        ,
        'urlMark'              : '[[\a|\a]]'     ,
        'img'                  : '{{\a}}'        ,
        'tableTitleRowOpen'    : '|= '           ,
        'tableTitleRowClose'   : '|'             ,
        'tableTitleCellSep'    : ' |= '          ,
        'tableRowOpen'         : '| '            ,
        'tableRowClose'        : ' |'            ,
        'tableCellSep'         : ' | '           ,
        # TODO: placeholder (mark for unknown syntax)
        # if possible: http://www.wikicreole.org/wiki/Placeholder
    },
        # regular markdown: http://daringfireball.net/projects/markdown/syntax
        # markdown extra:   http://michelf.com/projects/php-markdown/extra/
        # sandbox:
        # http://daringfireball.net/projects/markdown/dingus
        # http://michelf.com/projects/php-markdown/dingus/
    'md': {
        'title1'               : '# \a '         ,
        'title2'               : '## \a '        ,
        'title3'               : '### \a '       ,
        'title4'               : '#### \a '      ,
        'title5'               : '##### \a '     ,
        'blockVerbLine'        : '    '          ,
        'blockQuoteLine'       : '> '            ,
        'fontMonoOpen'         : "`"             ,
        'fontMonoClose'        : "`"             ,
        'fontBoldOpen'         : "**"            ,
        'fontBoldClose'        : "**"            ,
        'fontItalicOpen'       : "*"             ,
        'fontItalicClose'      : "*"             ,
        'fontUnderlineOpen'    : ""              ,
        'fontUnderlineClose'   : ""              ,
        'fontStrikeOpen'       : ""              ,
        'fontStrikeClose'      : ""              ,
        # Lists
        #'listOpenCompact'             : '*'     ,
        'listItemLine'          : ' '            ,
        'listItemOpen'          : '*'            ,
        #'numlistItemLine'       : '1.'          ,
        'numlistItemOpen'       : '1.'           ,
        'deflistItem1Open'      : ': '           ,
        #'deflistItem1Close'     : ':'           ,
        #'deflistItem2LineOpen'  : '::'          ,
        #'deflistItem2LineClose' : ':'           ,
        # Verbatim block
        #'blockVerbOpen'        : ''             ,
        #'blockVerbClose'       : ''             ,
        'bar1'                 : '---'           ,
        'bar2'                 : '---'           ,
        # URL, email and anchor
        'url'                   : '\a'           ,
        'urlMark'               : '[\a](\a)'     ,
        'email'                 : '\a'           ,
        #'emailMark'             : '[[\a -> mailto:\a]]',
        #'anchor'                : '[[#\a]]\n'   ,
        # Image markup
        'img'                   : '![](\a)'      ,
        #'imgAlignLeft'         : '{{\a }}'      ,
        #'imgAlignRight'        : '{{ \a}}'      ,
        #'imgAlignCenter'       : '{{ \a }}'     ,
        # Table attributes
        'tableTitleRowOpen'    : '| '            ,
        'tableTitleRowClose'   : '|\n|---------------|'            ,
        'tableTitleCellSep'    : ' |'            ,
        'tableRowOpen'         : '|'             ,
        'tableRowClose'        : '|'             ,
        'tableCellSep'         : ' |'            ,
    },
        # http://www.phpbb.com/community/faq.php?mode=bbcode
        # http://www.bbcode.org/reference.php (but seldom implemented)
    'bbcode': {
        'title1'               : '[size=200]\a[/size]'             ,
        'title2'               : '[size=170]\a[/size]'             ,
        'title3'               : '[size=150]\a[/size]'             ,
        'title4'               : '[size=130]\a[/size]'             ,
        'title5'               : '[size=120]\a[/size]'             ,
        'blockQuoteOpen'       : '[quote]'         ,
        'blockQuoteClose'      : '[/quote]'        ,
        'fontMonoOpen'         : '[code]'          ,
        'fontMonoClose'        : '[/code]'         ,
        'fontBoldOpen'         : '[b]'             ,
        'fontBoldClose'        : '[/b]'            ,
        'fontItalicOpen'       : '[i]'             ,
        'fontItalicClose'      : '[/i]'            ,
        'fontUnderlineOpen'    : '[u]'             ,
        'fontUnderlineClose'   : '[/u]'            ,
        #'fontStrikeOpen'       : '[s]'            , (not supported by phpBB)
        #'fontStrikeClose'      : '[/s]'           ,
        'listOpen'             : '[list]'          ,
        'listClose'            : '[/list]'         ,
        'listItemOpen'         : '[*]'             ,
        #'listItemClose'        : '[/li]'          ,
        'numlistOpen'          : '[list=1]'        ,
        'numlistClose'         : '[/list]'         ,
        'numlistItemOpen'      : '[*]'             ,
        'url'                  : '[url]\a[/url]'   ,
        'urlMark'              : '[url=\a]\a[/url]',
        #'urlMark'              : '[url]\a[/url]',
        'img'                  : '[img]\a[/img]'   ,
        #'tableOpen'            : '[table]',
        #'tableClose'           : '[/table]'       ,
        #'tableRowOpen'         : '[tr]'           ,
        #'tableRowClose'        : '[/tr]'          ,
        #'tableCellOpen'        : '[td]'           ,
        #'tableCellClose'       : '[/td]'          ,
        #'tableTitleCellOpen'   : '[th]'           ,
        #'tableTitleCellClose'  : '[/th]'          ,
    },
    # http://en.wikipedia.org/wiki/Rich_Text_Format
    # Based on RTF Version 1.5 specification
    # Should be compatible with MS Word 97 and newer
    # ~D~ and ~L~ are used to encode depth and nesting level formatting
    'rtf': {
        'title1'                : '~A~{\\pard\\plain\\s11\\keepn{\\*\\txttags title1}\\f1\\fs24\\qc\\sb240\\sa240\\sl480\\slmult1\\li0\\ri0\\fi0{\\b{\a}}\\par}',
        'title2'                : '~A~{\\pard\\plain\\s12\\keepn{\\*\\txttags title2}\\f1\\fs24\\ql\\sb240\\sa240\\sl480\\slmult1\\li0\\ri0\\fi0{\\b{\a}}\\par}',
        'title3'                : '~A~{\\pard\\plain\\s13\\keepn{\\*\\txttags title3}\\f1\\fs24\\ql\\sb240\\sa240\\sl480\\slmult1\\li360\\ri0\\fi0{\\b{\a}}\\par}',
        'title4'                : '~A~{\\pard\\plain\\s14\\keepn{\\*\\txttags title4}\\f1\\fs24\\ql\\sb240\\sa240\\sl480\\slmult1\\li360\\ri0\\fi0{\\b\\i{\a}}\\par}',
        'title5'                : '~A~{\\pard\\plain\\s15\\keepn{\\*\\txttags title5}\\f1\\fs24\\ql\\sb240\\sa240\\sl480\\slmult1\\li360\\ri0\\fi0{\\i{\a}}\\par}',
        'numtitle1'             : '~A~{\\pard\\plain\\s11\\keepn{\\*\\txttags title1}\\f1\\fs24\\qc\\sb240\\sa240\\sl480\\slmult1\\li0\\ri0\\fi0\\ls3\\ilvl0{\\b{\a}}\\par}',
        'numtitle2'             : '~A~{\\pard\\plain\\s12\\keepn{\\*\\txttags title2}\\f1\\fs24\\ql\\sb240\\sa240\\sl480\\slmult1\\li0\\ri0\\fi0\\ls3\\ilvl1{\\b{\a}}\\par}',
        'numtitle3'             : '~A~{\\pard\\plain\\s13\\keepn{\\*\\txttags title3}\\f1\\fs24\\ql\\sb240\\sa240\\sl480\\slmult1\\li360\\ri0\\fi0\\ls3\\ilvl2{\\b{\a}}\\par}',
        'numtitle4'             : '~A~{\\pard\\plain\\s14\\keepn{\\*\\txttags title4}\\f1\\fs24\\ql\\sb240\\sa240\\sl480\\slmult1\\li360\\ri0\\fi0\\ls3\\ilvl3{\\b\\i{\a}}\\par}',
        'numtitle5'             : '~A~{\\pard\\plain\\s15\\keepn{\\*\\txttags title5}\\f1\\fs24\\ql\\sb240\\sa240\\sl480\\slmult1\\li360\\ri0\\fi0\\ls3\\ilvl4{\\i{\a}}\\par}',
        'paragraphOpen'         : '{\\pard\\plain\\s2{\\*\\txttags paragraph}\\f0\\fs24\\qj\\sb0\\sa0\\sl480\\slmult1\\li~D~\\ri0\\fi360',
        'paragraphClose'        : '\\par}',
        'blockVerbOpen'         : '{\\pard\\plain\\s3{\\*\\txttags verbatim}\\f2\\fs20\\ql\\sb0\\sa240\\sl240\\slmult1\\li720\\ri720\\fi0',
        'blockVerbSep'          : '\\line',
        'blockVerbClose'        : '\\par}',
        'blockQuoteOpen'        : '{\\pard\\plain\\s4{\\*\\txttags quote}\\f0\\fs24\\qj\\sb0\\sa0\\sl480\\slmult1\\li~D~\\ri720\\fi0',
        'blockQuoteClose'       : '\\par}',
        'fontMonoOpen'          : '{\\f2\\fs20{',
        'fontMonoClose'         : '}}',
        'fontBoldOpen'          : '{\\b{',
        'fontBoldClose'         : '}}',
        'fontItalicOpen'        : '{\\i{',
        'fontItalicClose'       : '}}',
        'fontUnderlineOpen'     : '{\\ul{',
        'fontUnderlineClose'    : '}}',
        'fontStrikeOpen'        : '{\\strike{',
        'fontStrikeClose'       : '}}',
        'anchor'                : '{\\*\\bkmkstart \a}{\\*\\bkmkend \a}',
        # 'comment'               : '{\\v \a }',  # doesn't hide text in all readers
        'pageBreak'             : '\\page\n',
        'EOD'                   : '}',
        'url'                   : '{\\field{\\*\\fldinst{HYPERLINK "\a"}}{\\fldrslt{\\ul\\cf1 \a}}}',
        'urlMark'               : '{\\field{\\*\\fldinst{HYPERLINK "\a"}}{\\fldrslt{\\ul\\cf1 \a}}}',
        'email'                 : '{\\field{\\*\\fldinst{HYPERLINK "mailto:\a"}}{\\fldrslt{\\ul\\cf1 \a}}}',
        'emailMark'             : '{\\field{\\*\\fldinst{HYPERLINK "mailto:\a"}}{\\fldrslt{\\ul\\cf1 \a}}}',
        'img'                   : '{\\field{\\*\\fldinst{INCLUDEPICTURE "\a" \\\\* MERGEFORMAT \\\\d}}{\\fldrslt{(\a)}}}',
        'imgEmbed'              : '{\*\shppict{\pict\a}}',
        'listOpen'              : '{\\pard\\plain\\s21{\\*\\txttags list}\\f0\\fs24\\qj\\sb0\\sa0\\sl480\\slmult1',
        'listClose'             : '}',
        'listItemOpen'          : '{\\*\\listtext{\\*\\txttags list indent}\\li~D~\\ri0\\fi-360\\\'95\\tab}\\ls1\\ilvl~L~{\\*\\txttags list indent}\\li~D~\\ri0\\fi-360\n',
        'listItemClose'         : '\\par',
        'numlistOpen'           : '{\\pard\\plain\\s21{\\*\\txttags list}\\f0\\fs24\\qj\\sb0\\sa0\\sl480\\slmult1',
        'numlistClose'          : '}',
        'numlistItemOpen'       : '{\\*\\listtext{\\*\\txttags list indent}\\li~D~\\ri0\\fi-360 \a.\\tab}\\ls2\\ilvl~L~{\\*\\txttags list indent}\\li~D~\\ri0\\fi-360\n',
        'numlistItemClose'      : '\\par',
        'deflistOpen'           : '{\\pard\\plain\\s21{\\*\\txttags list}\\f0\\fs24\\qj\\sb0\\sa0\\sl480\\slmult1',
        'deflistClose'          : '}',
        'deflistItem1Open'      : '{\\*\\txttags list indent}\\li~D~\\ri0\\fi-360{\\b\n',
        'deflistItem1Close'     : ':}\\tab',
        'deflistItem2Open'      : '',
        'deflistItem2Close'     : '\\par',
        'tableOpen'             : '{\\pard\\plain',
        'tableClose'            : '\\par}',
        'tableRowOpen'          : '{\\trowd\\trgaph60~A~~B~',
        'tableRowClose'         : '\\row}',
        'tableRowSep'           : '',
        'tableTitleRowOpen'     : '{\\trowd\\trgaph60\\trhdr~A~~B~\\trbrdrt\\brdrs\\brdrw20\\trbrdrb\\brdrs\\brdrw20',
        'tableTitleRowClose'    : '',
        'tableCellOpen'         : '{\\intbl\\itap1\\f0\\fs20~A~ ',
        'tableCellClose'        : '\\cell}',
        'tableCellHead'         : '~B~~S~',
        'tableTitleCellOpen'    : '{\\intbl\\itap1\\f0\\fs20~A~\\b ',
        'tableTitleCellClose'   : '\\cell}',
        'tableTitleCellHead'    : '~B~\\clbrdrt\\brdrs\\brdrw20\\clbrdrb\\brdrs\\brdrw20~S~',
        '_tableCellColSpan'     : '\\cellx\a',
        '_tableAlignLeft'       : '\\trql',
        '_tableAlignCenter'     : '\\trqc',
        '_tableBorder'          : '\\trbrdrt\\brdrs\\brdrw10\\trbrdrb\\brdrs\\brdrw10\\trbrdrl\\brdrs\\brdrw10\\trbrdrr\\brdrs\\brdrw10',
        '_tableCellAlignLeft'   : '\\ql',
        '_tableCellAlignRight'  : '\\qr',
        '_tableCellAlignCenter' : '\\qc',
        '_tableCellBorder'      : '\\clbrdrt\\brdrs\\brdrw10\\clbrdrb\\brdrs\\brdrw10\\clbrdrl\\brdrs\\brdrw10\\clbrdrr\\brdrs\\brdrw10',
        'bar1'                  : '{\\pard\\plain\\s1\\brdrt\\brdrs\\brdrw10\\li1400\\sb120\\sa120\\ri1400\\fs12\\par}',
        'bar2'                  : '{\\pard\\plain\\s1\\brdrt\\brdrs\\brdrdb\\brdrw10\\sb120\\sa120\\li1400\\ri1400\\fs12\\par}'
    },

# http://foswiki.org/System/TextFormattingRules
# http://twiki.org/cgi-bin/view/TWiki/TextFormattingRules
    'tml': {
        'title1'            : '---++ \a',
        'title2'            : '---+++ \a',
        'title3'            : '---++++ \a',
        'title4'            : '---+++++ \a',
        'title5'            : '---++++++ \a',
        'blockVerbOpen'     : '<verbatim>',
        'blockVerbClose'        : '</verbatim>',
        'blockQuoteOpen'        : '<blockquote>',
        'blockQuoteClose'       : '</blockquote>',
        'fontMonoOpen'          : '=',
        'fontMonoClose'         : '=',
        'fontBoldOpen'          : "*",
        'fontBoldClose'         : "*",
        'fontItalicOpen'        : "_",
        'fontItalicClose'       : "_",
        'fontUnderlineOpen'     : '<u>',
        'fontUnderlineClose'    : '</u>',
        'fontStrikeOpen'        : '<del>',
        'fontStrikeClose'       : '</del>',
        'listItemLine'          : '   ',
        'listItemOpen'          : '* ',
        'numlistItemLine'       : '   ',
        'numlistItemOpen'       : '1. ',
        'deflistItemLine'       : '   ',
        'listItemLine'          : '   ',
        'listItemOpen'          : '* ',
        'numlistItemLine'       : '   ',
        'numlistItemOpen'       : '1. ',
        'deflistItemLine'       : '   ',
        'deflistItem1Open'      : '$ ',
        'deflistItem2Open'      : ': ',
        'bar1'                  : '---',
        'bar2'                  : '---',
        'img'                   : '<img~A~ src="%ATTACHURL%/\a" border="0" alt="">',
        'urlImg'                : '[[\a][<img~A~ src="%ATTACHURL%/\a" border="0" alt="">]]',
        'imgEmbed'              : '<img~A~ src="%ATTACHURL%/\a" border="0" alt="">',
        '_imgAlignLeft'         : ' align="left"',
        '_imgAlignCenter'       : ' align="middle"',
        '_imgAlignRight'        : ' align="right"',
        'url'                   : '[[\a]]',
        'urlMark'               : '[[\a][\a]]',
        'anchor'                : '[[#\a]]\n',
        'urlMarkAnchor'         : '[[\a][\a]]',
        'email'                 : '\a',
        'emailMark'             : '[[mailto:\a][\a]]',
        'tableRowOpen'          : '|',
        'tableRowClose'         : '|',
        'tableTitleCellOpen'    : ' *',
        'tableTitleCellClose'   : '* ',
        'tableTitleCellSep'     : '|',
        'tableCellOpen'         : ' ',
        'tableCellClose'        : ' ~S~',
        'tableCellSep'  : '|',
        '_tableCellColSpan'     : '|',
        'comment'               : '<!-- \a -->',
        'TOC'                   : '%TOC%',
     },
#
## MOM ##
#
# for mom macros documentation see: http://www.schaffter.ca/mom/mom-01.html
# I commented the difficult parts...
    'mom': {
        'paragraphOpen'        : '.PP'            ,
        'title1'               : '.HEAD "\a"'     ,
        'title2'               : '.SUBHEAD "\a"' ,
        'title3'               : '.SUBSUBHEAD "\a"' ,
        'title4'               : '.PP\n.PARAHEAD "\a"' ,
        'title5'               : '.PP\n.PARAHEAD "\\*[UL]\a\\f[R]\\"' , # my choice
# NB for mom ALL heads of a level after the first numbered are numbered!
# The "NUMBER_*" macros are toggle ones
        'numtitle1'            : '.NUMBER_HEADS\n.HEAD "\a"' ,
        'numtitle2'            : '.NUMBER_SUBHEADS\n.SUBHEAD "\a"' ,
        'numtitle3'            : '.NUMBER_SUBSUBHEADS\n.SUBSUBHEAD "\a"' ,
        'numtitle4'            : '.NUMBER_PARAHEADS\n.PP\nPARAHEAD "\a"' ,
        'numtitle5'            : '.NUMBER_PARAHEADS\n.PP\n.PARAHEAD "\\*[UL]\a\\f[R]\\"' , # my choice
#        'anchor'               : '"\a"', # not supported
        'blockVerbOpen'        : '.QUOTE\n.CODE' , # better for quoting code
        'blockVerbClose'       : '.CODE OFF\n.QUOTE OFF'         ,
        'blockVerbLine '       : '.QUOTE\n.CODE\n\a\n.CODE OFF\n.QUOTE OFF' ,
        'blockQuoteOpen'       : '.BLOCKQUOTE'   ,
        'blockQuoteClose'      : '.BLOCKQUOTE OFF'  ,
#        'blockQuoteLine'       : '.BLOCKQUOTE\n\a\.BLOCKQUOTE OFF' , 
        'fontMonoOpen'         : '\\f[CR]' ,
        'fontMonoClose'        : '\\f[]'  ,
        'fontBoldOpen'         : '\\f[B]'  ,
        'fontBoldClose'        : '\\f[]'  ,
        'fontItalicOpen'       : '\\f[I]'  ,
        'fontItalicClose'      : '\\f[]'  ,
        'fontUnderlineOpen'    : '\\*[FWD 8p]\\*[UL]' , # dirty trick for a bug(?) in mom!
        'fontUnderlineClose'   : '\\*[ULX]'           ,
# Strike. Not directly supported. A groff geek could do a macro for that, not me! :-(
# Use this tricks to emulate "a sort of" strike through word.
# It strikes start and end of a word.
# Not good for less than 3 chars word
# For 4 or 5 chars word is not bad!
# Beware of escapes trying to change it!
# No! It's too ugly!
#        'fontStrikeOpen'       : '\\v\'-0.25m\'\\l\'1P\'\\h\'-1P\'\\v\'0.25m\'' ,
#        'fontStrikeClose'      : '\\v\'-0.25m\'\\l\'-1P\'\\v\'0.25m\'' ,
# Prefer a sort of tag to point out situation
        'fontStrikeOpen'       : '[\(mi' ,
        'fontStrikeClose'      : '\(mi]' ,
        'listOpen'             : '.LIST BULLET' , # other kinds of lists are possible, see mom documentation at site
        'listClose'            : '.LIST OFF'  ,
        'listItemOpen'         : '.ITEM\n'    ,
        'numlistOpen'          : '.LIST DIGIT',
        'numlistClose'         : '.LIST OFF'  ,
        'numlistItemOpen'      : '.ITEM\n'    ,
        'deflistOpen'          : '\\# DEF LIST ON'        , # deflist non supported but "permitted" using PARAHEAD macro or some other hack
        'deflistClose'         : '\\# DEF LIST OFF'        ,
#        'deflistItem1Open'     : '.BR\n.PT_SIZE +1\n\\f[B]' , # trick 1
#        'deflistItem1Close'    : '\\f[P]\n.PT_SIZE -1'      , # trick 2 for deflist
        'deflistItem1Open'     : '.PP\n.PARAHEAD "'        , # using PARAHEAD is better, it needs PP before.
        'deflistItem1Close'    : ': "'      , # "colon" is a personal choice...
        'bar1'                 : '.LINEBREAK' , # section break
        'bar2'                 : '.NEWPAGE' , # new page
        'url'                  : '\a' ,
# urlMark outputs like this: "label (http://ser.erfg.gov)". Needs a
# preproc rule to transform #anchor links, not used by mom, in
# labels only. Like this one: '\[(.+) #.+\]' '\1'   without that
# one obtains: label (#anchor)
        'urlMark'              : '\a (\a)' ,
        'email'                : '\a' ,
        'emailMark'            : '\a (\a)' , # like urlMark
        'urlImg'               : '.PSPIC "\a"\n.(\a)\n.SHIM\n', # Mmmh...
 # NB images: works only with .ps and .eps images (postscript and
 # encapsulated postscript) easily obtained with "convert" (in
 # ImageMagick suite) from *jpg, *png ecc. It's groff!
        'img'                 : '.PSPIC "\a"\n.SHIM\n',
        'imgAlignLeft'        : '.PSPIC -L "\a"\n.SHIM\n'  ,
        'imgAlignCenter'      : '.PSPIC "\a"\n.SHIM\n',
        'imgAlignRight'       : '.PSPIC -R "\a"\n.SHIM\n' ,
# All table stuff copied from man target! Tables need
# preprocessing with "tbl" using option "-t" with groff
        'tableOpen'             : '.TS\n~A~~B~tab(^); ~C~.', 
        'tableClose'            : '.TE'     ,
        'tableRowOpen'          : ' '       ,
        'tableCellSep'          : '^'       ,
        '_tableAlignCenter'     : 'center, ',
        '_tableBorder'          : 'allbox, ',
        '_tableColAlignLeft'    : 'l'       ,
        '_tableColAlignRight'   : 'r'       ,
        '_tableColAlignCenter'  : 'c'       ,
#        'cssOpen'              : '<STYLE TYPE="text/css">',
#        'cssClose'             : '</STYLE>',
        'comment'              : '\\# \a'    ,
        'blockCommentOpen'     : '.COMMENT' ,
        'blockCommentClose'    : '.COMMENT OFF' ,
        'TOC'                  : '.TOC', # NB: it must be the last macro in file!
        'EOD'                  : '.FINIS'
    },
    }
    for target in TARGETS_LIST:
        if getattr(getattr(targets, target), 'RULES', {}).get('confdependenttags'):
            reload(getattr(targets, target))
        alltags[target] = getattr(getattr(targets, target), 'TAGS', {})

    # Exceptions for --css-sugar
    if (config['css-sugar'] and config['target'] in ('html', 'xhtml', 'xhtmls')) or config['target'] == 'wp':
        # Change just HTML because XHTML inherits it
        htmltags = alltags['html']
        # Table with no cellpadding
        htmltags['tableOpen'] = htmltags['tableOpen'].replace(' CELLPADDING="4"', '')
        # DIVs
        htmltags['tocOpen'] = '<DIV CLASS="toc">'
        htmltags['tocClose'] = '</DIV>'
        htmltags['bodyOpen'] = '<DIV CLASS="body" ID="body">'
        htmltags['bodyClose'] = '</DIV>'

    # Make the HTML -> XHTML inheritance
    xhtml = alltags['html'].copy()
    for key in xhtml.keys():
        xhtml[key] = xhtml[key].lower()
    # Some like HTML tags as lowercase, some don't... (headers out)
    if HTML_LOWER:
        alltags['html'] = xhtml.copy()
    if config['target'] == 'htmls':
        alltags['htmls'] = alltags['html5'].copy()
    if config['target'] == 'texs':
        alltags['texs'] = alltags['tex'].copy()
    if config['target'] == 'csvs':
        alltags['csvs'] = alltags['csv'].copy()
    if config['target'] in ('xhtml', 'xhtmls', 'html5', 'htmls', 'wp'):
        xhtml.update(alltags[config['target']])
        alltags[config['target']] = xhtml.copy()

    if config['target'] == 'aat' and config['slides']:
        alltags['aat']['urlMark'] = alltags['aat']['emailMark'] = '\a (\a)'
        alltags['aat']['bar1'] = aa_line(AA['bar1'], config['width'] - 2)
        alltags['aat']['bar2'] = aa_line(AA['bar2'], config['width'] - 2)
        if not config['chars']:
            alltags['aat']['listItemOpen'] = '* '
    if config['target'] == 'aat' and config['web']:
        alltags['aat']['url'] = alltags['aat']['urlMark'] = '<a href="\a">\a</a>'
        alltags['aat']['email'] = alltags['aat']['emailMark'] = '<a href="mailto:\a">\a</a>'
        alltags['aat']['img'] = '<img src="\a" alt=""/>'
        alltags['aat']['anchor'] = '<a id="\a">'
        alltags['aat']['comment'] = '<!-- \a -->'
        for beautifier in ['Bold', 'Italic', 'Underline', 'Strike']:
            _open, close = 'font' + beautifier + 'Open', 'font' + beautifier + 'Close'
            alltags['aat'][_open], alltags['aat'][close] = alltags['html'][_open].lower(), alltags['html'][close].lower()

    # Compose the target tags dictionary
    tags = {}
    target_tags = alltags[config['target']].copy()

    for key in keys:
        tags[key] = ''  # create empty keys
    for key in target_tags.keys():
        tags[key] = maskEscapeChar(target_tags[key])  # populate

    # Map strong line to pagebreak
    if rules['mapbar2pagebreak'] and tags['pageBreak']:
        tags['bar2'] = tags['pageBreak']

    # Change img tag if embedding images in RTF
    if config['embed-images']:
        if tags.get('imgEmbed'):
            tags['img'] = tags['imgEmbed']
        else:
            Error(_("Invalid --embed-images option with target '%s'." % config['target']))

    # Map strong line to separator if not defined
    if not tags['bar2'] and tags['bar1']:
        tags['bar2'] = tags['bar1']

    return tags


##############################################################################


def getRules(config):
    "Returns all the target-specific syntax rules"

    ret = {}
    allrules = [

        # target rules (ON/OFF)
        'linkable',               # target supports external links
        'tableable',              # target supports tables
        'tableonly',              # target computes only the tables
        'spread',                 # target uses the spread.py engine
        'spreadgrid',             # target adds the reference grid to the sheet
        'imglinkable',            # target supports images as links
        'imgalignable',           # target supports image alignment
        'imgasdefterm',           # target supports image as definition term
        'autonumberlist',         # target supports numbered lists natively
        'autonumbertitle',        # target supports numbered titles natively
        'stylable',               # target supports external style files
        'parainsidelist',         # lists items supports paragraph
        'compactlist',            # separate enclosing tags for compact lists
        'spacedlistitem',         # lists support blank lines between items
        'listnotnested',          # lists cannot be nested
        'listitemnotnested',      # list items must be closed before nesting lists
        'quotenotnested',         # quotes cannot be nested
        'verbblocknotescaped',    # don't escape specials in verb block
        'verbblockfinalescape',   # do final escapes in verb block
        'escapeurl',              # escape special in link URL
        'labelbeforelink',        # label comes before the link on the tag
        'onelinepara',            # dump paragraph as a single long line
        'onelinequote',           # dump quote as a single long line (EXPERIMENTAL)
        'notbreaklistitemclose',  # do not break line before the list item close tag (EXPERIMENTAL)
        'tabletitlerowinbold',    # manually bold any cell on table titles
        'tablecellstrip',         # strip extra spaces from each table cell
        'tablecellspannable',     # the table cells can have span attribute
        'tablecellmulticol',      # separate open+close tags for multicol cells
        'tablecolumnsnumber',     # set the number of columns in place of n_cols in tableOpen
        'tablenumber',            # set the number of the table in place of n_table in tableOpen
        'barinsidequote',         # bars are allowed inside quote blocks
        'finalescapetitle',       # perform final escapes on title lines
        'autotocnewpagebefore',   # break page before automatic TOC
        'autotocnewpageafter',    # break page after automatic TOC
        'autotocwithbars',        # automatic TOC surrounded by bars
        'plaintexttoc',           # TOC will be plain text (no links)
        'mapbar2pagebreak',       # map the strong bar to a page break
        'titleblocks',            # titles must be on open/close section blocks
        'listlineafteropen',      # put listItemLine after listItemOpen
        'escapexmlchars',         # escape the XML special chars: < > &
        'listlevelzerobased',     # list levels start at 0 when encoding into tags
        'zerodepthparagraph',     # non-nested paras have block depth of 0 instead of 1
        'cellspancumulative',     # cell span value adds up for each cell of a row
        'keepblankheaderline',    # template lines are not removed if headers are blank
        'confdependenttags',      # tags are configuration dependent
        'confdependentrules',     # rules are configuration dependent

        # Target code beautify (ON/OFF)
        'indentverbblock',        # add leading spaces to verb block lines
        'breaktablecell',         # break lines after any table cell
        'breaktablelineopen',     # break line after opening table line
        'notbreaklistopen',       # don't break line after opening a new list
        'keepquoteindent',        # don't remove the leading TABs on quotes
        'keeplistindent',         # don't remove the leading spaces on lists
        'blankendautotoc',        # append a blank line at the auto TOC end
        'tagnotindentable',       # tags must be placed at the line beginning
        'spacedlistitemopen',     # append a space after the list item open tag
        'spacednumlistitemopen',  # append a space after the numlist item open tag
        'deflisttextstrip',       # strip the contents of the deflist text
        'blanksaroundpara',       # put a blank line before and after paragraphs
        'blanksaroundverb',       # put a blank line before and after verb blocks
        'blanksaroundquote',      # put a blank line before and after quotes
        'blanksaroundlist',       # put a blank line before and after lists
        'blanksaroundnumlist',    # put a blank line before and after numlists
        'blanksarounddeflist',    # put a blank line before and after deflists
        'blanksaroundnestedlist', # put a blank line before and after all type of nested lists
        'blanksaroundtable',      # put a blank line before and after tables
        'blanksaroundbar',        # put a blank line before and after bars
        'blanksaroundtitle',      # put a blank line before and after titles
        'blanksaroundnumtitle',   # put a blank line before and after numtitles
        'iswrapped',              # wrap with the --width value

        # Value settings
        'listmaxdepth',           # maximum depth for lists
        'quotemaxdepth',          # maximum depth for quotes
        'tablecellaligntype',     # type of table cell align: cell, column
        'blockdepthmultiply',     # block depth multiple for encoding
        'depthmultiplyplus',      # add to block depth before multiplying
        'cellspanmultiplier',     # cell span is multiplied by this value
        'spreadmarkup',           # the markup spread engine option: 'txt', 'html' or 'tex'
    ]

    rules_bank = {
        'txt': {
            'indentverbblock': 1,
            'spacedlistitem': 1,
            'parainsidelist': 1,
            'keeplistindent': 1,
            'barinsidequote': 1,
            'autotocwithbars': 1,
            'plaintexttoc': 1,

            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
            'iswrapped': 1,
        },
        'txt2t': {
            'linkable': 1,
            'tableable': 1,
            'imglinkable': 1,
            # 'imgalignable',
            'imgasdefterm': 1,
            'autonumberlist': 1,
            'autonumbertitle': 1,
            'stylable': 1,
            'spacedlistitem': 1,
            'labelbeforelink': 1,
            'tablecellstrip': 1,
            'tablecellspannable': 1,
            'keepblankheaderline': 1,
            'barinsidequote': 1,
            'keeplistindent': 1,
            'blankendautotoc': 1,
            'blanksaroundpara': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
            'tablecellaligntype': 'cell',
        },
        'rst': {
            'indentverbblock': 1,
            'spacedlistitem': 1,
            'parainsidelist': 1,
            'keeplistindent': 1,
            'barinsidequote': 1,
            'imgalignable': 1,
            'imglinkable': 1,
            'tableable': 1,

            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
            'blanksaroundnestedlist': 1,
        },
        'aat': {
            #TIP art inherits all TXT rules
        },
        'csv': {
            'tableable': 1,
            'tableonly': 1,
            'tablecellstrip': 1,
            'blanksaroundtable': 1,
        },
        'csvs': {
            #TIP csvs inherits all csv rules
            'spread': 1,
            'spreadmarkup': 'txt',
        },
        'db': {
            'tableable': 1,
            'tableonly': 1,
        },
        'ods': {
            'escapexmlchars': 1,
            'tableable': 1,
            'tableonly': 1,
            'tablecellstrip': 1,
            'tablenumber': 1,
        },
        'html': {
            'escapexmlchars': 1,
            'indentverbblock': 1,
            'linkable': 1,
            'stylable': 1,
            'escapeurl': 1,
            'imglinkable': 1,
            'imgalignable': 1,
            'imgasdefterm': 1,
            'autonumberlist': 1,
            'spacedlistitem': 1,
            'parainsidelist': 1,
            'tableable': 1,
            'tablecellstrip': 1,
            'breaktablecell': 1,
            'breaktablelineopen': 1,
            'keeplistindent': 1,
            'keepquoteindent': 1,
            'barinsidequote': 1,
            'autotocwithbars': 1,
            'tablecellspannable': 1,
            'tablecellaligntype': 'cell',

            # 'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            # 'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
        },
        'xhtml': {
            #TIP xhtml inherits all HTML rules
        },
        'wp': {
            #TIP wp inherits all HTML rules
            'onelinepara': 1,
            'onelinequote': 1,
            'tagnotindentable': 1,
            'blanksaroundpara': 1,
            'quotemaxdepth': 1,
            'keepquoteindent': 0,
            'keeplistindent': 0,
            'notbreaklistitemclose': 1,
        },

        'xhtmls': {
            #TIP xhtmls inherits all HTML rules
        },
        'html5': {
            #TIP html5 inherits all HTML rules
            'titleblocks' : 1,
        },
        'htmls': {
            #TIP htmls inherits all HTML rules
            'tableonly': 1,
            'spread': 1,
            'spreadgrid': 1,
            'spreadmarkup': 'html',
        },

        'sgml': {
            'escapexmlchars': 1,
            'linkable': 1,
            'escapeurl': 1,
            'autonumberlist': 1,
            'spacedlistitem': 1,
            'tableable': 1,
            'tablecellstrip': 1,
            'blankendautotoc': 1,
            'keeplistindent': 1,
            'keepquoteindent': 1,
            'barinsidequote': 1,
            'finalescapetitle': 1,
            'tablecellaligntype': 'column',

            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
            'quotemaxdepth': 1,
        },
        'dbk': {
            'escapexmlchars': 1,
            'linkable': 1,
            'tableable': 1, 
            'imglinkable': 1,
            'imgalignable': 1,
            'imgasdefterm': 1,
            'autonumberlist': 1,
            'autonumbertitle': 1,
            'parainsidelist': 1,
            'spacedlistitem': 1,
            'titleblocks': 1,
            'tablecolumnsnumber': 1,
        },
        'vimwiki': {
            'linkable':1,
            'tableable':1,
            #'spacedlistitem':1,
            #'tablecellstrip':1,
            #'autotocwithbars':1,
            #'spacedlistitemopen':1,
            #'spacednumlistitemopen':1,
            #'deflisttextstrip':1,
            'autonumberlist':1,
            'autonumbertitle':1,
            'imgalignable':1,
            'keeplistindent':1,

            'blanksaroundpara':1,
            'blanksaroundverb':1,
            # 'blanksaroundquote':1,
            #'blanksaroundlist':1,
            #'blanksaroundnumlist':1,
            #'blanksarounddeflist':1,
            'blanksaroundtable':1,
            'blanksaroundbar':1,
            'blanksaroundtitle':1,
            'blanksaroundnumtitle':1,
        },
        'mgp': {
            'tagnotindentable': 1,
            'spacedlistitem': 1,
            'imgalignable': 1,
            'autotocnewpagebefore': 1,

            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            # 'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'tableable': 1,
            # 'blanksaroundtitle': 1,
            # 'blanksaroundnumtitle': 1,
        },
        'tex': {
            'stylable': 1,
            'escapeurl': 1,
            'autonumberlist': 1,
            'autonumbertitle': 1,
            'spacedlistitem': 1,
            'compactlist': 1,
            'parainsidelist': 1,
            'tableable': 1,
            'tablecellstrip': 1,
            'tabletitlerowinbold': 1,
            'verbblocknotescaped': 1,
            'keeplistindent': 1,
            'listmaxdepth': 4,  # deflist is 6
            'quotemaxdepth': 6,
            'barinsidequote': 1,
            'finalescapetitle': 1,
            'autotocnewpageafter': 1,
            'mapbar2pagebreak': 1,
            'tablecellaligntype': 'column',
            'tablecellmulticol': 1,

            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            # 'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
        },
        'texs': {
            #TIP texs inherits all tex rules
            'tableonly': 1,
            'spread': 1,
            'spreadgrid': 1,
            'spreadmarkup': 'tex',
        },
        'lout': {
            'keepquoteindent': 1,
            'deflisttextstrip': 1,
            'escapeurl': 1,
            'verbblocknotescaped': 1,
            'imgalignable': 1,
            'mapbar2pagebreak': 1,
            'titleblocks': 1,
            'autonumberlist': 1,
            'parainsidelist': 1,

            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            # 'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
        },
        'moin': {
            'spacedlistitem': 1,
            'linkable': 1,
            'keeplistindent': 1,
            'tableable': 1,
            'barinsidequote': 1,
            'tabletitlerowinbold': 1,
            'tablecellstrip': 1,
            'autotocwithbars': 1,
            'tablecellspannable': 1,
            'tablecellaligntype': 'cell',
            'deflisttextstrip': 1,

            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            # 'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            # 'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
        },
        'gwiki': {
            'spacedlistitem': 1,
            'linkable': 1,
            'keeplistindent': 1,
            'tableable': 1,
            'tabletitlerowinbold': 1,
            'tablecellstrip': 1,
            'autonumberlist': 1,

            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            # 'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            # 'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
        },
        'adoc': {
            'spacedlistitem': 1,
            'linkable': 1,
            'keeplistindent': 0,
            'autonumberlist': 1,
            'autonumbertitle': 1,
            'listnotnested': 1,
            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
        },
        'doku': {
            'indentverbblock': 1,  # DokuWiki uses '  ' to mark verb blocks
            'spacedlistitem': 1,
            'linkable': 1,
            'keeplistindent': 1,
            'tableable': 1,
            'barinsidequote': 1,
            'tablecellstrip': 1,
            'autotocwithbars': 1,
            'autonumberlist': 1,
            'imgalignable': 1,
            'tablecellaligntype': 'cell',

            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            # 'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
        },
        'pmw': {
            'indentverbblock': 1,
            'spacedlistitem': 1,
            'linkable': 1,
            'labelbeforelink': 1,
            # 'keeplistindent': 1,
            'tableable': 1,
            'barinsidequote': 1,
            'tablecellstrip': 1,
            'autotocwithbars': 1,
            'autonumberlist': 1,
            'spacedlistitemopen': 1,
            'spacednumlistitemopen': 1,
            'imgalignable': 1,
            'tabletitlerowinbold': 1,
            'tablecellaligntype': 'cell',

            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
        },
        'wiki': {
            'escapexmlchars': 1,
            'linkable': 1,
            'tableable': 1,
            'tablecellstrip': 1,
            'autotocwithbars': 1,
            'spacedlistitemopen': 1,
            'spacednumlistitemopen': 1,
            'deflisttextstrip': 1,
            'autonumberlist': 1,
            'imgalignable': 1,
            'tablecellspannable': 1,
            'tablecellaligntype': 'cell',

            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            # 'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
        },
        'red': {
            'linkable': 1,
            'tableable': 1,
            'tablecellstrip': 1,
            'tablecellspannable': 1,
            'tablecellaligntype': 'cell',
            'autotocwithbars': 1,
            'spacedlistitemopen': 1,
            'spacednumlistitemopen': 1,
            'deflisttextstrip': 1,
            'autonumberlist': 1,
            'imgalignable': 1,
            'labelbeforelink': 1,
            'quotemaxdepth': 1,
            'autonumbertitle': 1,
            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            # 'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
        },
        'man': {
            'spacedlistitem': 1,
            'tagnotindentable': 1,
            'tableable': 1,
            'tablecellaligntype': 'column',
            'tabletitlerowinbold': 1,
            'tablecellstrip': 1,
            'barinsidequote': 1,
            'parainsidelist': 0,
            'plaintexttoc': 1,

            'blanksaroundpara': 0,
            'blanksaroundverb': 1,
            # 'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            # 'blanksaroundbar': 1,
            'blanksaroundtitle': 0,
            'blanksaroundnumtitle': 1,
        },
        'utmac': {
            'tagnotindentable': 1,
            'autonumbertitle': 1,
            'quotenotnested' : 1,
            'barinsidequote': 1,
            'parainsidelist': 0,
            'spacedlistitem': 0,
            'labelbeforelink' : 0, # is that work ?
            'imgalignable': 1,
            'plaintexttoc': 0,
        
            'tableable': 1,
            'tablecellaligntype': 'column',
            'tabletitlerowinbold': 1,
            'tablecellstrip': 1,
        
            'blanksaroundpara': 0,
            'blanksaroundverb': 0,
            'blanksaroundquote': 0,
            'blanksaroundlist': 0,
            'blanksaroundnumlist': 0,
            'blanksarounddeflist': 0,
            'blanksaroundtable': 0,
            'blanksaroundbar': 0,
            'blanksaroundtitle': 0,
            'blanksaroundnumtitle': 0,
        },
        'pm6': {
            'keeplistindent': 1,
            'verbblockfinalescape': 1,
            #TODO add support for these
            # maybe set a JOINNEXT char and do it on addLineBreaks()
            'notbreaklistopen': 1,
            'barinsidequote': 1,
            'autotocwithbars': 1,
            'onelinepara': 1,

            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            # 'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            # 'blanksaroundtable': 1,
            # 'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
        },
        'creole': {
            'linkable': 1,
            'tableable': 1,
            'imglinkable': 1,
            'tablecellstrip': 1,
            'autotocwithbars': 1,
            'spacedlistitemopen': 1,
            'spacednumlistitemopen': 1,
            'deflisttextstrip': 1,
            'verbblocknotescaped': 1,
            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
        },
        'md': {
            #'keeplistindent': 1,
            'linkable': 1,
            'labelbeforelink': 1,
            'tableable': 1,
            'imglinkable': 1,
            'tablecellstrip': 1,
            'autonumberlist': 1,
            'spacedlistitemopen': 1,
            'spacednumlistitemopen': 1,
            'deflisttextstrip': 1,
            'blanksaroundpara': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            #'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
        },
        'bbcode': {
            #'keeplistindent': 1,
            'keepquoteindent': 1,
            #'indentverbblock': 1,
            'linkable': 1,
            #'labelbeforelink': 1,
            #'tableable': 1,
            'imglinkable': 1,
            'tablecellstrip': 1,
            #'autotocwithbars': 1,
            'autonumberlist': 1,
            'spacedlistitemopen': 1,
            'spacednumlistitemopen': 1,
            'deflisttextstrip': 1,
            #'verbblocknotescaped': 1,
            'blanksaroundpara': 1,
            #'blanksaroundverb': 1,
            #'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            #'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
        },
        'spip': {
            'spacedlistitem': 1,
            'spacedlistitemopen': 1,
            'linkable': 1,
            'blankendmotherlist': 1,
            'tableable': 1,
            'barinsidequote': 1,
            'keepquoteindent': 1,
            'blankendtable': 1,
            'tablecellstrip': 1,
            'imgalignable': 1,
            'tablecellaligntype': 'cell',
            'listlineafteropen': 1,
            'labelbeforelink': 1,
            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            'blanksaroundquote': 1,
            'blanksaroundlist': 1,
            'blanksaroundnumlist': 1,
            'blanksarounddeflist': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
        },
        'rtf': {
            'linkable': 1,
            'tableable': 1,
            'autonumbertitle': 1,
            'parainsidelist': 1,
            'listnotnested': 1,
            'listitemnotnested': 1,
            'quotenotnested': 1,
            'onelinepara': 1,
            'tablecellstrip': 1,
            'tablecellspannable': 1,
            'tagnotindentable': 1,
            'deflisttextstrip': 1,
            'encodeblockdepth': 1,
            'zerodepthparagraph': 1,
            'cellspancumulative': 1,
            'blockdepthmultiply': 360,
            'depthmultiplyplus': 1,
            'cellspanmultiplier': 1080,
            'listmaxdepth': 9,
            'tablecellaligntype': 'cell',
        },
        'tml': {
            'escapexmlchars': 1,
            'linkable': 1,
            'tableable': 1,
            'tablecellstrip': 1,
            'tablecellspannable': 1,
            'spacedlistitem': 1,
            'autonumberlist': 1,
            'notbreaklistopen': 1,
            'imgalignable': 1,
            'imglinkable': 1,
            'tablecellaligntype': 'cell',
            'blanksaroundpara': 1,
            'blanksaroundverb': 1,
            'blanksaroundtable': 1,
            'blanksaroundbar': 1,
            'blanksaroundtitle': 1,
            'blanksaroundnumtitle': 1,
       },
        'mom': {
        'autonumberlist': 1,         # target supports numbered lists natively
        'autonumbertitle': 1,        # target supports numbered titles natively
        'imgalignable': 1,           # target supports image alignment
#        'stylable': 1,               # target supports external style files
        'parainsidelist': 1,         # lists items supports paragraph
        'spacedlistitem': 1,         # lists support blank lines between items
        'labelbeforelink': 1,        # label comes before the link on the tag
        'barinsidequote': 1,         # bars are allowed inside quote blocks
        'quotenotnested': 1,         # quotes cannot be nested
        'autotocnewpagebefore': 1,   # break page before automatic TOC
        'autotocnewpageafter': 1,    # break page after automatic TOC
        'mapbar2pagebreak': 1,       # map the strong bar to a page break
        'tableable': 1,              # target supports tables
        'tablecellaligntype': 'column',
        'tabletitlerowinbold': 1,
        'tablecellstrip': 1,
        'blanksaroundlist': 1,       # put a blank line before and after lists
#        'blanksaroundnumlist': 1,    # put a blank line before and after numlists
#        'blanksarounddeflist': 1,    # put a blank line before and after deflists
#        'blanksaroundnestedlist': 1, # put a blank line before and after all type of nested lists
#        'blanksaroundquote',      # put a blank line before and after quotes
        'blanksaroundtable': 1,      # put a blank line before and after tables
        'blankendautotoc': 1,        # append a blank line at the auto TOC end
        'tagnotindentable': 1,       # tags must be placed at the line beginning
        },
    }
    for target in TARGETS_LIST:
        if getattr(getattr(targets, target), 'RULES', {}).get('confdependentrules'):
            reload(getattr(targets, target))
        rules_bank[target] = getattr(getattr(targets, target), 'RULES', {})

    # Exceptions for --css-sugar
    if (config['css-sugar'] and config['target'] in ('html', 'xhtml', 'xhtmls', 'html5')) or config['target'] == 'wp':
        rules_bank['html']['indentverbblock'] = 0
        rules_bank['html']['autotocwithbars'] = 0
    # Get the target specific rules
    if config['target'] in ('xhtml', 'xhtmls', 'html5', 'htmls', 'wp'):
        myrules = rules_bank['html'].copy()   # inheritance
        myrules.update(rules_bank[config['target']])   # get specific
    elif config['target'] == 'aat':
        myrules = rules_bank['txt'].copy()    # inheritance
        myrules['tableable'] = 1
        if config['slides']:
            myrules['blanksaroundtitle'] = 0
            myrules['blanksaroundnumtitle'] = 0
            myrules['blanksaroundlist'] = 0
            myrules['blanksaroundnumlist'] = 0
            myrules['blanksarounddeflist'] = 0
        if config['web']:
            myrules['linkable'] = 1
            myrules['imglinkable'] = 1
            myrules['escapexmlchars'] = 1
        if config['spread']:
            myrules['tableonly'] = 1
            myrules['spread'] = 1
            myrules['spreadgrid'] = 1,
            myrules['spreadmarkup'] = 'txt'
            if config['web']:
                myrules['spreadmarkup'] = 'html'
    elif config['target'] == 'texs':
        myrules = rules_bank['tex'].copy()    # inheritance
        myrules.update(rules_bank[config['target']])   # get specific
    elif config['target'] == 'csvs':
        myrules = rules_bank['csv'].copy()    # inheritance
        myrules.update(rules_bank[config['target']])   # get specific
    else:
        myrules = rules_bank[config['target']].copy()

    # Populate return dictionary
    for key in allrules:
        ret[key] = 0                         # reset all
    ret.update(myrules)                      # get rules

    if ret['iswrapped'] and not config['width']:
        config['width'] = DFT_TEXT_WIDTH

    return ret


##############################################################################

def getRegexes():
    "Returns all the regexes used to find the t2t marks"

    bank = {
    'blockVerbOpen':
        re.compile(r'^```\s*$'),
    'blockVerbClose':
        re.compile(r'^```\s*$'),
    'blockRawOpen':
        re.compile(r'^"""\s*$'),
    'blockRawClose':
        re.compile(r'^"""\s*$'),
    'blockTaggedOpen':
        re.compile(r"^'''\s*$"),
    'blockTaggedClose':
        re.compile(r"^'''\s*$"),
    'blockCommentOpen':
        re.compile(r'^%%%\s*$'),
    'blockCommentClose':
        re.compile(r'^%%%\s*$'),
    'quote':
        re.compile(r'^\t+'),
    '1lineVerb':
        re.compile(r'^``` (?=.)'),
    '1lineRaw':
        re.compile(r'^""" (?=.)'),
    '1lineTagged':
        re.compile(r"^''' (?=.)"),
    # mono, raw, bold, italic, underline:
    # - marks must be glued with the contents, no boundary spaces
    # - they are greedy, so in ****bold****, turns to <b>**bold**</b>
    'fontMono':
        re.compile(r'``([^\s](|.*?[^\s])`*)``'),
    'raw':
        re.compile(r'""([^\s](|.*?[^\s])"*)""'),
    'tagged':
        re.compile(r"''([^\s](|.*?[^\s])'*)''"),
    'fontBold':
        re.compile(r'\*\*([^\s](|.*?[^\s])\**)\*\*'),
    'fontItalic':
        re.compile(r'//([^\s](|.*?[^\s])/*)//'),
    'fontUnderline':
        re.compile(r'__([^\s](|.*?[^\s])_*)__'),
    'fontStrike':
        re.compile(r'--([^\s](|.*?[^\s])-*)--'),
    'list':
        re.compile(r'^( *)(-) (?=[^ ])'),
    'numlist':
        re.compile(r'^( *)(\+) (?=[^ ])'),
    'deflist':
        re.compile(r'^( *)(:) (.*)$'),
    'listclose':
        re.compile(r'^( *)([-+:])\s*$'),
    'bar':
        re.compile(r'^(\s*)([_=-]{20,})\s*$'),
    'table':
        re.compile(r'^ *\|([|_/]){0,2} '),
    'blankline':
        re.compile(r'^\s*$'),
    'comment':
        re.compile(r'^%'),

    # Auxiliary tag regexes
    '_imgAlign'          : re.compile(r'~A~', re.I),
    '_tableAlign'        : re.compile(r'~A~', re.I),
    '_anchor'            : re.compile(r'~A~', re.I),
    '_tableBorder'       : re.compile(r'~B~', re.I),
    '_tableSortable'     : re.compile(r'~S~', re.I),
    '_tableColAlign'     : re.compile(r'~C~', re.I),
    '_tableCellColSpan'  : re.compile(r'~S~', re.I),
    '_tableCellAlign'    : re.compile(r'~A~', re.I),
    '_tableAttrDelimiter': re.compile(r'~Z~', re.I),
    '_blockDepth'        : re.compile(r'~D~', re.I),
    '_listLevel'         : re.compile(r'~L~', re.I),
    }

    # Special char to place data on TAGs contents  (\a == bell)
    bank['x'] = re.compile('\a')

    # %%macroname [ (formatting) ]
    bank['macros'] = re.compile(r'%%%%(?P<name>%s)\b(\((?P<fmt>.*?)\))?' % (
        '|'.join(MACROS.keys())), re.I)

    # %%TOC special macro for TOC positioning
    bank['toc'] = re.compile(r'^ *%%toc\s*$', re.I)

    # Almost complicated title regexes ;)
    titskel = r'^ *(?P<id>%s)(?P<txt>%s)\1(\[(?P<label>[\w-]*)\])?\s*$'
    bank['title']    = re.compile(titskel % ('[=]{1,5}', '[^=](|.*[^=])'))
    bank['numtitle'] = re.compile(titskel % ('[+]{1,5}', '[^+](|.*[^+])'))

    ### Complicated regexes begin here ;)
    #
    # Textual descriptions on --help's style: [...] is optional, | is OR

    ### First, some auxiliary variables
    #

    # [image.EXT]
    patt_img = r'\[([\w_,.+%$#@!?+~/-]+\.(png|jpe?g|gif|eps|bmp|svg))\]'

    # Link things
    # http://www.gbiv.com/protocols/uri/rfc/rfc3986.html
    # pchar: A-Za-z._~- / %FF / !$&'()*+,;= / :@
    # Recomended order: scheme://user:pass@domain/path?query=foo#anchor
    # Also works      : scheme://user:pass@domain/path#anchor?query=foo
    # TODO form: !'():
    urlskel = {
        'proto' : r'(https?|ftp|news|telnet|gopher|wais)://',
        'guess' : r'(www[23]?|ftp)\.',         # w/out proto, try to guess
        'login' : r'A-Za-z0-9_.-',             # for ftp://login@domain.com
        'pass'  : r'[^ @]*',                   # for ftp://login:pass@dom.com
        'chars' : r'A-Za-z0-9%._/~:,=$@&+-',   # %20(space), :80(port), D&D
        'anchor': r'A-Za-z0-9%._-',            # %nn(encoded)
        'form'  : r'A-Za-z0-9/%&=+:;.,$@*_-',  # .,@*_-(as is)
        'punct' : r'.,;:!?'
    }

    # username [ :password ] @
    patt_url_login = r'([%s]+(:%s)?@)?' % (urlskel['login'], urlskel['pass'])

    # [ http:// ] [ username:password@ ] domain.com [ / ]
    #     [ #anchor | ?form=data ]
    retxt_url = r'\b(%s%s|%s)[%s]+\b/*(\?[%s]+)?(#[%s]*)?' % (
        urlskel['proto'], patt_url_login, urlskel['guess'],
        urlskel['chars'], urlskel['form'], urlskel['anchor'])

    # filename | [ filename ] #anchor
    retxt_url_local = r'[%s]+|[%s]*(#[%s]*)' % (
        urlskel['chars'], urlskel['chars'], urlskel['anchor'])

    # user@domain [ ?form=data ]
    patt_email = r'\b[%s]+@([A-Za-z0-9_-]+\.)+[A-Za-z]{2,4}\b(\?[%s]+)?' % (
        urlskel['login'], urlskel['form'])

    # Saving for future use
    bank['_urlskel'] = urlskel

    ### And now the real regexes
    #

    bank['email'] = re.compile(patt_email, re.I)

    # email | url
    bank['link'] = re.compile(r'%s|%s' % (retxt_url, patt_email), re.I)

    # \[ label | imagetag    url | email | filename \]
    bank['linkmark'] = re.compile(
        r'\[(?P<label>%s|[^]]+) (?P<link>%s|%s|%s)\]' % (
            patt_img, retxt_url, patt_email, retxt_url_local),
        re.L + re.I)

    # Image
    bank['img'] = re.compile(patt_img, re.L + re.I)

    # Special things
    bank['special'] = re.compile(r'^%!\s*')
    return bank
### END OF regex nightmares

# The ASCII Art library

def aa_line(char, width):
    return char * width


def aa_under(txt, char, width, over):
    ret = []
    if over:
        ret.append(aa_line(char, aa_lencjk(txt)))
    for lin in textwrap.wrap(txt, width):
        ret.extend([lin, aa_line(char, aa_lencjk(lin))])
    return ret


def aa_box(txt, chars, width, centred=True, web=False, slides=False):
    wrap_txt = []
    char_side = ''
    if slides:
        width = width - 2
        char_side = ' '
    for lin in txt:
        wrap_txt.extend(aa_wrap(lin, width - 4, web))
    len_cjk = max([aa_lencjk(lin, web) for lin in wrap_txt])
    tline_box = char_side + aa_center(chars['tlcorner'] + chars['border'] * (len_cjk + 2) + chars['trcorner'], width) + char_side
    bline_box = char_side + aa_center(chars['blcorner'] + chars['border'] * (len_cjk + 2) + chars['brcorner'], width) + char_side
    line_txt = []
    for lin in wrap_txt:
        if centred:
            line_txt.append(char_side + aa_center(chars['side'] + ' ' + aa_center(lin, len_cjk, web) + ' ' + chars['side'], width, web) + char_side)
        else:
            line_txt.append(char_side + aa_center(chars['side'] + ' ' + lin + ' ' * (len_cjk - aa_lencjk(lin, web) + 1) + chars['side'], width, web) + char_side)
    return [tline_box] + line_txt + [bline_box]


def aa_header(header_data, chars, width, height, web, slides):
    h = [header_data[v] for v in header_data if v.startswith("HEADER") and header_data[v]]
    n_h = len(h)
    height_box = sum([len(aa_box([header], chars, width, slides=slides)) for header in h])
    if not n_h:
        return []
    if not slides:
        n, end = 2, 0
    else:
        x = height - 3 - height_box
        n = x / (n_h + 1)
        end = x % (n_h + 1)
    header = [aa_line(chars['bar2'], width)]
    header.extend([''] * n)
    for h in 'HEADER1', 'HEADER2', 'HEADER3':
        if header_data[h]:
            header.extend(aa_box([header_data[h]], chars, width, slides=slides))
            header.extend([''] * n)
    header.extend([''] * end)
    header.append(aa_line(chars['bar2'], width))
    if web and slides:
        header = ['<section><pre>' + header[0]] + header[1:-1] + [header[-1] + '</pre></section>']
    if not slides:
        header = [''] + header
    return header


def aa_slide(title, char, width, web):
    res = [aa_line(char, width)]
    res.append('')
    res.append(aa_center(title, width)[:width])
    res.append('')
    res.append(aa_line(char, width))
    if web:
        res = ['<section><pre>' + res[0]] + res[1:]
    return res


def aa_table(data, chars, width, borders, h_header, v_header, align, spread, web):
    n = max([len(lin[0]) for lin in data])
    data3 = []
    for lin in data:
        if  max(lin[1]) == 1:
            data3.append(lin[0])
        else:
            newline = []
            for i, el in enumerate(lin[0]):
                if lin[1][i] == 1:
                    newline.append(el)
                else:
                    newline.extend(lin[1][i] * [''])
            data3.append(newline)
    tab = []
    for i in range(n):
        tab.append([lin[i] for lin in data3])
    if web:
        length = [max([aa_lencjk(re.sub('<a.*">|</a>', '', el)) for el in lin]) for lin in tab]
    else:
        length = [max([aa_lencjk(el) for el in lin]) for lin in tab]
    if spread:
        data[0][0] = [data[0][0][i].center(length[i]) for i in range(n)]
    tcross, border, bcross, lcross, side, rcross, tlcorner, trcorner, cross, blcorner, brcorner, tvhead, vhead, vheadcross, bvhead ,headerscross, hhead, hheadcross, lhhead, rhhead= chars['tcross'], chars['border'], chars['bcross'], chars['lcross'], chars['side'], chars['rcross'], chars['tlcorner'], chars['trcorner'], chars['cross'], chars['blcorner'], chars['brcorner'], chars['tvhead'], chars['vhead'], chars['vheadcross'], chars['bvhead'], chars['headerscross'], chars['hhead'], chars['hheadcross'], chars['lhhead'], chars['rhhead']
    if not v_header:
        tvhead, bvhead = tcross, bcross
        if borders:
            vheadcross = cross
            if h_header:
                headerscross = hheadcross
    if not borders:
        hhead, hheadcross, lhhead, rhhead, headerscross = border, cross, lcross, rcross, vheadcross
        if h_header and not v_header:
                headerscross = cross
    if v_header and not h_header:
        headerscross = vheadcross

    len0 = length[0] + 2
    res = lcross + len0 * border + vheadcross
    resh = lhhead + len0 * hhead + headerscross
    rest = tlcorner + len0 * border + tvhead
    resb = blcorner + len0 * border + bvhead
    for i in range(1, n):
        res = res + (length[i] + 2) * border + cross
        resh = resh + (length[i] + 2) * hhead + hheadcross
        rest = rest + (length[i] + 2) * border + tcross
        resb = resb + (length[i] + 2) * border + bcross
    res = res[:-1] + rcross
    resh = resh[:-1] + rhhead
    rest = rest[:-1] + trcorner
    resb = resb[:-1] + brcorner
    ret = []
    for i, lin in enumerate(data):
        aff = side
        if i == 1 and h_header:
            ret.append(resh)
        elif i == 0:
            ret.append(rest)
        elif borders:
            ret.append(res)
        for j, el in enumerate(lin[0]):
            if web:
                aff = aff + " " + el + (sum(length[j:(j + lin[1][j])]) + lin[1][j] * 3 - aa_lencjk(re.sub('<a.*">|</a>', '',el)) - 2) * " " + side
            else:
                aff = aff + " " + el + (sum(length[j:(j + lin[1][j])]) + lin[1][j] * 3 - aa_lencjk(el) - 2) * " " + side
            if j == 0 and v_header:
                aff = aff[:-1] + vhead
        ret.append(aff)
    ret.append(resb)
    if align == 'Left':
        ret = [' ' * 2  + lin for lin in ret]
    elif align == 'Center' and not (web and spread):
        ret = [aa_center(lin, width) for lin in ret]
    return ret


def aa_image(image):
    art_table = '#$!;:,. '
    art_image = []
    for lin in image:
        art_line = ''
        for pixel in lin:
            art_line = art_line + art_table[pixel/32]
        art_image.append(art_line)
    return art_image


def aa_wrap(txt, width, web):
    if not web:
        return textwrap.wrap(txt, width)
    txt = re.split('(<a href=.*?>)|(</a>)|(<img src=.*?>)', txt)
    lin, length, ret = '', 0, []
    for el in txt:
        if el:
            if el[0] != '<':
                if len(el) > width:
                    lin = lin + el
                    multi = textwrap.wrap(lin, width)
                    ret.extend(multi[:-1])
                    lin = multi[-1]
                elif length + len(el) <= width:
                    length = length + len(el)
                    lin = lin + el
                else:
                    ret.append(lin)
                    lin, length = el, len(el)
            else:
                    lin = lin + el
    ret.append(lin)
    return ret


def aa_lencjk(txt, web=False):
    if web:
        txt = re.sub('(<a href=.*?>)|(</a>)|(<img src=.*?>)', '', txt)
    if isinstance(txt, str):
        return len(txt)
    l = 0
    for char in txt:
        if unicodedata.east_asian_width(unicode(char)) in ('F', 'W'):
            l = l + 2
        else:
            l = l + 1
    return l


def aa_center(txt, width, web=False):
    n_before = (width - aa_lencjk(txt, web)) / 2
    n_after = width - aa_lencjk(txt, web) - n_before
    return ' ' * n_before + txt + ' ' * n_after


# The Spreadsheet library

ascii_uppercase = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'

class SpreadSheet:
    """Raymond Hettinger's recipe
    http://code.activestate.com/recipes/355045-spreadsheet
    """
    _cells = {}
    def __setitem__(self, key, formula):
        self._cells[key] = formula
    def getformula(self, key):
        return self._cells[key]
    def __getitem__(self, key):
        if self._cells[key].strip()[0] == '=':
            try:
                return eval(self._cells[key].strip()[1:], globals(), self)
            except Exception, e:
                return e
        else:
            return self._cells[key].strip()


def spreadsheet(data, markup, grid):
    n = max([len(line[0]) for line in data])
    if n > 676:
        Error("Spreadsheet tables are limited to 676 columns, and your table has %i columns." % n)
    s = SpreadSheet()
    for j, row in enumerate(data):
        for i, el in enumerate(row[0]):
            ind = ascii_uppercase[i/26 - 1].replace('Z', '') + ascii_uppercase[i%26] + str(j+1)
            if el and el.strip():
                s[ind] = el
    for j, row in enumerate(data):
        for i, el in enumerate(row[0]):
            ind = ascii_uppercase[i/26 - 1].replace('Z', '') + ascii_uppercase[i%26] + str(j+1)
            if el and el.strip():
                if markup == 'html':
                    row[0][i] = '<a title="' + el.strip() + '">' + str(s[ind]) + '</a>'
                elif markup == 'tex':
                    if el.strip()[0] == '=':
                        tooltip = 'formula: '
                    else:
                        tooltip = 'value: '
                    row[0][i] = '\htmladdnormallink{' + str(s[ind]) + '}{' + tooltip + el.strip() + '}'
                elif markup == 'txt':
                    row[0][i] = str(s[ind])
    if grid:
        h = [(ascii_uppercase[i/26 - 1].replace('Z', '') + ascii_uppercase[i%26]) for i in range(n)]
        data = [[h, [1] * n]] + data
        data = [[[str(i)] + line[0], [1] + line[1]] for i, line in enumerate(data)]
        data[0][0][0] = ''
    return data


def completes_table(table):
    data = [[row['cells'], row['cellspan']] for row in table]
    n = max([len(line[0]) for line in data])
    data2 = []
    for line in data:
        if not line[1]:
            data2.append([n * [''], n * [1]])
        else:
            data2.append([line[0] + (n - sum(line[1])) * [''], line[1] + (n - sum(line[1])) * [1]])
    return data2


def convert_to_table(itera, headers, borders, center):
    if center:
        row_ini = ' | '
    else:
        row_ini = '| '
    if borders:
        row_end = ' |'
    else:
        row_end = ''
    table = []
    for row in itera:
        table.append(row_ini + ' | '.join(row).expandtabs() + row_end)
    if headers:
        table[0] = table[0].replace('|', '||', 1)
    return table


def parse_convert_table(table, tableable, target):
    ret = []
    # Note: cell contents is raw, no t2t marks are parsed
    if tableable:
        ret.extend(BLOCK.blockin('table'))
        if table:
            BLOCK.tableparser.__init__(table[0])
            for row in table:
                tablerow = TableMaster().parse_row(row)
                BLOCK.tableparser.add_row(tablerow)

                # Very ugly, but necessary for escapes
                line = SEPARATOR.join(tablerow['cells'])
                BLOCK.holdadd(doEscape(target, line))
            ret.extend(BLOCK.blockout())

    # Tables are mapped to verb when target is not table-aware
    else:
        ret.extend(BLOCK.blockin('verb'))
        BLOCK.propset('mapped', 'table')
        for row in table:
            BLOCK.holdadd(row)
        ret.extend(BLOCK.blockout())
    return ret


##############################################################################


class error(Exception):
    pass


def echo(msg):   # for quick debug
    print '\033[32;1m%s\033[m' % msg


def Quit(msg=''):
    if msg:
        print msg
    sys.exit(0)


def Error(msg):
    msg = _("%s: Error: ") % my_name + msg
    raise error(msg)


def getTraceback():
    try:
        from traceback import format_exception
        etype, value, tb = sys.exc_info()
        return ''.join(format_exception(etype, value, tb))
    except:
        pass


def getUnknownErrorMessage():
    msg = '%s\n%s (%s):\n\n%s' % (
        _('Sorry! Txt2tags aborted by an unknown error.'),
        _('Please send the following Error Traceback to the author'),
        my_email, getTraceback())
    return msg


def Message(msg, level):
    if level <= VERBOSE and not QUIET:
        prefix = '-' * 5
        print "%s %s" % (prefix * level, msg)


def Debug(msg, id_=0, linenr=None):
    "Show debug messages, categorized (colored or not)"
    if QUIET or not DEBUG:
        return
    if int(id_) not in range(8):
        id_ = 0
    # 0:black 1:red 2:green 3:yellow 4:blue 5:pink 6:cyan 7:white ;1:light
    ids            = ['INI', 'CFG', 'SRC', 'BLK', 'HLD', 'GUI', 'OUT', 'DET']
    colors_bgdark  = ['7;1', '1;1', '3;1', '6;1', '4;1', '5;1', '2;1', '7;1']
    colors_bglight = ['0'  , '1'  , '3'  , '6'  , '4'  , '5'  , '2'  , '0'  ]
    if linenr is not None:
        msg = "LINE %04d: %s" % (linenr, msg)
    if COLOR_DEBUG:
        if BG_LIGHT:
            color = colors_bglight[id_]
        else:
            color = colors_bgdark[id_]
        msg = '\033[3%sm%s\033[m' % (color, msg)
    print "++ %s: %s" % (ids[id_], msg)


def Readfile(file_path, remove_linebreaks=0, ignore_error=0):
    data = []

    # STDIN
    if file_path == '-':
        try:
            data = sys.stdin.readlines()
        except:
            if not ignore_error:
                Error(_('You must feed me with data on STDIN!'))

    # URL
    elif PathMaster().is_url(file_path):
        try:
            from urllib import urlopen
            f = urlopen(file_path)
            if f.getcode() == 404:  # URL not found
                raise
            data = f.readlines()
            f.close()
        except:
            if not ignore_error:
                Error(_("Cannot read file:") + ' ' + file_path)

    # local file
    else:
        try:
            f = open(file_path)
            data = f.readlines()
            f.close()
        except:
            if not ignore_error:
                Error(_("Cannot read file:") + ' ' + file_path)

    if remove_linebreaks:
        data = map(lambda x: re.sub('[\n\r]+$', '', x), data)

    Message(_("File read (%d lines): %s") % (len(data), file_path), 2)
    return data


def Savefile(file_path, contents):
    try:
        f = open(file_path, 'wb')
    except:
        Error(_("Cannot open file for writing:") + ' ' + file_path)
    if type(contents) == type([]):
        doit = f.writelines
    else:
        doit = f.write
    cont = []
    if CONF['encoding'].lower() == 'utf-8' and CONF['target'] != 'mgp':
        for line in contents:
            if isinstance(line, unicode):
                cont.append(line.encode('utf-8'))
            else:
                cont.append(line)
    elif CONF['target'] == 'mgp':
        for line in contents:
            if isinstance(line, unicode):
                cont.append(line.encode('latin1', 'replace'))
            else:
                cont.append(line)
    else:
        cont = contents
    doit(cont)
    f.close()


def showdic(dic):
    for k in dic.keys():
        print "%15s : %s" % (k, dic[k])


def dotted_spaces(txt=''):
    return txt.replace(' ', '.')


# TIP: win env vars http://www.winnetmag.com/Article/ArticleID/23873/23873.html
def get_rc_path():
    "Return the full path for the users' RC file"
    # Try to get the path from an env var. if yes, we're done
    user_defined = os.environ.get('T2TCONFIG')
    if user_defined:
        return user_defined
    # Env var not found, so perform automatic path composing
    # Set default filename according system platform
    rc_names = {'default': '.txt2tagsrc', 'win': '_t2trc'}
    rc_file = rc_names.get(sys.platform[:3]) or rc_names['default']
    # The file must be on the user directory, but where is this dir?
    rc_dir_search = ['HOME', 'HOMEPATH']
    for var in rc_dir_search:
        rc_dir = os.environ.get(var)
        if rc_dir:
            break
    # rc dir found, now we must join dir+file to compose the full path
    if rc_dir:
        # Compose path and return it if the file exists
        rc_path = os.path.join(rc_dir, rc_file)
        # On windows, prefix with the drive (%homedrive%: 2k/XP/NT)
        if sys.platform.startswith('win'):
            rc_drive = os.environ.get('HOMEDRIVE')
            rc_path = os.path.join(rc_drive, rc_path)
        return rc_path
    # Sorry, not found
    return ''


##############################################################################

class PathMaster:
    """Handle paths. See issues: 27, 62, 63, 71, 85."""

    def __init__(self):
        pass

    def is_url(self, text):
        return text.startswith('http://') or text.startswith('https://')

    def join(self, dirname, filename):
        """Join paths, unless filename is STDOUT, absolute or URL."""

        if not dirname \
            or not filename \
            or filename in (STDOUT, MODULEOUT) \
            or os.path.isabs(filename) \
            or self.is_url(filename):
            return filename
        else:
            return os.path.join(dirname, filename)

    def relpath(self, path, start):
        """Unlike os.path.relpath(), never touch URLs"""
        if not path or self.is_url(path):
            return path
        else:
            return os.path.relpath(path, start)


class CommandLine:
    """
    Command Line class - Masters command line

    This class checks and extract data from the provided command line.
    The --long options and flags are taken from the global OPTIONS,
    FLAGS and ACTIONS dictionaries. The short options are registered
    here, and also their equivalence to the long ones.

    _compose_short_opts() -> str
    _compose_long_opts() -> list
        Compose the valid short and long options list, on the
        'getopt' format.

    parse() -> (opts, args)
        Call getopt to check and parse the command line.
        It expects to receive the command line as a list, and
        without the program name (sys.argv[1:]).

    get_raw_config() -> [RAW config]
        Scans command line and convert the data to the RAW config
        format. See ConfigMaster class to the RAW format description.
        Optional 'ignore' and 'filter_' arguments are used to filter
        in or out specified keys.

    compose_cmdline(dict) -> [Command line]
        Compose a command line list from an already parsed config
        dictionary, generated from RAW by ConfigMaster(). Use
        this to compose an optimal command line for a group of
        options.

    The get_raw_config() calls parse(), so the typical use of this
    class is:

        raw = CommandLine().get_raw_config(sys.argv[1:])
    """
    def __init__(self):
        self.all_options = OPTIONS.keys()
        self.all_flags   = FLAGS.keys()
        self.all_actions = ACTIONS.keys()

        # short:long options equivalence
        self.short_long = {
            'C': 'config-file',
            'h': 'help',
            'H': 'no-headers',
            'i': 'infile',
            'n': 'enum-title',
            'o': 'outfile',
            'q': 'quiet',
            't': 'target',
            'T': 'template',
            'v': 'verbose',
            'V': 'version',
        }

        # Compose valid short and long options data for getopt
        self.short_opts = self._compose_short_opts()
        self.long_opts  = self._compose_long_opts()

    def _compose_short_opts(self):
        "Returns a string like 'hVt:o' with all short options/flags"
        ret = []
        for opt in self.short_long.keys():
            long_ = self.short_long[opt]
            if long_ in self.all_options:   # is flag or option?
                opt = opt + ':'             # option: have param
            ret.append(opt)
        #Debug('Valid SHORT options: %s' % ret)
        return ''.join(ret)

    def _compose_long_opts(self, extra=True):
        "Returns a list with all the valid long options/flags"
        ret = map(lambda x: x + '=', self.all_options)        # add =
        ret.extend(self.all_flags)                            # flag ON
        ret.extend(self.all_actions)                          # actions
        ret.extend(map(lambda x: 'no-' + x, self.all_flags))  # add no-*
        if extra:
            ret.extend(['no-style', 'no-encoding'])           # turn OFF
            ret.extend(['no-outfile', 'no-infile'])           # turn OFF
            ret.extend(['no-dump-config', 'no-dump-source'])  # turn OFF
            ret.extend(['no-targets'])                        # turn OFF
        #Debug('Valid LONG options: %s' % ret)
        return ret

    def tokenize(self, cmdline=''):
        "Convert a command line string to a list"
        return shlex.split(cmdline)

    def parse(self, cmdline=[]):
        "Check/Parse a command line list     TIP: no program name!"
        # Get the valid options
        short, long_ = self.short_opts, self.long_opts
        # Parse it!
        try:
            opts, args = getopt.getopt(cmdline, short, long_)
        except getopt.error, errmsg:
            Error(_("%s (try --help)") % errmsg)
        return (opts, args)

    def get_raw_config(self, cmdline=[], ignore=[], filter_=[], relative=0):
        "Returns the options/arguments found as RAW config"

        if not cmdline:
            return []
        ret = []

        # We need lists, not strings (such as from %!options)
        if type(cmdline) in (type(''), type(u'')):
            if isinstance(cmdline, unicode):
                cmdline = cmdline.encode('utf-8')
            cmdline = self.tokenize(cmdline)

        # Extract name/value pair of all configs, check for invalid names
        options, arguments = self.parse(cmdline[:])

        # Needed when expanding %!options inside remote %!includeconf
        dirname = ''

        # Some cleanup on the raw config
        for name, value in options:

            # Remove leading - and --
            name = re.sub('^--?', '', name)

            # Fix old misspelled --suGGar, --no-suGGar
            name = name.replace('suggar', 'sugar')

            # Translate short option to long
            if len(name) == 1:
                name = self.short_long[name]

            if name == 'dirname':
                dirname = value
                continue

            # Outfile exception: path relative to PWD
            if name == 'outfile' and value not in [STDOUT, MODULEOUT]:
                if relative:
                    value = os.path.abspath(value)
                else:
                    value = PathMaster().join(dirname, value)

            # -C, --config-file inclusion, path relative to PWD
            if name == 'config-file':
                value = PathMaster().join(dirname, value)
                ret.extend(ConfigLines().include_config_file(value))
                continue

            # --style: path relative to PWD
            # Already OK, when comming from the command line
            # Needs fix when coming from %!options: --style foo.css
            if name == 'style':
                ret.append(['all', 'stylepath', PathMaster().join(dirname, value)])

            # Save this config
            ret.append(['all', name, value])

        # All configuration was read and saved

        # Get infile, if any
        while arguments:
            infile = arguments.pop(0)
            ret.append(['all', 'infile', infile])

        # Apply 'ignore' and 'filter_' rules (filter_ is stronger)
        if (ignore or filter_):
            filtered = []
            for target, name, value in ret:
                if (filter_ and name in filter_) or \
                   (ignore and name not in ignore):
                    filtered.append([target, name, value])
                else:
                    fancykey = dotted_spaces("%12s" % name)
                    Message(_("Ignored config") + (" %s : %s" % (fancykey, value)), 3)
            ret = filtered[:]

        # Add the original command line string as 'realcmdline'
        ret.append(['all', 'realcmdline', cmdline])

        return ret

    def compose_cmdline(self, conf={}, no_check=0):
        "compose a full (and diet) command line from CONF dict"
        if not conf:
            return []
        args = []
        dft_options = OPTIONS.copy()
        cfg = conf.copy()
        valid_opts = self.all_options + self.all_flags
        use_short = {'no-headers': 'H', 'enum-title': 'n'}
        # Remove useless options
        if not no_check and cfg.get('toc-only'):
            if 'no-headers' in cfg:
                del cfg['no-headers']
            if 'outfile' in cfg:
                del cfg['outfile']      # defaults to STDOUT
            if cfg.get('target') == 'txt':
                del cfg['target']       # already default
            args.append('--toc-only')  # must be the first
            del cfg['toc-only']
        # Add target type
        if 'target' in cfg:
            args.append('-t ' + cfg['target'])
            del cfg['target']
        # Add other options
        for key in cfg.keys():
            if key not in valid_opts:
                continue  # may be a %!setting
            if key == 'outfile' or key == 'infile':
                continue  # later
            val = cfg[key]
            if not val:
                continue
            # Default values are useless on cmdline
            if val == dft_options.get(key):
                continue
            # -short format
            if key in use_short:
                args.append('-' + use_short[key])
                continue
            # --long format
            if key in self.all_flags:   # add --option
                args.append('--' + key)
            else:                       # add --option=value
                args.append('--%s=%s' % (key, val))
        # The outfile using -o
        if 'outfile' in cfg and \
           cfg['outfile'] != dft_options.get('outfile'):
            args.append('-o ' + cfg['outfile'])
        # Place input file(s) always at the end
        if 'infile' in cfg:
            args.append(' '.join(cfg['infile']))
        # Return as a nice list
        Debug("Diet command line: %s" % ' '.join(args), 1)
        return args


class BaseOptions(CommandLine):

    def __init__(self, cmdline=None, dft_options={}, dft_flags={}, short_long={}):

        # Available options
        self.dft_options = dft_options
        self.dft_flags = dft_flags
        self.short_long = short_long

        # Default values for all options
        self.defaults = {}
        self.defaults.update(self.dft_options)
        self.defaults.update(self.dft_flags)

        # Needed by self._compose_*_opts()
        self.all_flags = self.dft_flags.keys()
        self.all_options = self.dft_options.keys()
        self.all_actions = []

        # Compose valid short and long options data for getopt
        self.short_opts = self._compose_short_opts()
        self.long_opts = self._compose_long_opts(extra=False)

        # Got data? Parse it!
        if cmdline:
            self.raw = self.get_raw_config(cmdline)
            self.parsed = self.parse_raw()
        else:
            self.raw = []
            self.parsed = {}

    def get(self, key):
        return self.parsed.get(key, self.defaults[key])

    def parse(self, cmdline):
        try:
            opts, args = getopt.getopt(cmdline, self.short_opts, self.long_opts)
        except getopt.error, errmsg:
            Error(_("%s in %%!%s command") % (errmsg, self.__class__.__name__[:-7].upper()))
        return (opts, args)

    def parse_raw(self, raw=None):
        if not raw:
            raw = self.raw
        # Reset attributes to our modest needs
        cm = ConfigMaster(raw)
        cm.dft_options  = self.dft_options.copy()
        cm.dft_flags    = self.dft_flags.copy()
        cm.dft_actions  = {}
        cm.dft_settings = {}
        cm.incremental  = []
        cm.numeric      = []
        cm.multi        = []  # maybe in the future: ['infile']
        cm.defaults     = self.defaults.copy()
        cm.off          = cm._get_off()
        return cm.parse()


class CsvOptions(BaseOptions):
    """Tokenize and parse the %!CSV command arguments.
    
    When you find this line in the user document:
    
        %!CSV: -s tab foo.csv
    
    Just feed everything after the first : to this class,
    as a single string. It will be tokenized, parsed and
    saved to self.raw and self.parsed.
    
    Use the self.get() method to get the value of a config.
    If missing, the default value will be returned.
    
    Example:
        >>> import txt2tags, pprint
        >>> csvopt = txt2tags.CsvOptions('-s tab foo.csv')
        >>> pprint.pprint(csvopt.raw)
        [['all', 'separator', 'tab'],
         ['all', 'infile', 'foo.csv'],
         ['all', 'realcmdline', ['-s', 'tab', 'foo.csv']]]
        >>> pprint.pprint(csvopt.parsed)
        {'infile': 'foo.csv',
         'realcmdline': ['-s', 'tab', 'foo.csv'],
         'separator': 'tab'}
        >>> csvopt.get('separator')
        'tab'
        >>>
    """

    def __init__(self, cmdline=None):

        # Available options for %!CSV
        self.dft_options = {
            'separator': ',',
            'quotechar': '',
            'infile': '',
        }
        self.dft_flags = {
            'headers': 0,
            'borders': 0,
            'center': 0,
            'utf8': 0,
            'mailing': 0,
        }
        self.short_long = {
            'b': 'borders',
            'c': 'center',
            'h': 'headers',
            's': 'separator',
            'q': 'quotechar',
            'u': 'utf8',
            'm': 'mailing',
        }

        BaseOptions.__init__(self, cmdline, self.dft_options, self.dft_flags, self.short_long)


class DbOptions(BaseOptions):
    """Tokenize and parse the %!DB command arguments.
    
    When you find this line in the user document:
    
        %!DB: -q "select * from table" foo.db
    
    Just feed everything after the first : to this class,
    as a single string. It will be tokenized, parsed and
    saved to self.raw and self.parsed.
    
    Use the self.get() method to get the value of a config.
    If missing, the default value will be returned.
    
    Example:
        >>> import txt2tags, pprint
        >>> dbopt = txt2tags.DbOptions('-q "select * from table" foo.db')
        >>> pprint.pprint(dbopt.raw)
        [['all', 'query', 'select * from table'],
         ['all', 'infile', 'foo.db'],
         ['all', 'realcmdline', ['-q', 'select * from table', 'foo.db']]]
        >>> pprint.pprint(dbopt.parsed)
        {'infile': 'foo.db',
         'query': 'select * from table'}
        >>> dbopt.get('query')
        'select * from table'
        >>>
    """

    def __init__(self, cmdline=None):

        # Available options for %!DB
        self.dft_options = {
            'query': '',
            'infile': '',
        }
        self.dft_flags = {
            'borders': 0,
            'center': 0,
            'headers': 0,
            'mailing': 0,
        }
        self.short_long = {
            'b': 'borders',
            'c': 'center',
            'h': 'headers',
            'q': 'query',
            'm': 'mailing',
        }

        BaseOptions.__init__(self, cmdline, self.dft_options, self.dft_flags, self.short_long)


class FenOptions(BaseOptions):

    def __init__(self, cmdline=None):

        # Available options for %!FEN
        self.dft_options = {
            'infile': '',
        }
        self.dft_flags = {
            'unicode': 0,
        }
        self.short_long = {
            'u': 'unicode',
        }

        BaseOptions.__init__(self, cmdline, self.dft_options, self.dft_flags, self.short_long)


##############################################################################

class SourceDocument:
    """
    SourceDocument class - scan document structure, extract data

    It knows about full files. It reads a file and identify all
    the areas beginning (Head,Conf,Body). With this info it can
    extract each area contents.
    Note: the original line break is removed.

    DATA:
      self.arearef - Save Head, Conf, Body init line number
      self.areas   - Store the area names which are not empty
      self.buffer  - The full file contents (with NO \\r, \\n)

    METHODS:
      get()   - Access the contents of an Area. Example:
                config = SourceDocument(file).get('conf')

      split() - Get all the document Areas at once. Example:
                head, conf, body = SourceDocument(file).split()

    RULES:
        * The document parts are sequential: Head, Conf and Body.
        * One ends when the next begins.
        * The Conf Area is optional, so a document can have just
          Head and Body Areas.

        These are the Areas limits:
          - Head Area: the first three lines
          - Body Area: from the first valid text line to the end
          - Conf Area: the comments between Head and Body Areas

        Exception: If the first line is blank, this means no
        header info, so the Head Area is just the first line.
    """
    def __init__(self, filename='', contents=[]):
        self.areas = ['head', 'conf', 'body']
        self.arearef = []
        self.areas_fancy = ''
        self.filename = filename
        self.buffer = []
        if filename:
            self.scan_file(filename)
        elif contents:
            self.scan(contents)

    def split(self):
        "Returns all document parts, splitted into lists."
        return self.get('head'), self.get('conf'), self.get('body')

    def get(self, areaname):
        "Returns head|conf|body contents from self.buffer"
        # Sanity
        if areaname not in self.areas:
            return []
        if not self.buffer:
            return []
        # Go get it
        bufini = 1
        bufend = len(self.buffer)
        if   areaname == 'head':
            ini = bufini
            end = self.arearef[1] or self.arearef[2] or bufend
        elif areaname == 'conf':
            ini = self.arearef[1]
            end = self.arearef[2] or bufend
        elif areaname == 'body':
            ini = self.arearef[2]
            end = bufend
        else:
            Error("Unknown Area name '%s'" % areaname)
        lines = self.buffer[ini:end]
        # Make sure head will always have 3 lines
        while areaname == 'head' and len(lines) < 3:
            lines.append('')
        return lines

    def scan_file(self, filename):
        Debug("source file: %s" % filename)
        Message(_("Loading source document"), 1)
        buf = Readfile(filename, remove_linebreaks=1)
        self.scan(buf)

    def scan(self, lines):
        "Run through source file and identify head/conf/body areas"
        buf = lines
        if len(buf) == 0:
            Error(_('The input file is empty: %s') % self.filename)
        cfg_parser = ConfigLines().parse_line
        buf.insert(0, '')                         # text start at pos 1
        ref = [1, 4, 0]
        if not buf[1].strip():                    # no header
            ref[0] = 0
            ref[1] = 2
        rgx = getRegexes()
        on_comment_block = 0
        for i in xrange(ref[1], len(buf)):         # find body init:
            # Handle comment blocks inside config area
            if not on_comment_block \
               and rgx['blockCommentOpen'].search(buf[i]):
                on_comment_block = 1
                continue
            if on_comment_block \
               and rgx['blockCommentOpen'].search(buf[i]):
                on_comment_block = 0
                continue
            if on_comment_block:
                continue

            if buf[i].strip() and (            # ... not blank and
               buf[i][0] != '%' or             # ... not comment or
               rgx['macros'].match(buf[i]) or  # ... %%macro
               rgx['toc'].match(buf[i])    or  # ... %%toc
               cfg_parser(buf[i], 'include')[1] or  # ... %!include
               cfg_parser(buf[i], 'csv')[1] or # ... %!csv
               cfg_parser(buf[i], 'db')[1]  or # ... %!db
               cfg_parser(buf[i], 'fen')[1]    # ... %!fen
            ):
                ref[2] = i
                break
        if ref[1] == ref[2]:
            ref[1] = 0                          # no conf area
        for i in 0, 1, 2:                       # del !existent
            if ref[i] >= len(buf):
                ref[i] = 0                      # title-only
            if not ref[i]:
                self.areas[i] = ''
        Debug('Head,Conf,Body start line: %s' % ref)
        self.arearef = ref                      # save results
        self.buffer  = buf
        # Fancyness sample: head conf body (1 4 8)
        self.areas_fancy = "%s (%s)" % (
            ' '.join(self.areas),
            ' '.join(map(str, map(lambda x: x or '', ref))))
        Message(_("Areas found: %s") % self.areas_fancy, 2)

    def get_raw_config(self):
        "Handy method to get the CONF area RAW config (if any)"
        if not self.areas.count('conf'):
            return []
        Message(_("Scanning source document CONF area"), 1)
        raw = ConfigLines(
            file_=self.filename, lines=self.get('conf'),
            first_line=self.arearef[1]).get_raw_config()
        Debug("document raw config: %s" % raw, 1)
        return raw


##############################################################################

class ConfigMaster:
    """
    ConfigMaster class - the configuration wizard

    This class is the configuration master. It knows how to handle
    the RAW and PARSED config format. It also performs the sanity
    checking for a given configuration.

    DATA:
      self.raw         - Stores the config on the RAW format
      self.parsed      - Stores the config on the PARSED format
      self.defaults    - Stores the default values for all keys
      self.off         - Stores the OFF values for all keys
      self.multi       - List of keys which can have multiple values
      self.numeric     - List of keys which value must be a number
      self.incremental - List of keys which are incremental

    RAW FORMAT:
      The RAW format is a list of lists, being each mother list item
      a full configuration entry. Any entry is a 3 item list, on
      the following format: [ TARGET, KEY, VALUE ]
      Being a list, the order is preserved, so it's easy to use
      different kinds of configs, as CONF area and command line,
      respecting the precedence.
      The special target 'all' is used when no specific target was
      defined on the original config.

    PARSED FORMAT:
      The PARSED format is a dictionary, with all the 'key : value'
      found by reading the RAW config. The self.target contents
      matters, so this dictionary only contains the target's
      config. The configs of other targets are ignored.

    The CommandLine and ConfigLines classes have the get_raw_config()
    method to convert the configuration found to the RAW format.
    Just feed it to parse() and get a brand-new ready-to-use config
    dictionary. Example:

        >>> raw = CommandLine().get_raw_config(['-n', '-H'])
        >>> print raw
        [['all', 'enum-title', ''], ['all', 'no-headers', '']]
        >>> parsed = ConfigMaster(raw).parse()
        >>> print parsed
        {'enum-title': 1, 'headers': 0}
    """
    def __init__(self, raw=[], target=''):
        self.raw          = raw
        self.target       = target
        self.parsed       = {}
        self.dft_options  = OPTIONS.copy()
        self.dft_flags    = FLAGS.copy()
        self.dft_actions  = ACTIONS.copy()
        self.dft_settings = SETTINGS.copy()
        self.defaults     = self._get_defaults()
        self.off          = self._get_off()
        self.incremental  = ['verbose']
        self.numeric      = ['toc-level', 'split', 'width', 'height']
        self.multi        = ['infile', 'preproc', 'postproc', 'postvoodoo', 'options', 'style', 'stylepath']

    def _get_defaults(self):
        "Get the default values for all config/options/flags"
        empty = {}
        for kw in CONFIG_KEYWORDS:
            empty[kw] = ''
        empty.update(self.dft_options)
        empty.update(self.dft_flags)
        empty.update(self.dft_actions)
        empty.update(self.dft_settings)
        empty['realcmdline'] = ''  # internal use only
        empty['sourcefile']  = ''  # internal use only
        empty['currentsourcefile']  = ''  # internal use only
        return empty

    def _get_off(self):
        "Turns OFF all the config/options/flags"
        off = {}
        for key in self.defaults.keys():
            kind = type(self.defaults[key])
            if kind == type(9):
                off[key] = 0
            elif kind == type('') or kind == type(u''):
                off[key] = ''
            elif kind == type([]):
                off[key] = []
            else:
                Error('ConfigMaster: %s: Unknown type' % key)
        return off

    def _check_target(self):
        "Checks if the target is already defined. If not, do it"
        if not self.target:
            self.target = self.find_value('target')

    def get_target_raw(self):
        "Returns the raw config for self.target or 'all'"
        ret = []
        self._check_target()
        for entry in self.raw:
            if entry[0] == self.target or entry[0] == 'all':
                ret.append(entry)
        return ret

    def add(self, key, val):
        "Adds the key:value pair to the config dictionary (if needed)"
        # %!options
        if key == 'options':
            # Actions are not valid inside %!options
            ignoreme = self.dft_actions.keys()
            # --target inside %!options is not allowed (use %!target)
            ignoreme.append('target')
            # But there are some exceptions that are allowed (XXX why?)
            ignoreme.remove('dump-config')
            ignoreme.remove('dump-source')
            ignoreme.remove('targets')
            raw_opts = CommandLine().get_raw_config(
                val, ignore=ignoreme)
            for target, key, val in raw_opts:
                self.add(key, val)
            return
        # The no- prefix turns OFF this key
        if key.startswith('no-'):
            key = key[3:]              # remove prefix
            val = self.off.get(key)    # turn key OFF
        # Is this key valid?
        if key not in self.defaults:
            Debug('Bogus Config %s:%s' % (key, val), 1)
            return
        # Is this value the default one?
        if val == self.defaults.get(key):
            # If default value, remove previous key:val
            if key in self.parsed:
                del self.parsed[key]
            # Nothing more to do
            return
        # Flags ON comes empty. we'll add the 1 value now
        if val == '' and (
           key in self.dft_flags or
           key in self.dft_actions):
            val = 1
        # Multi value or single?
        if key in self.multi:
            # First one? start new list
            if key not in self.parsed:
                self.parsed[key] = []
            self.parsed[key].append(val)
        # Incremental value? so let's add it
        elif key in self.incremental:
            self.parsed[key] = (self.parsed.get(key) or 0) + val
        else:
            self.parsed[key] = val
        fancykey = dotted_spaces("%12s" % key)
        Message(_("Added config") + (" %s : %s" % (fancykey, val)), 3)

    def get_outfile_name(self, config={}):
        "Dirname is the same for {in,out}file"

        infile, outfile = config['sourcefile'], config['outfile']

        # Set output to STDOUT/MODULEOUT when no real inputfile
        if infile == STDIN and not outfile:
            outfile = STDOUT
        if infile == MODULEIN and not outfile:
            outfile = MODULEOUT

        # Automatic outfile name: infile.target
        if not outfile and (infile and config.get('target')):
            # .t2t and .txt are the only "official" source extensions
            basename = re.sub('\.t[2x]t$', '', infile)
            outfile = "%s.%s" % (basename, config['target'])
            if config['target'] == 'aat' and config['slides']:
                outfile = "%s.%s" % (basename, 'aap')
            if config['target'] == 'aat' and config['spread']:
                outfile = "%s.%s" % (basename, 'aas')
            if config['target'] == 'aat' and config['web']:
                outfile = "%s.%s" % (basename, 'aatw')
            if config['target'] == 'aat' and config['slides'] and config['web']:
                outfile = "%s.%s" % (basename, 'aapw')
            if config['target'] == 'aat' and config['spread'] and config['web']:
                outfile = "%s.%s" % (basename, 'aasw')

        Debug(" infile: '%s'" % infile , 1)
        Debug("outfile: '%s'" % outfile, 1)
        return outfile

    def sanity(self, config, gui=0):
        "Basic config sanity checking"
        global AA
        global RST
        global CSV
        if not config:
            return {}
        target = config.get('target')
        # Some actions don't require target specification
        if not target:
            for action in NO_TARGET:
                if config.get(action):
                    target = 'txt'
                    break
        # On GUI, some checking are skipped
        if not gui:
            # We *need* a target
            if not target:
                Error(_('No target specified (try --help)') + '\n\n' +
                _('Please inform a target using the -t option or the %!target command.') + '\n' +
                _('Example:') + ' %s -t html %s' % (my_name, _('file.t2t')) + '\n\n' +
                _("Run 'txt2tags --targets' to see all the available targets."))
            # And of course, an infile also
            # TODO#1: It seems that this checking is never reached
            if not config.get('infile'):
                Error(_('Missing input file (try --help)'))
            # Is the target valid?
            if not TARGETS.count(target):
                Error(_("Invalid target '%s'") % target + '\n\n' +
                _("Run 'txt2tags --targets' to see all the available targets."))
        # Ensure all keys are present
        empty = self.defaults.copy()
        empty.update(config)
        config = empty.copy()
        # Check integers options
        for key in config.keys():
            if key in self.numeric:
                try:
                    config[key] = int(config[key])
                except ValueError:
                    Error(_('--%s value must be a number') % key)
        # Check split level value
        if config['split'] not in (0, 1, 2):
            Error(_('Option --split must be 0, 1 or 2'))
        if target == 'aap':
            target, config['slides'] = 'aat', True
        if target == 'aas':
            target, config['spread'] = 'aat', True
        if target == 'aatw':
            target, config['web'] = 'aat', True
        if target == 'aapw':
            target, config['slides'], config['web'] = 'aat', True, True
        if target == 'aasw':
            target, config['spread'], config['web'] = 'aat', True, True
        # Slides needs width and height
        if config['slides'] and target == 'aat':
            if config['web']:
                config['height'], config['width'] = 28, 73
            if not config['width'] and  not config['height'] and os.name == 'posix':
                import fcntl, termios
                data = fcntl.ioctl(sys.stdout.fileno(), termios.TIOCGWINSZ, 4*'00')
                config['height'], config['width'] = struct.unpack('4H',data)[:2]
            if not config['width']:
                config['width'] = DFT_SLIDE_WIDTH
            if not config['height']:
                config['height'] = DFT_SLIDE_HEIGHT
        # ASCII Art needs a width
        if target == 'aat' and not config['width']:
            config['width'] = DFT_TEXT_WIDTH
        if target == 'aat' and config['width'] < 5:
            Error(_("--width: Expected width > 4, got %i") % config['width'])
        # Check/set user ASCII Art formatting characters
        if config['chars']:
            try:
                # Peace for ASCII 7-bits only
                config['chars'] = config['chars'].encode()
            except:
                if config['encoding'].lower() == 'utf-8' and locale.getpreferredencoding() != 'UTF-8':
                    Error(_("--chars: Expected chars from an UTF-8 terminal for your UTF-8 file"))
                if config['encoding'].lower() != 'utf-8' and locale.getpreferredencoding() == 'UTF-8':
                    if not config['encoding']:
                        Error(_("--chars: Expected an UTF-8 file for your chars from an UTF-8 terminal, you could set %!encoding: UTF-8"))
                    else:
                        Error(_("--chars: Expected an UTF-8 file for your chars from an UTF-8 terminal"))
            if target == 'aat':
                if config['chars'] == 'unicode':
                    if config['encoding'].lower() != 'utf-8':
                        if not config['encoding']:
                            Error(_("--chars: Expected an UTF-8 file for the unicode chars set, you could set %!encoding: UTF-8"))
                        else:
                            Error(_("--chars: Expected an UTF-8 file for the unicode chars set"))
                    config['chars'] = unichr(0x250c) + unichr(0x2510) + unichr(0x2514) + unichr(0x2518) + unichr(0x252C) + unichr(0x2534) + unichr(0x251c) + unichr(0x2524) + unichr(0x255e) + unichr(0x256a) + unichr(0x2561) + unichr(0x256c) + unichr(0x2565) + unichr(0x256b) + unichr(0x2568) + unichr(0x253c) + unichr(0x2500) + unichr(0x2502) + unichr(0x2500) + unichr(0x2550) + unichr(0x2550) + unichr(0x2500) + '^"' + unichr(0x2043) + unichr(0x2550) + unichr(0x2551)
                if len(config['chars']) != len(AA_SIMPLE) and len(config['chars']) != len(AA_ADVANCED):
                    Error(_("--chars: Expected %i or %i chars, got %i") % (
                        len(AA_SIMPLE), len(AA_ADVANCED), len(config['chars'])))
                if isinstance(config['chars'], unicode):
                    for char in config['chars']:
                        if unicodedata.east_asian_width(char) in ('F', 'W'):
                            Error(_("--chars: Expected no CJK double width chars, but got %s") % char.encode('utf-8'))
                if len(config['chars']) == len(AA_SIMPLE):
                    config['chars'] = 15 * config['chars'][0] + config['chars']
                AA = dict(zip(AA_KEYS, config['chars']))
            elif target == 'rst':
                if len(config['chars']) != len(RST_VALUES):
                    Error(_("--chars: Expected %i chars, got %i") % (
                        len(RST_VALUES), len(config['chars'])))
                else:
                    # http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#sections
                    chars_section = '!"#$%&\'()*+,-./:;<=>?@[\]^_`{|}~'
                    for char in config['chars'][:7]:
                        if char not in chars_section:
                            if locale.getpreferredencoding() == 'UTF-8':
                                char = char.encode('utf-8')
                            Error(_("--chars: Expected chars in : %s but got %s") % (chars_section, char))
                    # http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#bullet-lists
                    chars_bullet, char_8  = '*+-', config['chars'][7]
                    if char_8 not in chars_bullet:
                        if locale.getpreferredencoding() == 'UTF-8':
                            char_8 = char_8.encode('utf-8')
                        Error(_("--chars: Expected chars in : %s but got %s") % (chars_bullet, char_8))
                    RST = dict(zip(RST_KEYS, config['chars']))
            elif target in ('csv', 'csvs'):
                if len(config['chars']) != len(CSV_VALUES) and len(config['chars']) != len(CSV_VALUES) + 1:
                    Error(_("--chars: Expected %i or %i chars, got %i") % (
                        len(CSV_VALUES), len(CSV_VALUES) + 1, len(config['chars'])))
                else:
                    CSV = dict(zip(CSV_KEYS, config['chars']))

        # --toc-only is stronger than others
        if config['toc-only']:
            config['headers'] = 0
            config['toc']     = 0
            config['split']   = 0
            config['gui']     = 0
            config['outfile'] = config['outfile'] or STDOUT
        # Splitting is disable for now (future: HTML only, no STDOUT)
        config['split'] = 0
        # Restore target
        config['target'] = target
        # Set output file name
        config['outfile'] = self.get_outfile_name(config)
        # Checking suicide
        if os.path.abspath(config['sourcefile']) == os.path.abspath(config['outfile']) and \
           config['outfile'] not in [STDOUT, MODULEOUT] and not gui:
            Error(_("Input and Output files are the same: %s") % config['outfile'])
        if target == 'db':
            try:
                import sqlite3
            except:
                Error('No sqlite3 module')
            global DB, DBC
            try:
                os.remove(config['outfile'])
            except:
                pass
            DB = sqlite3.connect(config['outfile'])
            DBC = DB.cursor()
        return config

    def parse(self):
        "Returns the parsed config for the current target"
        raw = self.get_target_raw()
        for target, key, value in raw:
            if key == 'chars' and locale.getpreferredencoding() == 'UTF-8':
                self.add(key, value.decode('utf-8'))
            else:
                self.add(key, value)
        Message(_("Added the following keys: %s") % ', '.join(self.parsed.keys()), 2)
        return self.parsed.copy()

    def find_value(self, key='', target=''):
        "Scans ALL raw config to find the desired key"
        ret = []
        # Scan and save all values found
        for targ, k, val in self.raw:
            if k == key and (targ == target or targ == 'all'):
                ret.append(val)
        if not ret:
            return ''
        # If not multi value, return only the last found
        if key in self.multi:
            return ret
        else:
            return ret[-1]


########################################################################

class ConfigLines:
    """
    ConfigLines class - the config file data extractor

    This class reads and parse the config lines on the %!key:val
    format, converting it to RAW config. It deals with user
    config file (RC file), source document CONF area and
    %!includeconf directives.

    Call it passing a file name or feed the desired config lines.
    Then just call the get_raw_config() method and wait to
    receive the full config data on the RAW format. This method
    also follows the possible %!includeconf directives found on
    the config lines. Example:

        raw = ConfigLines(file=".txt2tagsrc").get_raw_config()

    The parse_line() method is also useful to be used alone,
    to identify and tokenize a single config line. For example,
    to get the %!include command components, on the source
    document BODY:

        target, key, value = ConfigLines().parse_line(body_line)
    """
    # parse_line regexes, moved here to avoid recompilation
    _parse_cfg = re.compile("""
        ^%!\s*                # leading id with opt spaces
        (?P<name>\w+)\s*       # config name
        (\((?P<target>\w*)\))? # optional target spec inside ()
        \s*:\s*               # key:value delimiter with opt spaces
        (?P<value>\S.+?)      # config value
        \s*$                  # rstrip() spaces and hit EOL
        """, re.I + re.VERBOSE)
    _parse_prepost = re.compile("""
                                      # ---[ PATTERN ]---
        ^( "([^"]*)"          # "double quoted" or
        | '([^']*)'           # 'single quoted' or
        | ([^\s]+)            # single_word
        )
        \s+                   # separated by spaces
                                  # ---[ REPLACE ]---
        ( "([^"]*)"           # "double quoted" or
        | '([^']*)'           # 'single quoted' or
        | (.*)                # anything
        )
        \s*$
        """, re.VERBOSE)
    _parse_guicolors = re.compile("^([^\s]+\s+){3}[^\s]+")  # 4 tokens

    def __init__(self, file_='', lines=[], first_line=1):
        self.file = file_ or 'NOFILE'
        self.lines = lines
        self.first_line = first_line
        if file_:
            self.folder = os.path.dirname(self.file)
        else:
            self.folder = ''

    def load_lines(self):
        "Make sure we've loaded the file contents into buffer"
        if not self.lines and not self.file:
            Error("ConfigLines: No file or lines provided")
        if not self.lines:
            self.lines = self.read_config_file(self.file)

    def read_config_file(self, filename=''):
        "Read a Config File contents, aborting on invalid line"
        if not filename:
            return []
        errormsg = _("Invalid CONFIG line on %s") + "\n%03d:%s"
        lines = Readfile(filename, remove_linebreaks=1)
        # Sanity: try to find invalid config lines
        for i in xrange(len(lines)):
            line = lines[i].rstrip()
            if not line:  # empty
                continue
            if line[0] != '%':
                Error(errormsg % (filename, i + 1, line))
        return lines

    def include_config_file(self, file_=''):
        "Perform the %!includeconf action, returning RAW config"
        if not file_:
            return []

        # Fix config file path
        file_ = self.fix_config_relative_path(file_)

        # Read and parse included config file contents
        return ConfigLines(file_=file_).get_raw_config()

    def fix_config_relative_path(self, path_):
        """
        The path for external files must be relative to the config file path.
        External files appear in: %!includeconf, %!style, %!template.
        See issue 71.
        """
        return PathMaster().join(self.folder, path_)

    def get_raw_config(self):
        "Scan buffer and extract all config as RAW (including includes)"
        ret = []
        self.load_lines()
        first = self.first_line

        def add(target, key, val):
            "Save the RAW config"
            ret.append([target, key, val])
            Message(_("Added %s") % key, 3)

        for i in xrange(len(self.lines)):
            line = self.lines[i]
            Message(_("Processing line %03d: %s") % (first + i, line), 2)
            target, key, val = self.parse_line(line)

            if not key:  # no config on this line
                continue

            # %!style
            # We need to fix the CSS files path. See issue 71.
            #
            # This stylepath config holds the fixed path for each CSS file.
            # This path is used when composing headers, inside doHeader().
            #
            if key == 'style':
                stylepath = self.fix_config_relative_path(val)
                add(target, 'stylepath', stylepath)
                # Note: the normal 'style' config will be added later

            # %!options
            if key == 'options':
                # Prepend --dirname option to track config file original folder
                if self.folder:
                    val = '--dirname %s %s' % (self.folder, val)

            # %!includeconf
            if key == 'includeconf':

                # Sanity
                err = _('A file cannot include itself (loop!)')
                if val == self.file:
                    Error("%s: %%!includeconf: %s" % (err, self.file))

                more_raw = self.include_config_file(val)
                ret.extend(more_raw)

                Message(_("Finished Config file inclusion: %s") % val, 2)

            # Normal config, except %!includeconf
            else:
                add(target, key, val)
        return ret

    def parse_line(self, line='', keyname='', target=''):
        "Detects %!key:val config lines and extract data from it"
        empty = ['', '', '']
        if not line:
            return empty
        no_target = ['target', 'includeconf']
        # XXX TODO <value>\S.+?  requires TWO chars, breaks %!include:a
        cfgregex  = ConfigLines._parse_cfg
        prepostregex = ConfigLines._parse_prepost
        guicolors = ConfigLines._parse_guicolors

        # Give me a match or get out
        match = cfgregex.match(line)
        if not match:
            return empty

        if keyname and keyname != match.group('name'):
            return empty
        if target and match.group('target') not in (None, '', target):
            return empty

        # Save information about this config
        name   = (match.group('name') or '').lower()
        target = (match.group('target') or 'all').lower()
        value  = match.group('value')

        # %!keyword(target) not allowed for these
        if name in no_target and match.group('target'):
            Error(
                _("You can't use (target) with %s") % ('%!' + name)
                + "\n%s" % line)

        # Force no_target keywords to be valid for all targets
        if name in no_target:
            target = 'all'

        # Special config for GUI colors
        if name == 'guicolors':
            valmatch = guicolors.search(value)
            if not valmatch:
                return empty
            value = re.split('\s+', value)

        # Special config with two quoted values (%!preproc: "foo" 'bar')
        if name in ['preproc', 'postproc', 'postvoodoo']:
            valmatch = prepostregex.search(value)
            if not valmatch:
                return empty
            getval = valmatch.group
            patt   = getval(2) or getval(3) or getval(4) or ''
            repl   = getval(6) or getval(7) or getval(8) or ''
            value  = (patt, repl)
        return [target, name, value]


##############################################################################

class MaskMaster:
    """(Un)Protect important structures from escaping and formatting.

    Some inline markup must be protected, because its contents may match
    other markup, or because we should not escape or format its contents
    in any way.

    When the source line is read, we call the mask() method to identify
    those inliners (link, mono, macro, raw, tagged) and change each one
    for an (ugly) internal identifier.

    For example, ''<b>this</b>'' will become vvvTAGGED0vvv. The number
    increases as other inliners of the same type are found. 

    The method undo() is called at the end of the line processing,
    expanding all masks back to their original (untouched) content.
    """

    def __init__(self):
        self.linkmask   = 'vvvLINKNNNvvv'  # NNN will be replaced by the index
        self.monomask   = 'vvvMONONNNvvv'
        self.macromask  = 'vvvMACRONNNvvv'
        self.rawmask    = 'vvvRAWNNNvvv'
        self.taggedmask = 'vvvTAGGEDNNNvvv'
        self.tocmask    = 'vvvTOCvvv'
        self.linkmaskre   = re.compile('vvvLINK(\d+)vvv')
        self.monomaskre   = re.compile('vvvMONO(\d+)vvv')
        self.macromaskre  = re.compile('vvvMACRO(\d+)vvv')
        self.rawmaskre    = re.compile('vvvRAW(\d+)vvv')
        self.taggedmaskre = re.compile('vvvTAGGED(\d+)vvv')
        self.macroman   = MacroMaster()
        self.reset()

    def reset(self):
        self.linkbank = []
        self.monobank = []
        self.macrobank = []
        self.rawbank = []
        self.taggedbank = []

    def mask(self, line=''):
        global AUTOTOC

        # The verbatim, raw and tagged inline marks are mutually exclusive.
        # This means that one can't appear inside the other.
        # If found, the inner marks must be ignored.
        # Example: ``foo ""bar"" ''baz''``
        # In HTML: <code>foo ""bar"" ''baz''</code>
        #
        # The trick here is to protect the mark who appears first on the line.
        # The three regexes are tried and the one with the lowest index wins.
        # If none is found (else), we get out of the loop.
        #
        while True:

            # Try to match the line for the three marks
            # Note: 'z' > 99999999...
            #
            t = r = v = 'z'
            try:
                t = regex['tagged'].search(line).start()
            except:
                pass
            try:
                r = regex['raw'].search(line).start()
            except:
                pass
            try:
                v = regex['fontMono'].search(line).start()
            except:
                pass

            # Protect tagged text
            if t >= 0 and t < r and t < v:
                txt = regex['tagged'].search(line).group(1)
                txt = doProtect(TARGET, txt)
                i = len(self.taggedbank)
                self.taggedbank.append(txt)
                mask = self.taggedmask.replace('NNN', str(i))
                line = regex['tagged'].sub(mask, line, 1)

            # Protect raw text
            elif r >= 0 and r < t and r < v:
                txt = regex['raw'].search(line).group(1)
                txt = doEscape(TARGET, txt)
                i = len(self.rawbank)
                self.rawbank.append(txt)
                mask = self.rawmask.replace('NNN', str(i))
                line = regex['raw'].sub(mask, line, 1)

            # Protect verbatim text
            elif v >= 0 and v < t and v < r:
                txt = regex['fontMono'].search(line).group(1)
                txt = doEscape(TARGET, txt)
                i = len(self.monobank)
                self.monobank.append(txt)
                mask = self.monomask.replace('NNN', str(i))
                line = regex['fontMono'].sub(mask, line, 1)
            else:
                break

        # Protect macros
        while regex['macros'].search(line):
            txt = regex['macros'].search(line).group()
            i = len(self.macrobank)
            self.macrobank.append(txt)
            mask = self.macromask.replace('NNN', str(i))
            line = regex['macros'].sub(mask, line, 1)

        # Protect TOC location
        while regex['toc'].search(line):
            line = regex['toc'].sub(self.tocmask, line)
            AUTOTOC = 0

        # Protect URLs and emails
        while regex['linkmark'].search(line) or \
              regex['link'].search(line):

            # Try to match plain or named links
            match_link  = regex['link'].search(line)
            match_named = regex['linkmark'].search(line)

            # Define the current match
            if match_link and match_named:
                # Both types found, which is the first?
                m = match_link
                if match_named.start() < match_link.start():
                    m = match_named
            else:
                # Just one type found, we're fine
                m = match_link or match_named

            # Extract link data and apply mask
            if m == match_link:              # plain link
                link = m.group()
                label = ''
                link_re = regex['link']
            else:                            # named link
                link = fix_relative_path(m.group('link'))
                label = m.group('label').rstrip()
                link_re = regex['linkmark']

            # Save link data to the link bank
            i = len(self.linkbank)
            self.linkbank.append((label, link))

            # Mask the link mark in the original line
            mask = self.linkmask.replace('NNN', str(i))
            line = link_re.sub(mask, line, 1)

        return line

    def undo(self, line):

        # url & email
        matches = list(self.linkmaskre.finditer(line))
        while matches:
            m = matches.pop()
            i = int(m.group(1))
            label, url = self.linkbank[i]
            link = get_tagged_link(label, url)
            line = line[0:m.start()] + link + line[m.end():]

        # Expand macros
        matches = list(self.macromaskre.finditer(line))
        while matches:
            m = matches.pop()
            i = int(m.group(1))
            macro = self.macroman.expand(self.macrobank[i])
            line = line[0:m.start()] + macro + line[m.end():]

        # Expand verb
        matches = list(self.monomaskre.finditer(line))
        while matches:
            m = matches.pop()
            i = int(m.group(1))
            open_, close = TAGS['fontMonoOpen'], TAGS['fontMonoClose']
            line = line[0:m.start()] + open_ + self.monobank[i] + close + line[m.end():]

        # Expand raw
        matches = list(self.rawmaskre.finditer(line))
        while matches:
            m = matches.pop()
            i = int(m.group(1))
            line = line[0:m.start()] + self.rawbank[i] + line[m.end():]

        # Expand tagged
        matches = list(self.taggedmaskre.finditer(line))
        while matches:
            m = matches.pop()
            i = int(m.group(1))
            line = line[0:m.start()] + self.taggedbank[i] + line[m.end():]

        return line


##############################################################################


class TitleMaster:
    "Title things"
    def __init__(self):
        self.count = ['', 0, 0, 0, 0, 0]
        self.toc   = []
        self.level = 0
        self.kind  = ''
        self.txt   = ''
        self.label = ''
        self.tag   = ''
        self.tag_hold = []
        self.last_level = 0
        self.count_id = ''
        self.anchor_count = 0
        self.anchor_prefix = 'toc'

    def _open_close_blocks(self):
        "Open new title blocks, closing the previous (if any)"
        if not rules['titleblocks']:
            return
        tag = ''
        last = self.last_level
        curr = self.level

        # Same level, just close the previous
        if curr == last:
            tag = TAGS.get('title%dClose' % last)
            if tag:
                self.tag_hold.append(tag)

        # Section -> subsection, more depth
        while curr > last:
            last += 1

            # Open the new block of subsections
            tag = TAGS.get('blockTitle%dOpen' % last)
            if tag:
                self.tag_hold.append(tag)

            # Jump from title1 to title3 or more
            # Fill the gap with an empty section
            if curr - last > 0:
                tag = TAGS.get('title%dOpen' % last)
                tag = regex['x'].sub('', tag)      # del \a
                if tag:
                    self.tag_hold.append(tag)

        # Section <- subsection, less depth
        while curr < last:
            # Close the current opened subsection
            tag = TAGS.get('title%dClose' % last)
            if tag:
                self.tag_hold.append(tag)

            # Close the current opened block of subsections
            tag = TAGS.get('blockTitle%dClose' % last)
            if tag:
                self.tag_hold.append(tag)

            last -= 1

            # Close the previous section of the same level
            # The subsections were under it
            if curr == last:
                tag = TAGS.get('title%dClose' % last)
                if tag:
                    self.tag_hold.append(tag)

    def add(self, line):
        "Parses a new title line."
        if not line:
            return
        self._set_prop(line)
        self._open_close_blocks()
        self._set_count_id()
        self._set_label()
        self._save_toc_info()

    def close_all(self):
        "Closes all opened title blocks"
        ret = []
        ret.extend(self.tag_hold)
        while self.level:
            tag = TAGS.get('title%dClose' % self.level)
            if tag:
                ret.append(tag)
            tag = TAGS.get('blockTitle%dClose' % self.level)
            if tag:
                ret.append(tag)
            self.level -= 1
        return ret

    def _save_toc_info(self):
        "Save TOC info, used by self.dump_marked_toc()"
        self.toc.append((self.level, self.count_id, self.txt, self.label))

    def _set_prop(self, line=''):
        "Extract info from original line and set data holders."
        # Detect title type (numbered or not)
        id_ = line.lstrip()[0]
        if   id_ == '=':
            kind = 'title'
        elif id_ == '+':
            kind = 'numtitle'
        else:
            Error("Unknown Title ID '%s'" % id_)
        # Extract line info
        match = regex[kind].search(line)
        level = len(match.group('id'))
        txt   = match.group('txt').strip()
        label = match.group('label')
        # Parse info & save
        if CONF['enum-title']:
            kind = 'numtitle'  # force
        if rules['titleblocks']:
            self.tag = TAGS.get('%s%dOpen' % (kind, level)) or \
                       TAGS.get('title%dOpen' % level)
        else:
            self.tag = TAGS.get(kind + str(level)) or \
                       TAGS.get('title' + str(level))
        self.last_level = self.level
        self.kind  = kind
        self.level = level
        self.txt   = txt
        self.label = label

    def _set_count_id(self):
        "Compose and save the title count identifier (if needed)."
        count_id = ''
        if self.kind == 'numtitle' and not rules['autonumbertitle']:
            # Manually increase title count
            self.count[self.level] += 1
            # Reset sublevels count (if any)
            max_levels = len(self.count)
            if self.level < max_levels - 1:
                for i in xrange(self.level + 1, max_levels):
                    self.count[i] = 0
            # Compose count id from hierarchy
            for i in xrange(self.level):
                count_id = "%s%d." % (count_id, self.count[i + 1])
        self.count_id = count_id

    def _set_label(self):
        "Compose and save title label, used by anchors."
        # Remove invalid chars from label set by user
        self.label = re.sub('[^A-Za-z0-9_-]', '', self.label or '')
        # Generate name as 15 first :alnum: chars
        #TODO how to translate safely accented chars to plain?
        #self.label = re.sub('[^A-Za-z0-9]', '', self.txt)[:15]
        # 'tocN' label - sequential count, ignoring 'toc-level'
        #self.label = self.anchor_prefix + str(len(self.toc) + 1)

    def _get_tagged_anchor(self):
        "Return anchor if user defined a label, or TOC is on."
        ret = ''
        label = self.label
        if CONF['toc'] and self.level <= CONF['toc-level']:
            # This count is needed bcos self.toc stores all
            # titles, regardless of the 'toc-level' setting,
            # so we can't use self.toc length to number anchors
            self.anchor_count += 1
            # Autonumber label (if needed)
            label = label or '%s%s' % (self.anchor_prefix, self.anchor_count)
        if label and TAGS['anchor']:
            ret = regex['x'].sub(label, TAGS['anchor'])
        return ret

    def _get_full_title_text(self):
        "Returns the full title contents, already escaped."
        ret = self.txt
        # Insert count_id (if any) before text
        if self.count_id:
            ret = '%s %s' % (self.count_id, ret)
        # Escape specials
        ret = doEscape(TARGET, ret)
        # Same targets needs final escapes on title lines
        # It's here because there is a 'continue' after title
        if rules['finalescapetitle']:
            ret = doFinalEscape(TARGET, ret)
        return ret

    def get(self):
        "Returns the tagged title as a list."
        global AA_TITLE
        ret = []

        # Maybe some anchoring before?
        anchor = self._get_tagged_anchor()
        self.tag = regex['_anchor'].sub(anchor, self.tag)

        ### Compose & escape title text (TOC uses unescaped)
        full_title = self._get_full_title_text()

        # Close previous section area
        ret.extend(self.tag_hold)
        self.tag_hold = []

        tagged = regex['x'].sub(full_title, self.tag)

        # Adds "underline" on TXT target
        if TARGET == 'txt':
            if BLOCK.count > 1:
                ret.append('')  # blank line before
            ret.append(tagged)
            i = aa_lencjk(full_title)
            ret.append(regex['x'].sub('=' * i, self.tag))
        elif TARGET == 'aat' and self.level == 1:
            if CONF['slides'] :
                AA_TITLE = tagged
            else :
                if BLOCK.count > 1:
                    ret.append('')  # blank line before
                box = aa_box([tagged], AA, CONF['width'])
                if CONF['web'] and CONF['toc']:
                    ret.extend([anchor] + box + ['</a>'])
                else:
                    ret.extend(box)
        elif TARGET == 'aat':
            level = 'level' + str(self.level)
            if BLOCK.count > 1:
                ret.append('')  # blank line before
            if CONF['slides']:
                under = aa_under(tagged, AA[level], CONF['width'] - 2, False)
            else:
                under = aa_under(tagged, AA[level], CONF['width'], False)
            if CONF['web'] and CONF['toc'] and self.level <= CONF['toc-level'] and not CONF['slides']:
                ret.extend([anchor] + under + ['</a>'])
            else:
                ret.extend(under)
        elif TARGET == 'rst' and self.level == 1:
            if BLOCK.count > 1:
                ret.append('')  # blank line before
            ret.extend(aa_under(tagged, RST['level1'], 10000, True))
        elif TARGET == 'rst':
            level = 'level' + str(self.level)
            if BLOCK.count > 1:
                ret.append('')  # blank line before
            ret.extend(aa_under(tagged, RST[level], 10000, False))
        else:
            ret.append(tagged)
        return ret

    def dump_marked_toc(self, max_level=99):
        "Dumps all toc itens as a valid t2t-marked list"
        ret = []
        toc_count = 1
        head = 0
        if CONF['headers'] and CONF['header1']:
            head = 1
        for level, count_id, txt, label in self.toc:
            if level > max_level:  # ignore
                continue
            indent = '  ' * level
            id_txt = ('%s %s' % (count_id, txt)).lstrip()
            if CONF['target'] == 'aat' and CONF['slides']:
                indent = '  ' * (level - 1)
                if CONF['web'] and not CONF['toc-only']:
                    label = str(AA_PW_TOC[txt] / (CONF['height'] - 1) + head + 2) + '.0'
            label = label or self.anchor_prefix + str(toc_count)
            toc_count += 1

            # TOC will have crosslinks to anchors
            if TAGS['anchor']:
                if CONF['enum-title'] and level == 1:
                    # 1. [Foo #anchor] is more readable than [1. Foo #anchor] in level 1.
                    # This is a stoled idea from Windows .CHM help files.
                    tocitem = '%s+ [""%s"" #%s]' % (indent, txt, label)
                else:
                    tocitem = '%s- [""%s"" #%s]' % (indent, id_txt, label)

            # TOC will be plain text (no links)
            else:
                if rules['plaintexttoc'] and not CONF['slides']:
                    # For these, the list is not necessary, just dump the text
                    tocitem = '%s""%s""' % (indent, id_txt)
                elif TARGET == 'aat' and CONF['enum-title'] and level == 1:
                    tocitem = '%s+ ""%s""' % (indent, txt)
                else:
                    tocitem = '%s- ""%s""' % (indent, id_txt)
            ret.append(tocitem)
        return ret


##############################################################################

# Table syntax reference for targets:
# http://www.mediawiki.org/wiki/Help:Tables
# http://moinmo.in/HelpOnMoinWikiSyntax#Tables
# http://moinmo.in/HelpOnTables
# http://www.wikicreole.org/wiki/Creole1.0#section-Creole1.0-Tables
# http://www.wikicreole.org/wiki/Tables
# http://www.pmwiki.org/wiki/PmWiki/Tables
# http://www.dokuwiki.org/syntax#tables
# http://michelf.com/projects/php-markdown/extra/#table
# http://code.google.com/p/support/wiki/WikiSyntax#Tables
# http://www.biblioscape.com/rtf15_spec.htm
# http://docutils.sourceforge.net/docs/ref/rst/restructuredtext.html#tables
#
# Good reading:
# http://www.wikicreole.org/wiki/ListOfTableMarkups
#
# See also:
# test/marks/table.t2t
# test/target/table.t2t

#TODO check all this table mess
# It uses parse_row properties for table lines
# BLOCK.table() replaces the cells by the parsed content
#
class TableMaster:
    def __init__(self, line=''):
        self.rows      = []
        self.border    = 0
        self.align     = 'Left'
        self.sortable  = False
        self.cellalign = []
        self.colalign  = []
        self.cellspan  = []
        if line:
            prop = self.parse_row(line)
            self.border    = prop['border']
            self.title     = prop['title']
            self.vert_head = prop['vert_head']
            self.align     = prop['align']
            self.sortable  = prop['sortable']
            self.cellalign = prop['cellalign']
            self.cellspan  = prop['cellspan']
            self.n_cols    = sum(self.cellspan)
            self.colalign  = self._get_col_align()

    def _get_col_align(self):
        colalign = []
        for cell in range(0, len(self.cellalign)):
            align = self.cellalign[cell]
            span  = self.cellspan[cell]
            colalign.extend([align] * span)
        return colalign

    def _get_full_tag(self, topen):
        # topen     = TAGS['tableOpen']
        tborder   = TAGS['_tableBorder']
        try:
            tsortable = TAGS['_tableSortable']
        except:
            pass # not html5js target
        talign    = TAGS['_tableAlign' + self.align]
        calignsep = TAGS['tableColAlignSep']
        calign    = ''
        # The first line defines if table has border or not
        if not self.border:
            tborder = ''
        # Check if sortable
        if not self.sortable:
            tsortable = ''
        # Set the columns alignment
        if rules['tablecellaligntype'] == 'column':
            calign = map(lambda x: TAGS['_tableColAlign%s' % x], self.colalign)
            calign = calignsep.join(calign)
        # Align full table, set border and Column align (if any)
        topen = regex['_tableAlign'].sub(talign , topen)
        topen = regex['_tableBorder'].sub(tborder, topen)
        try:
            topen = regex['_tableSortable'].sub(tsortable, topen)
        except:
            pass # not html5js
        topen = regex['_tableColAlign'].sub(calign , topen)
        # Tex table spec, border or not: {|l|c|r|} , {lcr}
        if calignsep and not self.border:
            # Remove cell align separator
            topen = topen.replace(calignsep, '')
        return topen

    def _get_cell_align(self, cells):
        ret = []
        for cell in cells:
            align = 'Left'
            if cell.strip():
                if cell[0] == ' ' and cell[-1] == ' ':
                    align = 'Center'
                elif cell[0] == ' ':
                    align = 'Right'
            ret.append(align)
        return ret

    def _get_cell_span(self, cells):
        ret = []
        for cell in cells:
            span = 1
            m = re.search('\a(\|+)$', cell)
            if m:
                span = len(m.group(1)) + 1
            ret.append(span)
        return ret

    def _tag_cells(self, rowdata):
        cells = rowdata['cells']
        open_ = TAGS['tableCellOpen']
        close = TAGS['tableCellClose']
        sep = TAGS['tableCellSep']
        head = TAGS['tableCellHead']
        calign = map(lambda x: TAGS['_tableCellAlign' + x], rowdata['cellalign'])
        caligntag = map(lambda x: TAGS['tableCellAlign' + x], rowdata['cellalign'])
        calignsep = TAGS['tableColAlignSep']
        ncolumns = len(self.colalign)

        # Populate the span and multicol open tags
        cspan = []
        multicol = []
        colindex = 0

        thisspan = 0
        spanmultiplier = rules['cellspanmultiplier'] or 1

        cellhead = []
        cellbody = []

        for cellindex in range(0, len(rowdata['cellspan'])):

            span = rowdata['cellspan'][cellindex]
            align = rowdata['cellalign'][cellindex]

            # hack to get cell size/span into rtf, in twips
            if rules['cellspancumulative']:
                thisspan += span
            else:
                thisspan = span
            span = thisspan * spanmultiplier

            if span > 1:

                if TAGS['_tableCellColSpanChar']:
                    # spanchar * n
                    cspan.append(TAGS['_tableCellColSpanChar'] * (span - 1))
                    # Note: using -1 for moin, where spanchar == cell delimiter
                else:
                    # \a replaced by n
                    cspan.append(regex['x'].sub(str(span), TAGS['_tableCellColSpan']))

                mcopen = regex['x'].sub(str(span), TAGS['_tableCellMulticolOpen'])
                multicol.append(mcopen)
            else:
                cspan.append('')

                if colindex < ncolumns and align != self.colalign[colindex]:
                    mcopen = regex['x'].sub('1', TAGS['_tableCellMulticolOpen'])
                    multicol.append(mcopen)
                else:
                    multicol.append('')

            if not self.border:
                multicol[-1] = multicol[-1].replace(calignsep, '')

            colindex += span

        # Maybe is it a title row?
        if rowdata['title']:
            # Defaults to normal cell tag if not found
            open_ = TAGS['tableTitleCellOpen']  or open_
            close = TAGS['tableTitleCellClose'] or close
            sep   = TAGS['tableTitleCellSep']   or sep
            head  = TAGS['tableTitleCellHead']  or head

        # Should we break the line on *each* table cell?
        if rules['breaktablecell']:
            close = close + '\n'

        # Cells pre processing
        if rules['tablecellstrip']:
            cells = map(lambda x: x.strip(), cells)
        if rowdata['title'] and rules['tabletitlerowinbold']:
            cells = map(lambda x: enclose_me('fontBold', x), cells)

        # Add cell BEGIN/END tags
        for i, cell in enumerate(cells):
            copen = open_
            cclose = close
            chead = head
            if self.vert_head and i == 0:
                copen = TAGS['tableTitleCellOpen']
                cclose = TAGS['tableTitleCellClose']
                if rules['breaktablecell']:
                    cclose = cclose + '\n'

            # Make sure we will pop from some filled lists
            # Fixes empty line bug '| |'
            this_align = this_cell = this_span = this_mcopen = ''
            if calign:
                this_align = calign.pop(0)
            if caligntag:
                this_cell = caligntag.pop(0)
            if cspan:
                this_span = cspan.pop(0)
            if multicol:
                this_mcopen = multicol.pop(0)

            # Insert cell align into open tag (if cell is alignable)
            if rules['tablecellaligntype'] == 'cell':
                copen = regex['_tableCellAlign'].sub(this_align, copen)
                cclose = regex['_tableCellAlign'].sub(this_align, cclose)
                chead = regex['_tableCellAlign'].sub(this_align, chead)

                # Insert cell data into cellAlign tags
                if this_cell:
                    cell = regex['x'].sub(cell, this_cell)

            # Insert cell span into open tag (if cell is spannable)
            if rules['tablecellspannable']:
                copen = regex['_tableCellColSpan'].sub(this_span, copen)
                cclose = regex['_tableCellColSpan'].sub(this_span, cclose)
                chead = regex['_tableCellColSpan'].sub(this_span, chead)

            # Use multicol tags instead (if multicol supported, and if
            # cell has a span or is aligned differently to column)
            if rules['tablecellmulticol']:
                if this_mcopen:
                    copen = regex['_tableColAlign'].sub(this_align, this_mcopen)
                    cclose = TAGS['_tableCellMulticolClose']

            # RTF target requires the border in each cell
            border = ''
            if self.border:
                border = TAGS['_tableCellBorder']
            copen = regex['_tableBorder'].sub(border, copen)
            cclose = regex['_tableBorder'].sub(border, cclose)
            chead = regex['_tableBorder'].sub(border, chead)

            # Attribute delimiter, added when align/span attributes were used
            # Example: Wikipedia table cell, without and with attributes:
            # | cell contents
            # | align="right" colspan="2" | cell contents
            #
            if regex['_tableAttrDelimiter'].search(copen):
                if this_align or this_span:
                    copen = regex['_tableAttrDelimiter'].sub(TAGS['_tableAttrDelimiter'], copen)
                else:
                    copen = regex['_tableAttrDelimiter'].sub('', copen)  # remove marker

            if chead:
                cellhead.append(chead)
            cellbody.append(copen + cell + cclose)

        # Maybe there are cell separators?
        return ''.join(cellhead) + sep.join(cellbody)

    def add_row(self, cells):
        self.rows.append(cells)

    def parse_row(self, line):
        # Default table properties
        ret = {
            'border': 0, 'title': 0, 'vert_head': 0, 'align': 'Left', 'sortable': False,
            'cells': [], 'cellalign': [], 'cellspan': []
        }
        # Detect table align (and remove spaces mark)
        if line[0] == ' ':
            ret['align'] = 'Center'
        line = line.lstrip()
        # Detect vertical header mark
        if line[1] == '_':
            ret['vert_head'] = 1
            line = line[0] + line[2:]
        # Detect horizontal and vertical headers mark
        if line[1] == '/':
            ret['vert_head'] = 1
            line = line[0] + '|' + line[2:]
        # Detect title mark
        if line[1] == '|':
            ret['title'] = 1
            if line[2] == '|':
              ret['sortable'] = True
        # Detect border mark and normalize the EOL
        m = re.search(' (\|+) *$', line)
        if m:
            line = line + ' '
            ret['border'] = 1
        else:
            line = line + ' | '
        # Delete table mark
        line = regex['table'].sub('', line)
        # Detect colspan  | foo | bar baz |||
        line = re.sub(' (\|+)\| ', '\a\\1 | ', line)
        # Split cells (the last is fake)
        ret['cells'] = line.split(' | ')[:-1]
        # Find cells span
        ret['cellspan'] = self._get_cell_span(ret['cells'])
        # Remove span ID
        ret['cells'] = map(lambda x: re.sub('\a\|+$', '', x), ret['cells'])
        # Find cells align
        ret['cellalign'] = self._get_cell_align(ret['cells'])
        # Hooray!
        Debug('Table Prop: %s' % ret, 7)
        return ret

    def dump(self):
        open_ = self._get_full_tag(TAGS['tableOpen'])
        if rules['tablenumber']:
            open_ = re.sub('n_table', str(BLOCK.tablecount), open_)
        if rules['tablecolumnsnumber']:
            open_ = re.sub('n_cols', str(self.n_cols), open_)
        rows  = self.rows
        close = self._get_full_tag(TAGS['tableClose'])

        rowopen     = self._get_full_tag(TAGS['tableRowOpen'])
        rowclose    = self._get_full_tag(TAGS['tableRowClose'])
        rowsep      = self._get_full_tag(TAGS['tableRowSep'])
        titrowopen  = self._get_full_tag(TAGS['tableTitleRowOpen'])  or rowopen
        titrowclose = self._get_full_tag(TAGS['tableTitleRowClose']) or rowclose

        if rules['breaktablelineopen']:
            rowopen = rowopen + '\n'
            titrowopen = titrowopen + '\n'

        # Tex gotchas
        if TARGET in ['tex', 'texs']:
            if not self.border:
                rowopen = titrowopen = ''
            else:
                close = rowopen + close

        # Now we tag all the table cells on each row
        #tagged_cells = map(lambda x: self._tag_cells(x), rows)  #!py15
        tagged_cells = []
        for cell in rows:
            tagged_cells.append(self._tag_cells(cell))

        # Add row separator tags between lines
        tagged_rows = []
        if rowsep:
            #!py15
            #tagged_rows = map(lambda x: x + rowsep, tagged_cells)
            for cell in tagged_cells:
                tagged_rows.append(cell + rowsep)
            # Remove last rowsep, because the table is over
            tagged_rows[-1] = tagged_rows[-1].replace(rowsep, '')
        # Add row BEGIN/END tags for each line
        else:
            for rowdata in rows:
                if rowdata['title']:
                    o, c = titrowopen, titrowclose
                else:
                    o, c = rowopen, rowclose
                row = tagged_cells.pop(0)
                tagged_rows.append(o + row + c)

        # Join the pieces together
        fulltable = []
        if open_:
            fulltable.append(open_)
        fulltable.extend(tagged_rows)
        if close:
            fulltable.append(close)

        return fulltable


##############################################################################


class BlockMaster:
    "TIP: use blockin/out to add/del holders"
    def __init__(self):
        self.BLK = []
        self.HLD = []
        self.PRP = []
        self.depth = 0
        self.count = 0
        self.last = ''
        self.tableparser = None
        self.tablecount = 0
        self.contains = {
            'para'    : ['comment', 'raw', 'tagged'],
            'verb'    : [],
            'table'   : ['comment'],
            'raw'     : [],
            'tagged'  : [],
            'comment' : [],
            'quote'   : ['quote', 'comment', 'raw', 'tagged'],
            'list'    : ['list', 'numlist', 'deflist', 'para', 'verb', 'comment', 'raw', 'tagged'],
            'numlist' : ['list', 'numlist', 'deflist', 'para', 'verb', 'comment', 'raw', 'tagged'],
            'deflist' : ['list', 'numlist', 'deflist', 'para', 'verb', 'comment', 'raw', 'tagged'],
            'bar'     : [],
            'title'   : [],
            'numtitle': [],
        }
        self.allblocks = self.contains.keys()

        # If one is found inside another, ignore the marks
        self.exclusive = ['comment', 'verb', 'raw', 'tagged']

        # May we include bars inside quotes?
        if rules['barinsidequote']:
            self.contains['quote'].append('bar')

    def block(self):
        if not self.BLK:
            return ''
        return self.BLK[-1]

    def isblock(self, name=''):
        return self.block() == name

    def prop(self, key):
        if not self.PRP:
            return ''
        return self.PRP[-1].get(key) or ''

    def propset(self, key, val):
        self.PRP[-1][key] = val
        #Debug('BLOCK prop ++: %s->%s' % (key, repr(val)), 1)
        #Debug('BLOCK props: %s' % (repr(self.PRP)), 1)

    def hold(self):
        if not self.HLD:
            return []
        return self.HLD[-1]

    def holdadd(self, line):
        if self.block().endswith('list'):
            line = [line]
        self.HLD[-1].append(line)
        Debug('HOLD add: %s' % repr(line), 4)
        Debug('FULL HOLD: %s' % self.HLD, 4)

    def holdaddsub(self, line):
        self.HLD[-1][-1].append(line)
        Debug('HOLD addsub: %s' % repr(line), 4)
        Debug('FULL HOLD: %s' % self.HLD, 4)

    def holdextend(self, lines):
        if self.block().endswith('list'):
            lines = [lines]
        self.HLD[-1].extend(lines)
        Debug('HOLD extend: %s' % repr(lines), 4)
        Debug('FULL HOLD: %s' % self.HLD, 4)

    def blockin(self, block):
        ret = []
        if block not in self.allblocks:
            Error("Invalid block '%s'" % block)

        # First, let's close other possible open blocks
        while self.block() and block not in self.contains[self.block()]:
            ret.extend(self.blockout())

        # Now we can gladly add this new one
        self.BLK.append(block)
        self.HLD.append([])
        self.PRP.append({})
        self.count += 1
        if block == 'table':
            self.tableparser = TableMaster()
        # Deeper and deeper
        self.depth = len(self.BLK)
        Debug('block ++ (%s): %s' % (block, self.BLK), 3)
        return ret

    def blockout(self):
        if not self.BLK:
            Error('No block to pop')
        blockname = self.BLK.pop()
        result = getattr(self, blockname)()
        parsed = self.HLD.pop()
        self.PRP.pop()
        self.depth = len(self.BLK)

        if rules['tableonly'] and blockname != 'table':
            return []

        if blockname == 'table':
            del self.tableparser

        # Inserting a nested block into mother
        if self.block():
            if blockname != 'comment':  # ignore comment blocks
                if self.block().endswith('list'):
                    self.HLD[-1][-1].append(result)
                else:
                    self.HLD[-1].append(result)
            # Reset now. Mother block will have it all
            result = []

        Debug('block -- (%s): %s' % (blockname, self.BLK), 3)
        Debug('RELEASED (%s): %s' % (blockname, parsed), 3)

        # Save this top level block name (produced output)
        # The next block will use it
        if result:
            self.last = blockname
            if rules['iswrapped']:
                final = []
                if TARGET != 'aat':
                    for line in result:
                        if not line or blockname in ('verb', 'tagged'):
                            final.append(line)
                        else:
                            final.extend(aa_wrap(line, CONF['width'], False))
                elif CONF['slides'] and blockname in ('list', 'numlist', 'deflist'):
                    final.extend(aa_box(result, AA, CONF['width'], False, web=CONF['web'], slides=CONF['slides']))
                else:
                    for line in result:
                        if not line or (blockname in ('table', 'tagged', 'verb') and not CONF['slides']) or (blockname == 'quote' and CONF['slides']):
                            final.append(line)
                        else:
                            if CONF['slides'] and blockname in ('table', 'tagged', 'verb'):
                                final.append(line[:CONF['width']])
                            elif CONF['slides']:
                                final.extend(' ' + line for line in aa_wrap(line, CONF['width'] - 2, CONF['web']))
                            else:
                                final.extend(aa_wrap(line, CONF['width'], CONF['web']))
                result = final[:]

            Debug('BLOCK: %s' % result, 6)

        # ASCII Art processing
        global AA_TITLE, AA_COUNT, AA_PW_TOC, AA_IMG
        if TARGET == 'aat' and CONF['slides'] and not CONF['toc-only'] and not CONF.get('art-no-title'):
            len_res = len(result)
            for el in result:
                if '<img' in el:
                    len_res = len_res + AA_IMG
            n = (CONF['height'] - 1) - (AA_COUNT % (CONF['height'] - 1) + 1)
            if n < len_res and not (TITLE.level == 1 and blockname in ["title", "numtitle"]):
                if CONF['web']:
                    if len_res > CONF['height']:
                        result[CONF['height'] - 8] = result[CONF['height'] - 8] + '</pre></section>'
                        for i, line in enumerate(result[CONF['height'] - 7:]):
                            j = i % (CONF['height'] - 1)
                            if j == 0:
                                result[i + CONF['height'] - 7] = '<section><pre>' + line
                            elif j == CONF['height'] - 2:
                                result[i + CONF['height'] - 7] = line + '</pre></section>'
                    result = ([''] * n) + [aa_line(AA['bar1'], CONF['width']) + '</pre></section>'] + aa_slide(AA_TITLE, AA['bar2'], CONF['width'], True) + [''] + result
                else:
                    result = ([''] * n) + [aa_line(AA['bar1'], CONF['width'])] + aa_slide(AA_TITLE, AA['bar2'], CONF['width'], False) + [''] + result
            if (blockname in ["title", "numtitle"] and TITLE.level == 1) or not AA_TITLE:
                if not AA_TITLE:
                    if CONF['headers']:
                        AA_TITLE = CONF['header1'] or ' '
                    else:
                        AA_TITLE = ' '
                aa_title = aa_slide(AA_TITLE, AA['bar2'], CONF['width'], CONF['web']) + ['']
                if AA_COUNT:
                    if CONF['web']:
                        aa_title = ([''] * n) + [aa_line(AA['bar2'], CONF['width']) + '</pre></section>'] + aa_title
                    else:
                        aa_title = ([''] * n) + [aa_line(AA['bar2'], CONF['width'])] + aa_title
                result = aa_title + result
            AA_COUNT += len(result) + AA_IMG
            AA_IMG = 0
            if blockname in ["title", "numtitle"]:
                AA_PW_TOC[TITLE.txt] = AA_COUNT

        return result

    def _last_escapes(self, line):
        return doFinalEscape(TARGET, line)

    def _get_escaped_hold(self):
        ret = []
        for line in self.hold():
            linetype = type(line)
            if linetype == type('') or linetype == type(u''):
                ret.append(self._last_escapes(line))
            elif linetype == type([]):
                ret.extend(line)
            else:
                Error("BlockMaster: Unknown HOLD item type: %s" % linetype)
        return ret

    def _remove_twoblanks(self, lastitem):
        if len(lastitem) > 1 and lastitem[-2:] == ['', '']:
            return lastitem[:-2]
        return lastitem

    def _should_add_blank_line(self, where, blockname):
        "Validates the blanksaround* rules"

        # Nestable blocks: only mother blocks (level 1) are spaced
        if blockname.endswith('list') and self.depth > 1:
            return False

        # The blank line after the block is always added
        if where == 'after' \
            and rules['blanksaround' + blockname]:
            return True

        # # No blank before if it's the first block of the body
        # elif where == 'before' \
        #   and BLOCK.count == 1:
        #   return False

        # # No blank before if it's the first block of this level (nested)
        # elif where == 'before' \
        #   and self.count == 1:
        #   return False

        # The blank line before the block is only added if
        # the previous block haven't added a blank line
        # (to avoid consecutive blanks)
        elif where == 'before' \
            and rules['blanksaround' + blockname] \
            and not rules.get('blanksaround' + self.last):
            return True

        # Nested quotes are handled here,
        # because the mother quote isn't closed yet
        elif where == 'before' \
            and blockname == 'quote' \
            and rules['blanksaround' + blockname] \
            and self.depth > 1:
            return True

        return False

    # functions to help encode block depth into RTF formatting
    def _apply_depth(self, line, level):
        # convert block depth into an indent in twips
        depth = level
        multiply = rules['blockdepthmultiply']
        if depth > 0 and rules['depthmultiplyplus']:
            depth = depth + rules['depthmultiplyplus']
        if multiply:
            depth = depth * multiply
        return regex['_blockDepth'].sub(str(depth), line)

    def _apply_list_level(self, line, level):
        mylevel = level
        if rules['listlevelzerobased']:
            mylevel = mylevel - 1
        return regex['_listLevel'].sub(str(mylevel), line)

    def comment(self):
        return ''

    def raw(self):
        lines = self.hold()
        return map(lambda x: doEscape(TARGET, x), lines)

    def tagged(self):
        return self.hold()

    def para(self):
        result = []
        open_ = TAGS['paragraphOpen']
        close = TAGS['paragraphClose']
        lines = self._get_escaped_hold()

        # Blank line before?
        if self._should_add_blank_line('before', 'para'):
            result.append('')

        # RTF needs depth level encoded into nested paragraphs
        mydepth = self.depth
        if rules['zerodepthparagraph']:
            mydepth = 0
        open_ = self._apply_depth(open_, mydepth)

        # Open tag
        if open_:
            result.append(open_)

        # Pagemaker likes a paragraph as a single long line
        if rules['onelinepara']:
            result.append(' '.join(lines))
        # Others are normal :)
        else:
            result.extend(lines)

        # Close tag
        if close:
            result.append(close)

        # Blank line after?
        if self._should_add_blank_line('after', 'para'):
            result.append('')

        # Very very very very very very very very very UGLY fix
        # Needed because <center> can't appear inside <p>
        try:
            if len(lines) == 1 and \
               TARGET in ('html', 'xhtml', 'xhtmls', 'wp') and \
               re.match('^\s*<center>.*</center>\s*$', lines[0]):
                result = [lines[0]]
        except:
            pass

        return result

    def verb(self):
        "Verbatim lines are not masked, so there's no need to unmask"
        result = []
        open_ = TAGS['blockVerbOpen']
        close = TAGS['blockVerbClose']
        sep = TAGS['blockVerbSep']

        # Blank line before?
        if self._should_add_blank_line('before', 'verb'):
            result.append('')

        # Open tag
        if open_:
            result.append(open_)

        # Get contents
        for line in self.hold():
            if self.prop('mapped') == 'table':
                line = MacroMaster().expand(line)
            if not rules['verbblocknotescaped']:
                line = doEscape(TARGET, line)
            if TAGS['blockVerbLine']:
                line = TAGS['blockVerbLine'] + line
            if rules['indentverbblock']:
                line = '  ' + line
            if rules['verbblockfinalescape']:
                line = doFinalEscape(TARGET, line)
            result.append(line)
            if sep:
                result.append(sep)

        if sep:
            result.pop()

        # Close tag
        if close:
            result.append(close)

        # Blank line after?
        if self._should_add_blank_line('after', 'verb'):
            result.append('')

        return result

    def numtitle(self):
        return self.title('numtitle')

    def title(self, name='title'):
        result = []

        # Blank line before?
        if self._should_add_blank_line('before', name):
            result.append('')

        # Get contents
        result.extend(TITLE.get())

        # Blank line after?
        if self._should_add_blank_line('after', name):
            result.append('')

        return result

    def table(self):
        self.tablecount += 1
        result = []

        if TARGET == 'aat' and self.tableparser.rows:
            if CONF['spread']:
                data = spreadsheet(completes_table(self.tableparser.rows), rules['spreadmarkup'], rules['spreadgrid'])
                return aa_table(data, AA, CONF['width'], True, True, True, 'Center', True, CONF['web']) + ['']
            else:
                return aa_table(completes_table(self.tableparser.rows), AA, CONF['width'], self.tableparser.border, self.tableparser.title, self.tableparser.vert_head, self.tableparser.align, False, False) + ['']

        if TARGET == 'rst' and self.tableparser.rows:
            chars = AA.copy()
            if not self.tableparser.border:
                chars['border'] = '='
                chars['tlcorner'] = chars['trcorner'] = chars['cross'] = chars['blcorner'] = chars['brcorner'] = chars['lcross'] = chars['side'] = chars['rcross'] = chars['tcross'] = chars['bcross'] = chars['lhhead'] = chars['rhhead'] = ' '
            return aa_table(completes_table(self.tableparser.rows), chars, CONF['width'], self.tableparser.border, self.tableparser.title, False, 'Left', False, False) + ['']

        if TARGET == 'mgp' and self.tableparser.rows:
            aa_t = aa_table(completes_table(self.tableparser.rows), AA, CONF['width'], True, self.tableparser.title, False, 'Left', False, False)
            try:
                import aafigure
                t_name = 'table_' + str(self.tablecount) + '.png'
                aafigure.render(unicode('\n'.join(aa_t)), t_name, {'format':'png', 'background':'#000000', 'foreground':'#FFFFFF', 'textual':True})
                return ['%center', '%newimage "' + t_name + '"']
            except:
                return ['%font "mono"'] + aa_t + ['']

        if TARGET == 'db' and self.tableparser.rows:
            data = completes_table(self.tableparser.rows)
            n = max([len(line[0]) for line in data])
            table = 'table_' + str(self.tablecount)
            if self.tableparser.title:
                cols = [s.strip().replace(' ', '_') for s in data[0][0]]
                del data[0]
            else:
                cols = []
                for i in range(n):
                    cols.append('col_' + str(i + 1))
            cols_insert = ', '.join(cols)
            cols_create = ' text, '.join(cols) + ' text'
            sql_create = 'create table ' + table + ' (id integer primary key, ' +  cols_create + ')'
            DBC.execute(sql_create)
            sql_insert = 'insert into ' + table + ' (' +  cols_insert + ') values' + ' (' + ('?,' * n)[:-1] + ')'
            for line in data:
                DBC.execute(sql_insert, line[0])
            DB.commit()

        # Blank line before?
        if self._should_add_blank_line('before', 'table'):
            result.append('')

        # Rewrite all table cells by the unmasked and escaped data
        lines = self._get_escaped_hold()
        for i in xrange(len(lines)):
            cells = lines[i].split(SEPARATOR)
            self.tableparser.rows[i]['cells'] = cells
        if rules['spread']:
            data = spreadsheet(completes_table(self.tableparser.rows), rules['spreadmarkup'], rules['spreadgrid'])
            self.tableparser.border, len_line = True, len(data[0][0])
            self.tableparser.cellalign = len_line
            self.tableparser.colalign = len_line * ['Left']
            if rules['spreadgrid']:
                self.tableparser.vert_head = True
                self.tableparser.rows = [{'cells':data[0][0], 'cellspan':data[0][1], 'cellalign':['Left']*len_line, 'title':1}] + self.tableparser.rows
                for i, row in enumerate(self.tableparser.rows[1:]):
                    row['cells'], row['cellspan'], row['cellalign'], row['title'] = data[i+1][0], data[i+1][1], ['Left']*len_line, 0
            else:
                for i, row in enumerate(self.tableparser.rows):
                    row['cells'], row['cellspan'], row['cellalign'], row['title'] = data[i][0], data[i][1], ['Left']*len_line, 0
        result.extend(self.tableparser.dump())

        # Blank line after?
        if self._should_add_blank_line('after', 'table'):
            result.append('')

        return result

    def quote(self):
        result = []
        open_  = TAGS['blockQuoteOpen']            # block based
        close  = TAGS['blockQuoteClose']
        qline  = TAGS['blockQuoteLine']            # line based
        indent = tagindent = '\t' * self.depth

        # Apply rules
        if rules['tagnotindentable']:
            tagindent = ''
        if not rules['keepquoteindent']:
            indent = ''

        # Blank line before?
        if self._should_add_blank_line('before', 'quote'):
            result.append('')

        # RTF needs depth level encoded into almost everything
        open_ = self._apply_depth(open_, self.depth)

        # Open tag
        if open_:
            result.append(tagindent + open_)

        itemisclosed = False

        # Get contents
        if rules['onelinequote']:
            # XXX Dirty hack, won't work for nested blocks inside quote (when TABS are used in your t2t source), even subquotes
            result.append(' '.join([regex['quote'].sub('', x) for x in self.hold()]))
        else:
            for item in self.hold():
                if type(item) == type([]):
                    if close and rules['quotenotnested']:
                        result.append(tagindent + close)
                        itemisclosed = True
                    result.extend(item)        # subquotes
                else:
                    if open_ and itemisclosed:
                        result.append(tagindent + open_)
                    item = regex['quote'].sub('', item)  # del TABs
                    item = self._last_escapes(item)
                    if CONF['target'] == 'aat' and CONF['slides']:
                        result.extend(aa_box([item], AA, CONF['width'], web=CONF['web'], slides=CONF['slides']))
                    else:
                        item = qline * self.depth + item
                        result.append(indent + item)  # quote line

        # Close tag
        if close and not itemisclosed:
            result.append(tagindent + close)

        # Blank line after?
        if self._should_add_blank_line('after', 'quote'):
            result.append('')

        return result

    def bar(self):
        result = []
        bar_tag = ''

        # Blank line before?
        if self._should_add_blank_line('before', 'bar'):
            result.append('')

        # Get the original bar chars
        bar_chars = self.hold()[0].strip()

        # Set bar type
        if bar_chars.startswith('='):
            bar_tag = TAGS['bar2']
        else:
            bar_tag = TAGS['bar1']

        # To avoid comment tag confusion like <!-- ------ --> (sgml)
        if TAGS['comment'].count('--'):
            bar_chars = bar_chars.replace('--', '__')

        # Get the bar tag (may contain \a)
        result.append(regex['x'].sub(bar_chars, bar_tag))

        # Blank line after?
        if self._should_add_blank_line('after', 'bar'):
            result.append('')

        return result

    def deflist(self):
        return self.list('deflist')

    def numlist(self):
        return self.list('numlist')

    def list(self, name='list'):
        result    = []
        items     = self.hold()
        indent    = self.prop('indent')
        tagindent = indent
        listline  = TAGS.get(name + 'ItemLine')
        itemcount = 0

        if name == 'deflist':
            itemopen  = TAGS[name + 'Item1Open']
            itemclose = TAGS[name + 'Item2Close']
            itemsep   = TAGS[name + 'Item1Close'] +\
                        TAGS[name + 'Item2Open']
        else:
            itemopen  = TAGS[name + 'ItemOpen']
            itemclose = TAGS[name + 'ItemClose']
            itemsep   = ''

        # Apply rules
        if rules['tagnotindentable']:
            tagindent = ''
        if not rules['keeplistindent']:
            indent = tagindent = ''

        # RTF encoding depth
        itemopen = self._apply_depth(itemopen, self.depth)
        itemopen = self._apply_list_level(itemopen, self.depth)

        # ItemLine: number of leading chars identifies list depth
        if listline:
            if rules['listlineafteropen']:
                itemopen  = itemopen + listline * self.depth
            else:
                itemopen  = listline * self.depth + itemopen

        # Adds trailing space on opening tags
        if (name == 'list'    and rules['spacedlistitemopen']) or \
           (name == 'numlist' and rules['spacednumlistitemopen']):
            itemopen = itemopen + ' '

        # Remove two-blanks from list ending mark, to avoid <p>
        items[-1] = self._remove_twoblanks(items[-1])

        # Blank line before?
        if self._should_add_blank_line('before', name):
            result.append('')

        if rules['blanksaroundnestedlist']:
            result.append('')

        # Tag each list item (multiline items), store in listbody
        itemopenorig = itemopen
        listbody = []
        widelist = 0
        for item in items:

            # Add "manual" item count for noautonum targets
            itemcount += 1
            if name == 'numlist' and not rules['autonumberlist']:
                n = str(itemcount)
                itemopen = regex['x'].sub(n, itemopenorig)
                del n

            # Tag it
            item[0] = self._last_escapes(item[0])
            if name == 'deflist':
                z, term, rest = item[0].split(SEPARATOR, 2)
                item[0] = rest
                if not item[0]:
                    del item[0]      # to avoid <p>
                listbody.append(tagindent + itemopen + term + itemsep)
            else:
                fullitem = tagindent + itemopen
                listbody.append(item[0].replace(SEPARATOR, fullitem))
                del item[0]

            itemisclosed = False

            # Process next lines for this item (if any)
            for line in item:
                if type(line) == type([]):  # sublist inside
                    if rules['listitemnotnested'] and itemclose:
                        listbody.append(tagindent + itemclose)
                        itemisclosed = True
                    if TARGET == 'rst' and name == 'deflist':
                        del line[0]
                    listbody.extend(line)
                else:
                    line = self._last_escapes(line)

                    # Blank lines turns to <p>
                    if not line and rules['parainsidelist']:
                        line = indent + TAGS['paragraphOpen'] + TAGS['paragraphClose']
                        line = line.rstrip()
                        widelist = 1
                    elif not line and TARGET == 'rtf':
                        listbody.append(TAGS['paragraphClose'])
                        line = TAGS['paragraphOpen']
                        line = self._apply_depth(line, self.depth)

                    # Some targets don't like identation here (wiki)
                    if not rules['keeplistindent'] or (name == 'deflist' and rules['deflisttextstrip']):
                        line = line.lstrip()

                    # Maybe we have a line prefix to add? (wiki)
                    if name == 'deflist' and TAGS['deflistItem2LinePrefix']:
                        line = TAGS['deflistItem2LinePrefix'] + line

                    listbody.append(line)

            # Close item (if needed)
            if itemclose and not itemisclosed:
                if rules['notbreaklistitemclose']:
                    listbody[-1] += itemclose
                else:
                    listbody.append(tagindent + itemclose)

        if not widelist and rules['compactlist']:
            listopen = TAGS.get(name + 'OpenCompact')
            listclose = TAGS.get(name + 'CloseCompact')
        else:
            listopen  = TAGS.get(name + 'Open')
            listclose = TAGS.get(name + 'Close')

        # Open list (not nestable lists are only opened at mother)
        if listopen and not \
           (rules['listnotnested'] and BLOCK.depth != 1):
            result.append(tagindent + listopen)

        result.extend(listbody)

        # Close list (not nestable lists are only closed at mother)
        if listclose and not \
           (rules['listnotnested'] and self.depth != 1):
            result.append(tagindent + listclose)

        # Blank line after?
        if self._should_add_blank_line('after', name):
            result.append('')

        if rules['blanksaroundnestedlist']:
            if result[-1]:
                result.append('')

        return result


##############################################################################


class MacroMaster:
    def __init__(self, config={}):
        self.name     = ''
        self.config   = config or CONF
        self.infile   = self.config['sourcefile']
        self.outfile  = self.config['outfile']
        self.currentfile = self.config['currentsourcefile']
        self.currdate = time.localtime(time.time())
        self.rgx      = regex.get('macros') or getRegexes()['macros']
        self.fileinfo = {'infile': None, 'outfile': None}
        self.dft_fmt  = MACROS

    def walk_file_format(self, fmt):
        "Walks the %%{in/out}file format string, expanding the % flags"
        i = 0
        ret = ''
        while i < len(fmt):                     # char by char
            c = fmt[i]
            i += 1
            if c == '%':                        # hot char!
                if i == len(fmt):               # % at the end
                    ret = ret + c
                    break
                c = fmt[i]                      # read next
                i += 1
                ret = ret + self.expand_file_flag(c)
            else:
                ret = ret + c                   # common char
        return ret

    def expand_file_flag(self, flag):
        "%f: filename          %F: filename (w/o extension)"
        "%d: dirname           %D: dirname (only parent dir)"
        "%p: file path         %e: extension"
        info = self.fileinfo[self.name]         # get dict
        if   flag == '%':
            x = '%'                             # %% -> %
        elif flag == 'f':
            x = info['name']
        elif flag == 'F':
            x = os.path.splitext(info['name'])[0]
        elif flag == 'd':
            x = info['dir']
        elif flag == 'D':
            x = os.path.split(info['dir'])[-1]
        elif flag == 'p':
            x = info['path']
        elif flag == 'e':
            x = os.path.splitext(info['name'])[1].replace('.', '')
        else:
            x = '%' + flag                      # false alarm
        return x

    def set_file_info(self, macroname):
        if (macroname == 'currentfile'):
            self.currentfile = self.config['currentsourcefile']
        else:
            if self.fileinfo.get(macroname):    # already done
                return
        file_ = getattr(self, self.name)        # self.infile
        if file_ == STDOUT or file_ == MODULEOUT:
            dir_ = ''
            path = name = file_
        else:
            path = os.path.abspath(file_)
            dir_ = os.path.dirname(path)
            name = os.path.basename(path)
        self.fileinfo[macroname] = {'path': path, 'dir': dir_, 'name': name}

    def expand(self, line=''):
        "Expand all macros found on the line"
        while self.rgx.search(line):
            m = self.rgx.search(line)
            name = self.name = m.group('name').lower()
            fmt = m.group('fmt') or self.dft_fmt.get(name)
            if name == 'date':
                txt = time.strftime(fmt, self.currdate)
            elif name == 'mtime':
                if self.infile in (STDIN, MODULEIN):
                    fdate = self.currdate
                elif PathMaster().is_url(self.infile):
                    try:
                        # Doing it the easy way: fetching the URL again.
                        # The right way would be doing it in Readfile().
                        # But I'm trying to avoid yet another global var
                        # or fake 'sourcefile_mtime' config.
                        #
                        # >>> f= urllib.urlopen('http://txt2tags.org/index.t2t')
                        # >>> f.info().get('last-modified')
                        # 'Thu, 18 Nov 2010 22:42:11 GMT'
                        # >>>
                        #
                        from urllib import urlopen
                        from email.Utils import parsedate

                        f = urlopen(self.infile)
                        mtime_rfc2822 = f.info().get('last-modified')
                        fdate = parsedate(mtime_rfc2822)
                    except:
                        # If mtime cannot be found, defaults to current date
                        fdate = self.currdate
                else:
                    mtime = os.path.getmtime(self.infile)
                    fdate = time.localtime(mtime)
                txt = time.strftime(fmt, fdate)
            elif name in ('infile', 'outfile', 'currentfile'):
                self.set_file_info(name)
                txt = self.walk_file_format(fmt)
            elif name == 'appurl':
                txt = my_url
            elif name == 'appname':
                txt = my_name
            elif name == 'appversion':
                txt = my_version
            elif name == 'target':
                txt = TARGET
            elif name == 'encoding':
                txt = self.config['encoding']
            elif name == 'cmdline':
                txt = '%s %s' % (my_name, ' '.join(self.config['realcmdline']))
            elif name in ('header1', 'header2', 'header3'):
                txt = self.config[name]
            elif name == 'cc':
                txt = cc_formatter(self.config, fmt)
            else:
                # Never reached because the macro regex list the valid keys
                Error("Unknown macro name '%s'" % name)
            line = self.rgx.sub(txt, line, 1)
        return line


##############################################################################

def cc_formatter(conf, size):
    cc, target = conf['cc'].lower(), conf['target']
    licenses = 'by, by-sa, by-nc-sa, by-nd, by-nc-nd, by-nc'
    if cc not in licenses.split(', '):
        Error(_('Please, choose one of the six valid Creative Commons licenses : %s.') % licenses)
    if target in ('html', 'xhtml', 'xhtmls', 'html5') or (target == 'aat' and conf['web']):
        if size == 'small':
            end_img = '/3.0/80x15.png'
        else:
            end_img = '/3.0/88x31.png'
        url = 'http://creativecommons.org/licenses/' + cc + '/3.0'
        img = 'http://i.creativecommons.org/l/' + cc + end_img
        alt = 'Creative Commons ' + cc
        ret = '<a href="' + url + '"><img src="' + img + '" alt="' + alt + '"></a>'
    else:
        if size == 'small':
            ret = 'Creative Commons %s' % cc
        else:
            ret = 'Creative Commons %s' % cc.upper()
    return ret


def listTargets():
    """list all available targets"""
    for typ in TARGET_TYPES:
        targets = list(TARGET_TYPES[typ][1])
        targets.sort()
        print
        print TARGET_TYPES[typ][0] + ':'
        for target in targets:
            print "\t%s\t%s" % (target, TARGET_NAMES.get(target))
    if OTHER_TARGETS:
        print
        print _('OTHERS:')
        for target in OTHER_TARGETS:
            print "\t%s\t%s" % (target, TARGET_NAMES.get(target))
    print
    if NOT_LOADED:
        print _('Targets %s from the targets directory not loaded, because there is already targets with the same name in txt2tags core.') % ', '.join(NOT_LOADED)
        print


def dumpConfig(source_raw, parsed_config):
    onoff = {1: _('ON'), 0: _('OFF')}
    data = [
        (_('RC file')        , RC_RAW     ),
        (_('source document'), source_raw ),
        (_('command line')   , CMDLINE_RAW)
    ]
    # First show all RAW data found
    for label, cfg in data:
        print _('RAW config for %s') % label
        for target, key, val in cfg:
            target = '(%s)' % target
            key    = dotted_spaces("%-14s" % key)
            val    = val or _('ON')
            print '  %-8s %s: %s' % (target, key, val)
        print
    # Then the parsed results of all of them
    print _('Full PARSED config')
    keys = parsed_config.keys()
    keys.sort()  # sorted
    for key in keys:
        val = parsed_config[key]
        # Filters are the last
        if key in ['preproc', 'postproc', 'postvoodoo']:
            continue
        # Flag beautifier
        if key in FLAGS or key in ACTIONS:
            val = onoff.get(val) or val
        # List beautifier
        if type(val) == type([]):
            if key == 'options':
                sep = ' '
            else:
                sep = ', '
            val = sep.join(val)
        print "%25s: %s" % (dotted_spaces("%-14s" % key), val)
    print
    print _('Active filters')
    for filter_ in ['preproc', 'postproc', 'postvoodoo']:
        for rule in parsed_config.get(filter_) or []:
            print "%25s: %s  ->  %s" % (
                dotted_spaces("%-14s" % filter_), rule[0], rule[1])


def get_file_body(file_):
    "Returns all the document BODY lines"
    return process_source_file(file_, noconf=1)[1][2]


def post_voodoo(lines, config):
    r'''
    %!postvoodoo handler - Beware! Voodoo here. For advanced users only.

    Your entire output document will be put in a single string, to your
    search/replace pleasure. Line breaks are single \n's in all platforms.
    You can change multiple lines at once, or even delete them. This is the
    last txt2tags processing in your file. All %!postproc's were already
    applied. It's the same as:

        $ txt2tags myfile.t2t | postvoodoo

    Your regex will be compiled with no modifiers. The default behavior is:

        ^ and $ match begin/end of entire string
        . doesn't match \n
        \w is not locale aware
        \w is not Unicode aware

    You can use (?...) in the beginning of your regex to change behavior:

        (?s)    the dot . will match \n, so .* will get everything
        (?m)    the ^ and $ match begin/end of EACH inner line
        (?u)    the \w, \d, \s and friends will be Unicode aware

    You can also use (?smu) or any combination of those.
    Learn more in http://docs.python.org/library/re.html
    '''

    loser1 = _('No, no. Your PostVoodoo regex is wrong. Maybe you should call mommy?')
    loser2 = _('Dear PostVoodoo apprentice: You got the regex right, but messed the replacement')

    subject = '\n'.join(lines)
    spells = compile_filters(config['postvoodoo'], loser1)

    for (magic, words) in spells:
        try:
            subject = magic.sub(words, subject)
        except:
            Error("%s: '%s'" % (loser2, words))

    return subject.split('\n')


def finish_him(outlist, config):
    "Writing output to screen or file"
    outfile = config['outfile']
    file_dict = {}
    outlist = unmaskEscapeChar(outlist)
    outlist = expandLineBreaks(outlist)

    # Apply PostProc filters
    if config['postproc']:
        filters = compile_filters(config['postproc'],
            _('Invalid PostProc filter regex'))
        postoutlist = []
        errmsg = _('Invalid PostProc filter replacement')
        for line in outlist:
            for rgx, repl in filters:
                try:
                    line = rgx.sub(repl, line)
                except:
                    Error("%s: '%s'" % (errmsg, repl))
            postoutlist.append(line)
        outlist = postoutlist[:]

    if config['postvoodoo']:
        outlist = post_voodoo(outlist, config)

    if MAILING and not rules['tableonly']:
        reader = MAILING
        repl_dict = {}
        for i, val in enumerate(reader):
            if i == 0:
                for j, el in enumerate(val):
                    repl_dict[el] = j
            else:     
                write_file = outfile
                for key in repl_dict:
                    write_file = write_file.replace('<<%s>>' % key, val[repl_dict[key]])
                point = write_file.rfind('.')
                if write_file == outfile or write_file in file_dict:
                    if point == -1:
                        write_file = write_file + '_' + str(i)
                    else:
                        write_file = write_file[:point] + '_' + str(i) + write_file[point:]
                newout = []
                for line in outlist:
                    for key in repl_dict:
                        line = line.replace('<<%s>>' % key, val[repl_dict[key]])
                    newout.append(line)
                file_dict[write_file] = newout
    else:
        file_dict[outfile] = outlist

    if config['target'] == 'db':
        DBC.close()
        if outfile in [MODULEOUT, STDOUT]:
            outlist = [open(config['outfile']).read()]
            os.remove(config['outfile'])

    outlist = []
    if outfile == MODULEOUT:
        for write_file in file_dict:
            outlist.append(file_dict[write_file])
        return outlist
    elif outfile == STDOUT:
        for write_file in file_dict:
            outlist.extend(file_dict[write_file])
        if GUI:
            return outlist, config
        else:
            for line in outlist:
                if isinstance(line, unicode):
                    line = line.encode('utf-8')
                print line
    else:
        if not config['target'] == 'db':
            for write_file in file_dict:
                Savefile(write_file, addLineBreaks(file_dict[write_file]))
        if not GUI and not QUIET:
            for write_file in file_dict:
                print _('%s wrote %s') % (my_name, write_file)

    if config['split']:
        if not QUIET:
            print "--- html..."
        sgml2html = 'sgml2html -s %s -l %s %s' % (
            config['split'], config['lang'] or lang, outfile)
        if not QUIET:
            print "Running system command:", sgml2html
        os.system(sgml2html)


def toc_inside_body(body, toc, config):
    ret = []
    if AUTOTOC:
        return body                     # nothing to expand
    toc_mark = MaskMaster().tocmask
    # Expand toc mark with TOC contents
    flag, n = False, 0
    for i,line in enumerate(body):
        if line.count(toc_mark):            # toc mark found
            if config['toc']:
                if config['target'] == 'aat' and config['slides']:
                    j = i % (config['height'] - 1)
                    title = body[i - j + 2 + n]
                    ret.extend([''] * (config['height'] - j - 2 + n))
                    ret.extend([aa_line(AA['bar1'], config['width'])] + toc + aa_slide(title, AA['bar2'], config['width'], CONF['web']) + [''])
                    flag = True
                else:
                    ret.extend(toc)     # include if --toc
            else:
                pass                # or remove %%toc line
        else:
            if flag and config['target'] == 'aat' and config['slides'] and body[i] == body[i + 4] == aa_line(AA['bar2'], config['width']):
                end = [ret[-1]]
                del ret[-1]
                ret.extend([''] * (j - 6 - n) + end)
                flag, n = False, n + 1
                ret.append(line)            # common line
            else:
                ret.append(line)            # common line
    return ret


def toc_tagger(toc, config):
    "Returns the tagged TOC, as a single tag or a tagged list"
    ret = []
    # Convert the TOC list (t2t-marked) to the target's list format
    if config['toc-only'] or (config['toc'] and not TAGS['TOC']):
        fakeconf = config.copy()
        fakeconf['headers']    = 0
        fakeconf['toc-only']   = 0
        fakeconf['mask-email'] = 0
        fakeconf['preproc']    = []
        fakeconf['postproc']   = []
        fakeconf['postvoodoo'] = []
        fakeconf['css-sugar']  = 0
        fakeconf['fix-path']   = 0
        fakeconf['art-no-title']  = 1  # needed for --toc and --slides together, avoids slide title before TOC
        ret, foo = convert(toc, fakeconf)
        set_global_config(config)   # restore config
    # Our TOC list is not needed, the target already knows how to do a TOC
    elif config['toc'] and TAGS['TOC']:
        ret = [TAGS['TOC']]
    return ret


def toc_formatter(toc, config):
    "Formats TOC for automatic placement between headers and body"

    if config['toc-only']:
        return toc              # no formatting needed
    if not config['toc']:
        return []               # TOC disabled
    ret = toc

    # Art: An automatic "Table of Contents" header is added to the TOC slide
    if config['target'] == 'aat' and config['slides']:
        n = (config['height'] - 1) - (len(toc) + 6) % (config['height'] - 1)
        toc = aa_slide(config['toc-title'] or _("Table of Contents"), AA['bar2'], config['width'], CONF['web']) + toc + ([''] * n)
        end_toc = aa_line(AA['bar2'], config['width'])
        if config['web']:
            end_toc = end_toc + '</pre></section>'
        toc.append(end_toc)
        return toc
    if config['target'] == 'aat' and not config['slides']:
        ret = aa_box([config['toc-title'] or _("Table of Contents")], AA, config['width']) + toc

    # TOC open/close tags (if any)
    if TAGS['tocOpen']:
        ret.insert(0, TAGS['tocOpen'])
    if TAGS['tocClose']:
        ret.append(TAGS['tocClose'])

    # Autotoc specific formatting
    if AUTOTOC:
        if rules['autotocwithbars']:           # TOC between bars
            para = TAGS['paragraphOpen'] + TAGS['paragraphClose']
            bar  = regex['x'].sub('-' * DFT_TEXT_WIDTH, TAGS['bar1'])
            tocbar = [para, bar, para]
            if config['target'] == 'aat' and config['headers']:
                # exception: header already printed a bar
                ret = [para] + ret + tocbar
            else:
                ret = tocbar + ret + tocbar
        if rules['blankendautotoc']:           # blank line after TOC
            ret.append('')
        if rules['autotocnewpagebefore']:      # page break before TOC
            ret.insert(0, TAGS['pageBreak'])
        if rules['autotocnewpageafter']:       # page break after TOC
            ret.append(TAGS['pageBreak'])
    return ret


# XXX change function name. Now it's called at the end of the execution, dumping the full template.
def doHeader(headers, config):
    if not config['headers']:
        return config['fullBody']
    if not headers:
        headers = ['', '', '']
    target = config['target']
    if target not in HEADER_TEMPLATE:
        Error("doHeader: Unknown target '%s'" % target)

    # Use default templates
    if config['template'] == '' :
        if target in ('html', 'xhtml', 'xhtmls', 'html5') and config.get('css-sugar'):
            template = HEADER_TEMPLATE[target + 'css'].split('\n')
        else:
            template = HEADER_TEMPLATE[target].split('\n')

        template.append('%(BODY)s')

        if TAGS['EOD']:
            template.append(TAGS['EOD'].replace('%', '%%'))  # escape % chars

    # Read user's template file
    else:
        if PathMaster().is_url(config['template']):
            template = Readfile(config['template'], remove_linebreaks=1)
        else:
            templatefile = ''
            names = [config['template'] + '.' + target, config['template']]
            for filename in names:
                if os.path.isfile(filename):
                    templatefile = filename
                    break
            if not templatefile:
                Error(_("Cannot find template file:") + ' ' + config['template'])
            template = Readfile(templatefile, remove_linebreaks=1)

    head_data = {'STYLE': [], 'ENCODING': ''}

    # Fix CSS files path
    config['stylepath_out'] = fix_css_out_path(config)

    # Populate head_data with config info
    for key in head_data.keys():
        val = config.get(key.lower())
        if key == 'STYLE' and 'html' in target:
            val = config.get('stylepath_out') or []
        # Remove .sty extension from each style filename (freaking tex)
        # XXX Can't handle --style foo.sty, bar.sty
        if target in ['tex', 'texs'] and key == 'STYLE':
            val = map(lambda x: re.sub('(?i)\.sty$', '', x), val)
        if key == 'ENCODING':
            val = get_encoding_string(val, target)
        head_data[key] = val

    # Parse header contents
    for i in 0, 1, 2:
        # Expand macros
        contents = MacroMaster(config=config).expand(headers[i])
        # Escapes - on tex, just do it if any \tag{} present
        if target not in ['tex', 'texs'] or \
          (target in ['tex', 'texs'] and re.search(r'\\\w+{', contents)):
            contents = doEscape(target, contents)
        if target == 'lout':
            contents = doFinalEscape(target, contents)

        head_data['HEADER%d' % (i + 1)] = contents

    # When using --css-inside, the template's <STYLE> line must be removed.
    # Template line removal for empty header keys is made some lines above.
    # That's why we will clean STYLE now.
    if target in ('html', 'xhtml', 'xhtmls', 'html5', 'htmls', 'wp') and config.get('css-inside') and config.get('style'):
        head_data['STYLE'] = []

    Debug("Header Data: %s" % head_data, 1)

    # ASCII Art and rst don't use a header template, aa_header() formats the header
    if target == 'aat' and not (config['spread'] and not config['web']):
        template = aa_header(head_data, AA, config['width'], config['height'], CONF['web'], CONF['slides'])
        if config['slides']:
            l = aa_lencjk(head_data['HEADER2']) + aa_lencjk(head_data['HEADER3']) + 2
            bar_1 = bar_2 = aa_line(AA['bar2'], config['width'])
            if config['web']:
                bar_1 = '<section><pre>' + bar_1
            n_page = 0
            for i, line in enumerate(config['fullBody']):
                if config['fullBody'][i - 1] == bar_1 and config['fullBody'][i + 3] == bar_2:
                    n_page += 1
            page = 1
            for i, line in enumerate(config['fullBody']):
                if config['fullBody'][i - 1] == bar_1 and config['fullBody'][i + 3] == bar_2:
                    pages = str(page) + '/' + str(n_page)
                    l1 = aa_lencjk(head_data['HEADER1']) + len(pages) + 3
                    config['fullBody'][i] = ' ' + head_data['HEADER1'][:config['width'] - len(pages) - 3] + ' ' * (config['width'] - l1) + ' ' + pages + ' '
                    page += 1
                if config['fullBody'][i - 3] == bar_1 and config['fullBody'][i + 1] == bar_2:
                    if l < config['width']:
                        config['fullBody'][i] = ' ' + head_data['HEADER2'] + ' ' * (config['width'] - l) + head_data['HEADER3'] + ' '
        # Header done, let's get out
        if config['web']:
            encoding = ''
            if CONF['encoding'] and CONF['encoding'] != 'not_utf-8':
                encoding = '<meta charset=' + CONF['encoding'] + '>'
            if config['spread']:
                pre = '<pre style="text-align:center">'
            elif config['slides']:
                pre = ''
            else:
                pre = '<pre>'
            head_web = ['<!doctype html><html>' + encoding + '<title>' + config['header1'] + '</title>' + pre]
            foot_web = ['</pre></html>']
            if config['slides']:
                foot_web = [AAPW_FOOT]
            if config['spread']:
                return head_web + config['fullBody'] + foot_web
            else:
                return head_web + template + config['fullBody'] + foot_web
        else:
            return template + config['fullBody']

    if target =='rst':
        template =[]
        if head_data['HEADER1']:
            template.extend(aa_under(head_data['HEADER1'], RST['title'], 10000, True))
        if head_data['HEADER2']:
            template.append(':Author: ' + head_data['HEADER2'])
        if head_data['HEADER3']:
            template.append(':Date: ' + head_data['HEADER3'])
        return template + config['fullBody']

    # Scan for empty dictionary keys
    # If found, scan template lines for that key reference
    # If found, remove the reference
    # If there isn't any other key reference on the same line, remove it
    #TODO loop by template line > key
    for key in head_data.keys():
        if head_data.get(key):
            continue
        for line in template:
            if line.count('%%(%s)s' % key):
                sline = line.replace('%%(%s)s' % key, '')
                if not re.search(r'%\([A-Z0-9]+\)s', sline) and not rules['keepblankheaderline']:
                    template.remove(line)

    # Style is a multiple tag.
    # - If none or just one, use default template
    # - If two or more, insert extra lines in a loop (and remove original)
    styles = head_data['STYLE']
    if len(styles) == 1:
        head_data['STYLE'] = styles[0]
    elif len(styles) > 1:
        style_mark = '%(STYLE)s'
        for i in xrange(len(template)):
            if template[i].count(style_mark):
                while styles:
                    template.insert(i + 1, template[i].replace(style_mark, styles.pop()))
                del template[i]
                break

    # Expand macros on *all* lines of the template
    template = map(MacroMaster(config=config).expand, template)
    # Add Body contents to template data
    head_data['BODY'] = '\n'.join(config['fullBody'])
    # Populate template with data (dict expansion)
    template = '\n'.join(template) % head_data

    # Adding CSS contents into template (for --css-inside)
    # This code sux. Dirty++
    if target in ('html', 'xhtml', 'xhtmls', 'html5', 'htmls', 'wp') and config.get('css-inside') and \
       config.get('stylepath'):
        set_global_config(config)  # usually on convert(), needed here
        for i in xrange(len(config['stylepath'])):
            cssfile = config['stylepath'][i]
            try:
                contents = Readfile(cssfile, remove_linebreaks=1)
                css = "\n%s\n%s\n%s\n%s\n" % (
                    doCommentLine("Included %s" % cssfile),
                    TAGS['cssOpen'],
                    '\n'.join(contents),
                    TAGS['cssClose'])
                # Style now is content, needs escaping (tex)
                #css = maskEscapeChar(css)
            except:
                Error(_("CSS include failed for %s") % cssfile)
            # Insert this CSS file contents on the template
            template = re.sub('(?i)(</HEAD>)', css + r'\1', template)
            # template = re.sub(r'(?i)(\\begin{document})',
            #       css + '\n' + r'\1', template)  # tex

        # The last blank line to keep everything separated
        template = re.sub('(?i)(</HEAD>)', '\n' + r'\1', template)

    return template.split('\n')


def doCommentLine(txt):
    # The -- string ends a (h|sg|xht)ml comment :(
    txt = maskEscapeChar(txt)
    if TAGS['comment'].count('--') and txt.count('--'):
        txt = re.sub('-(?=-)', r'-\\', txt)

    if TAGS['comment']:
        return regex['x'].sub(txt, TAGS['comment'])
    return ''


def doFooter(config):
    ret = []

    # No footer. The --no-headers option hides header AND footer
    if not config['headers']:
        return []

    # Only add blank line before footer if last block doesn't added by itself
    if not rules.get('blanksaround' + BLOCK.last):
        ret.append('')

    # Add txt2tags info at footer, if target supports comments
    if TAGS['comment']:

        # Not using TARGET_NAMES because it's i18n'ed.
        # It's best to always present this info in english.
        target = config['target']
        if config['target'] == 'tex':
            target = 'LaTeX2e'
        if config['target'] == 'aat':
            target = 'ASCII Art'

        t2t_version = '%s code generated by %s %s (%s)' % (target, my_name, my_version, my_url)
        cmdline = 'cmdline: %s %s' % (my_name, ' '.join(config['realcmdline']))

        ret.append(doCommentLine(t2t_version))
        ret.append(doCommentLine(cmdline))

    # Maybe we have a specific tag to close the document?
    #if TAGS['EOD']:
    #   ret.append(TAGS['EOD'])

    return ret


#this converts proper \ue37f escapes to RTF \u-7297 escapes
def convertUnicodeRTF(match):
    num = int(match.group(1), 16)
    if num > 32767:
        num = num | -65536
    return ESCCHAR + 'u' + str(num) + '?'


def get_escapes(target):
    if target == 'texs':
        target = 'tex'
    return ESCAPES.get(target, [])


def doProtect(target, txt):
    "Protect text in tagged blocks from being escaped."
    for before, protected, after in get_escapes(target):
        txt = txt.replace(before, protected)
    return txt


def doEscape(target, txt):
    "Target-specific special escapes. Apply *before* insert any tag."
    tmpmask = 'vvvvThisEscapingSuxvvvv'

    if rules['escapexmlchars']:
        txt = re.sub('&', '&amp;', txt)
        txt = re.sub('<', '&lt;', txt)
        txt = re.sub('>', '&gt;', txt)

    if target == 'sgml':
            txt = re.sub('\xff', '&yuml;', txt)  # "+y
    elif target == 'pm6':
        txt = re.sub('<', '<\#60>', txt)
    elif target == 'mgp':
        txt = re.sub('^%', ' %', txt)  # add leading blank to avoid parse
    elif target == 'man':
        txt = re.sub("^([.'])", '\\&\\1', txt)              # command ID
        txt = txt.replace(ESCCHAR, ESCCHAR + 'e')           # \e
    elif target == 'lout':
        # TIP: / moved to FinalEscape to avoid //italic//
        # TIP: these are also converted by lout:  ...  ---  --
        txt = txt.replace(ESCCHAR, tmpmask)                 # \
        txt = txt.replace('"', '"%s""' % ESCCHAR)           # "\""
        txt = re.sub('([|&{}@#^~])', '"\\1"', txt)          # "@"
        txt = txt.replace(tmpmask, '"%s"' % (ESCCHAR * 2))  # "\\"
    elif target in ['tex', 'texs']:
        # Mark literal \ to be changed to $\backslash$ later
        txt = txt.replace(ESCCHAR, tmpmask)
        txt = re.sub('([#$&%{}])', ESCCHAR + r'\1'  , txt)  # \%
        txt = re.sub('([~^])'    , ESCCHAR + r'\1{}', txt)  # \~{}
        txt = re.sub('([<|>])'   ,           r'$\1$', txt)  # $>$
        txt = txt.replace(tmpmask, maskEscapeChar(r'$\backslash$'))
        # TIP the _ is escaped at the end
    elif target == 'rtf':
        txt = txt.replace(ESCCHAR, ESCCHAR + ESCCHAR)
        txt = re.sub('([{}])', ESCCHAR + r'\1', txt)
        # RTF is ascii only
        # If an encoding is declared, try to convert to RTF unicode
        enc = get_encoding_string(CONF['encoding'], 'rtf')
        if enc:
            try:
                txt = txt.decode(enc)
            except:
                Error('Problem decoding line "' % txt + '"')
            txt = txt.encode('cp1252', 'backslashreplace')
            # escape ANSI codes above ascii range
            for code in range(128, 255):
                txt = re.sub('%c' % code, ESCCHAR + "'" + hex(code)[2:], txt)
            # some code were preescaped by txt.encode
            txt = re.sub(r'\\x([0-9a-f]{2})', r"\\\'\1", txt)
            #finally, convert escaped unicode chars to RTF format
            txt = re.sub(r'\\u([0-9a-f]{4})', convertUnicodeRTF, txt)
    return txt


# TODO man: where - really needs to be escaped?
def doFinalEscape(target, txt):
    "Last escapes of each line"
    for before, protected, after in get_escapes(target):
        # If the string has not been protected, replace it.
        txt = txt.replace(before, after)
        # If the string has been protected, restore it.
        txt = txt.replace(protected, before)
    return txt


def EscapeCharHandler(action, data):
    "Mask/Unmask the Escape Char on the given string"
    if not data.strip():
        return data
    if action not in ('mask', 'unmask'):
        Error("EscapeCharHandler: Invalid action '%s'" % action)
    if action == 'mask':
        return data.replace('\\', ESCCHAR)
    else:
        return data.replace(ESCCHAR, '\\')


def maskEscapeChar(data):
    "Replace any Escape Char \ with a text mask (Input: str or list)"
    if type(data) == type([]):
        return map(lambda x: EscapeCharHandler('mask', x), data)
    return EscapeCharHandler('mask', data)


def unmaskEscapeChar(data):
    "Undo the Escape char \ masking (Input: str or list)"
    if type(data) == type([]):
        return map(lambda x: EscapeCharHandler('unmask', x), data)
    return EscapeCharHandler('unmask', data)


def addLineBreaks(mylist):
    "use LB to respect sys.platform"
    ret = []
    for line in mylist:
        line = line.replace('\n', LB)       # embedded \n's
        ret.append(line + LB)               # add final line break
    return ret


# Convert ['foo\nbar'] to ['foo', 'bar']
def expandLineBreaks(mylist):
    ret = []
    for line in mylist:
        ret.extend(line.split('\n'))
    return ret


def compile_filters(filters, errmsg='Filter'):
    if filters:
        for i in xrange(len(filters)):
            patt, repl = filters[i]
            try:
                rgx = re.compile(patt)
            except:
                Error("%s: '%s'" % (errmsg, patt))
            filters[i] = (rgx, repl)
    return filters


def enclose_me(tagname, txt):
    return TAGS.get(tagname + 'Open') + txt + TAGS.get(tagname + 'Close')


def fix_relative_path(path):
    """
    Fix image/link path to be relative to the source file path (issues 62, 63)

    Leave the path untouched when:
    - not using --fix-path
    - path is an URL (or email)
    - path is an #anchor
    - path is absolute
    - infile is STDIN
    - outfile is STDOUT

    Note: Keep this rules in sync with fix_css_out_path()
    """
    if not CONF['fix-path'] \
        or regex['link'].match(path) \
        or path[0] == '#' \
        or os.path.isabs(path) \
        or CONF['sourcefile'] in [STDIN, MODULEIN] \
        or CONF['outfile'] in [STDOUT, MODULEOUT]:
        return path

    # Make sure the input path is relative to the correct source file.
    # The path may be different from original source file when using %!include
    inputpath = PathMaster().join(os.path.dirname(CONF['currentsourcefile']), path)

    # Now adjust the inputpath to be reachable from the output folder
    return PathMaster().relpath(inputpath, os.path.dirname(CONF['outfile']))


def fix_css_out_path(config):
    """
    Fix CSS files path to be reached from the output folder (issue 71)

    Needed when the output file is in a different folder than the sources.
    This will affect the HTML's <link rel="stylesheet"> header tag.

    Leave the path untouched when:
    - not using --fix-path
    - path is an URL
    - path is absolute
    - infile is STDIN
    - outfile is STDOUT

    Note: Keep this rules in sync with fix_relative_path()
    """

    # No CSS files
    if not config.get('style'):
        return None

    # Defaults to user-typed paths
    default = config['style'][:]

    if not config['fix-path'] \
        or config['sourcefile'] in [STDIN, MODULEIN] \
        or config['outfile'] in [STDOUT, MODULEOUT]:
        return default

    # Sanity
    if len(config['style']) != len(config['stylepath']):
        Error("stylepath corrupted. Sorry, this shouldn't happen :(")

    # The stylepath paths are relative to the INPUT file folder.
    # Now we must make them relative to the OUTPUT file folder.
    stylepath_out = []
    for (userpath, fixedpath) in zip(config['style'], config['stylepath']):
        if os.path.isabs(userpath):
            # Never fix user-typed absolute paths
            path = userpath
        else:
            path = PathMaster().relpath(fixedpath, os.path.dirname(config['outfile']))
        stylepath_out.append(path)
    return stylepath_out


def beautify_me(name, font, line):
    "where name is: bold, italic, underline or strike"

    # Exception: Doesn't parse an horizontal bar as strike
    if name == 'strike' and regex['bar'].search(line):
        return line

    open_ = TAGS['%sOpen' % font]
    close = TAGS['%sClose' % font]
    txt = r'%s\1%s' % (open_, close)
    line = regex[font].sub(txt, line)
    return line


def get_tagged_link(label, url):
    ret = ''
    target = CONF['target']
    image_re = regex['img']

    # Set link type
    if regex['email'].match(url):
        linktype = 'email'
    else:
        linktype = 'url'

    # Escape specials from TEXT parts
    label = doEscape(target, label)

    # Escape specials from link URL
    if not rules['linkable'] or rules['escapeurl']:
        url = doEscape(target, url)

    # Adding protocol to guessed link
    guessurl = ''
    if linktype == 'url' and \
       re.match('(?i)' + regex['_urlskel']['guess'], url):
        if url[0] in 'Ww':
            guessurl = 'http://' + url
        else:
            guessurl = 'ftp://' + url

        # Not link aware targets -> protocol is useless
        if not rules['linkable']:
            guessurl = ''

    # Simple link (not guessed)
    if not label and not guessurl:
        if CONF['mask-email'] and linktype == 'email':
            # Do the email mask feature (no TAGs, just text)
            url = url.replace('@', ' (a) ')
            url = url.replace('.', ' ')
            url = "<%s>" % url
            if rules['linkable']:
                url = doEscape(target, url)
            ret = url
        else:
            # Just add link data to tag
            tag = TAGS[linktype]
            ret = regex['x'].sub(url, tag)

    # Named link or guessed simple link
    else:
        # Adjusts for guessed link
        if not label:
            label = url         # no protocol
        if guessurl:
            url = guessurl      # with protocol

        # Image inside link!
        if image_re.match(label):
            if rules['imglinkable']:  # get image tag
                label = parse_images(label)
            else:                     # img@link !supported
                img_path = image_re.match(label).group(1)
                label = "(%s)" % fix_relative_path(img_path)

        if TARGET == 'aat' and not CONF['slides'] and not CONF['web'] and not CONF['spread'] and not CONF['toc-only']:
            url_unmasked = MASK.undo(url)
            if url_unmasked not in AA_MARKS:
                AA_MARKS.append(url_unmasked)
            url = str(AA_MARKS.index(url_unmasked) + 1)

        # Putting data on the right appearance order
        if rules['labelbeforelink'] or not rules['linkable']:
            urlorder = [label, url]   # label before link
        else:
            urlorder = [url, label]   # link before label

        ret = TAGS["%sMark" % linktype]

        # Exception: tag for anchor link is different from the link tag
        if url.startswith('#') and TAGS['urlMarkAnchor']:
            ret = TAGS['urlMarkAnchor']

        # Add link data to tag (replace \a's)
        for data in urlorder:
            ret = regex['x'].sub(data, ret, 1)

        if TARGET == 'rst' and '.. image::' in label:
            ret = label[:-2] + TAGS['urlImg'] + url + label[-2:]

    return ret


def parse_deflist_term(line):
    "Extract and parse definition list term contents"
    img_re = regex['img']
    term   = regex['deflist'].search(line).group(3)

    # Mask image inside term as (image.jpg), where not supported
    if not rules['imgasdefterm'] and img_re.search(term):
        while img_re.search(term):
            imgfile = img_re.search(term).group(1)
            term = img_re.sub('(%s)' % imgfile, term, 1)

    #TODO tex: escape ] on term. \], \rbrack{} and \verb!]! don't work :(
    return term


def get_image_align(line):
    "Return the image (first found) align for the given line"

    # First clear marks that can mess align detection
    line = re.sub(SEPARATOR + '$', '', line)  # remove deflist sep
    line = re.sub('^' + SEPARATOR, '', line)  # remove list sep
    line = re.sub('^[\t]+'       , '', line)  # remove quote mark

    # Get image position on the line
    m = regex['img'].search(line)
    ini = m.start()
    head = 0
    end = m.end()
    tail = len(line)

    # The align detection algorithm
    if   ini == head and end != tail:
        align = 'left'      # ^img + text$
    elif ini != head and end == tail:
        align = 'right'     # ^text + img$
    else:
        align = 'center'    # default align

    # Some special cases
    if BLOCK.isblock('table'):
        align = 'center'    # ignore when table
#   if TARGET == 'mgp' and align == 'center': align = 'center'

    return align


# Reference: http://www.iana.org/assignments/character-sets
# http://www.drclue.net/F1.cgi/HTML/META/META.html
def get_encoding_string(enc, target):
    if not enc:
        return ''
    if target == 'texs':
        target = 'tex'
    # Target specific translation table
    translate = {
        'tex': {
            # missing: ansinew , applemac , cp437 , cp437de , cp865
            'utf-8'       : 'utf8',
            'us-ascii'    : 'ascii',
            'windows-1250': 'cp1250',
            'windows-1252': 'cp1252',
            'ibm850'      : 'cp850',
            'ibm852'      : 'cp852',
            'iso-8859-1'  : 'latin1',
            'iso-8859-2'  : 'latin2',
            'iso-8859-3'  : 'latin3',
            'iso-8859-4'  : 'latin4',
            'iso-8859-5'  : 'latin5',
            'iso-8859-9'  : 'latin9',
            'koi8-r'      : 'koi8-r'
        },
        'rtf': {
            'utf-8'       : 'utf8',
        }
    }
    # Normalization
    enc = re.sub('(?i)(us[-_]?)?ascii|us|ibm367', 'us-ascii'  , enc)
    enc = re.sub('(?i)(ibm|cp)?85([02])'        , 'ibm85\\2'  , enc)
    enc = re.sub('(?i)(iso[_-]?)?8859[_-]?'     , 'iso-8859-' , enc)
    enc = re.sub('iso-8859-($|[^1-9]).*'        , 'iso-8859-1', enc)
    # Apply translation table
    try:
        enc = translate[target][enc.lower()]
    except:
        pass
    return enc


##############################################################################
##MerryChristmas,IdontwanttofighttonightwithyouImissyourbodyandIneedyourlove##
##############################################################################


def process_source_file(file_='', noconf=0, contents=[]):
    """
    Find and Join all the configuration available for a source file.
    No sanity checking is done on this step.
    It also extracts the source document parts into separate holders.

    The config scan order is:
        1. The user configuration file (i.e. $HOME/.txt2tagsrc)
        2. The source document's CONF area
        3. The command line options

    The return data is a tuple of two items:
        1. The parsed config dictionary
        2. The document's parts, as a (head, conf, body) tuple

    All the conversion process will be based on the data and
    configuration returned by this function.
    The source files is read on this step only.
    """
    if contents:
        source = SourceDocument(contents=contents)
    else:
        source = SourceDocument(file_)
    head, conf, body = source.split()
    Message(_("Source document contents stored"), 2)
    if not noconf:
        # Read document config
        source_raw = source.get_raw_config()
        # Join all the config directives found, then parse it
        full_raw = RC_RAW + source_raw + CMDLINE_RAW
        Message(_("Parsing and saving all config found (%03d items)") % (len(full_raw)), 1)
        full_parsed = ConfigMaster(full_raw).parse()
        # Add manually the filename to the conf dic
        if contents:
            full_parsed['sourcefile'] = MODULEIN
            full_parsed['currentsourcefile'] = MODULEIN
            full_parsed['infile'] = MODULEIN
            full_parsed['outfile'] = MODULEOUT
        else:
            full_parsed['sourcefile'] = file_
            full_parsed['currentsourcefile'] = file_
        # Maybe should we dump the config found?
        if full_parsed.get('dump-config'):
            dumpConfig(source_raw, full_parsed)
            Quit()
        # The user just want to know a single config value (hidden feature)
        #TODO pick a better name than --show-config-value
        elif full_parsed.get('show-config-value'):
            config_value = full_parsed.get(full_parsed['show-config-value'])
            if config_value:
                if type(config_value) == type([]):
                    print '\n'.join(config_value)
                else:
                    print config_value
            Quit()
        # Okay, all done
        Debug("FULL config for this file: %s" % full_parsed, 1)
    else:
        full_parsed = {}
    return full_parsed, (head, conf, body)


def get_infiles_config(infiles):
    """
    Find and Join into a single list, all configuration available
    for each input file. This function is supposed to be the very
    first one to be called, before any processing.
    """
    return map(process_source_file, infiles)


def convert_this_files(configs):
    global CONF
    for myconf, doc in configs:                 # multifile support
        target_toc  = []
        target_body = []
        target_foot = []
        source_head, source_conf, source_body = doc
        myconf = ConfigMaster().sanity(myconf)

        if myconf['target'] in ['aat', 'txt', 'rst', 'mgp'] and myconf['encoding'].lower() == 'utf-8':
            decode_head, decode_body = [], []
            try:
                for line in source_head:
                    decode_head.append(line.decode('utf-8'))
                for line in source_body:
                    decode_body.append(line.decode('utf-8'))
                source_head, source_body = decode_head, decode_body
            except:
                myconf['encoding'] = 'not_utf-8'
                myconf = ConfigMaster().sanity(myconf)

        # Save header info for %%header1..3 macros
        if not source_head:
            myconf['header1'] = ''
            myconf['header2'] = ''
            myconf['header3'] = ''
        else:
            myconf['header1'] = source_head[0]
            myconf['header2'] = source_head[1]
            myconf['header3'] = source_head[2]

        # Parse the full marked body into tagged target
        first_body_line = (len(source_head) or 1) + len(source_conf) + 1
        Message(_("Composing target Body"), 1)
        target_body, marked_toc = convert(source_body, myconf, firstlinenr=first_body_line)

        # If dump-source, we're done
        if myconf['dump-source']:
            for line in source_head + source_conf + target_body:
                print line
            return

        # Close the last slide
        if myconf['slides'] and not myconf['toc-only'] and myconf['target'] == 'aat':
            n = (myconf['height'] - 1) - (AA_COUNT % (myconf['height'] - 1) + 1)
            if myconf['web']:
                target_body = target_body + ([''] * n) + [aa_line(AA['bar2'], myconf['width']) + '</pre></section>']
            else:
                target_body = target_body + ([''] * n) + [aa_line(AA['bar2'], myconf['width'])]
            if myconf['qa']:
                n_before = (myconf['height'] - 24) / 2
                n_after = myconf['height'] - 24 - n_before
                head = aa_slide(_("Q&A"), AA['bar2'], myconf['width'], myconf['web'])
                end_qa = aa_line(AA['bar2'], myconf['width'])
                if myconf['web']:
                    end_qa = end_qa + '</pre></section>'
                if myconf['height'] > 23 and myconf['width'] > 22:
                    target_body = target_body + head + [''] * n_before + [(myconf['width'] - 23) / 2 * ' ' + line for line in AA_QA] + [''] * n_after + [end_qa]
                else:
                    target_body = target_body + head + [''] * (myconf['height'] - 7) + [end_qa]

        # Uncomment the three next lines and specify your qa_image to use --qa option with the mgp target
        #if myconf['target'] == 'mgp' and myconf['qa']:
        #        qa_image = path_to_your_qa_image
        #        target_body = target_body + ['%page', '', 'Q&A', '', '%center', '%newimage "' + qa_image + '"', '']

        if myconf['target'] == 'aat' and not myconf['slides'] and not myconf['web'] and not myconf['spread'] and not myconf['toc-only']:
            for i, url in enumerate(AA_MARKS):
                target_body.extend(aa_wrap('[' + str(i + 1) + '] ' + url, myconf['width'], myconf['web']))

        # Compose the target file Footer
        Message(_("Composing target Footer"), 1)
        target_foot = doFooter(myconf)

        # Make TOC (if needed)
        Message(_("Composing target TOC"), 1)
        tagged_toc  = toc_tagger(marked_toc, myconf)
        target_toc  = toc_formatter(tagged_toc, myconf)
        target_body = toc_inside_body(target_body, target_toc, myconf)
        if not AUTOTOC and not myconf['toc-only']:
            target_toc = []
        # Finally, we have our document
        myconf['fullBody'] = target_toc + target_body + target_foot

        # Compose the target file Headers
        #TODO escape line before?
        #TODO see exceptions by tex and mgp
        Message(_("Composing target Headers"), 1)
        outlist = doHeader(source_head, myconf)

        if myconf['target'] == 'aat' and myconf['web'] and not myconf['headers']:
            outlist = ['<pre>'] + outlist + ['</pre>']

        # If on GUI, abort before finish_him
        # If module, return finish_him as list
        # Else, write results to file or STDOUT
        if GUI:
            return outlist, myconf
        elif myconf.get('outfile') == MODULEOUT:
            return finish_him(outlist, myconf), myconf
        else:
            Message(_("Saving results to the output file"), 1)
            finish_him(outlist, myconf)


def getImageInfo(filename):
    "Get image type, dimensions, and pixel size."
    try:
        f = open(filename, 'rb')
        head = f.read(2)
        # Default DPI (if none specified in image metadata) of 72
        dpix = 72
        dpiy = 72
        if head == '\x89\x50':  # PNG format image
            imgtype = 'png'
            magic, length, chunkid, width, height, bit_depth, colour_type = struct.unpack('!6sI4sIIBBxxxxxxx', f.read(31))
            if (magic == '\x4e\x47\x0d\x0a\x1a\x0a') and \
                    (length > 0) and \
                    (chunkid == 'IHDR'):
                        chunk = f.read(8)
                        # Now to find the DPI / Pixel dimensions
                        while chunk:
                            length, chunkid = struct.unpack('!I4s', chunk)
                            if chunkid == 'pHYs':
                                dpix, dpiy, units = struct.unpack('!IIbxxxx', f.read(13))
                                if units == 1:
                                    # PNG images have pixel dimensions in pixels per meter,
                                    # convert to pixels per inch
                                    dpix = dpix * 0.0257
                                    dpiy = dpiy * 0.0257
                                else:
                                    # No pixel dimensions, set back to default
                                    dpix = 72
                                    dpiy = 72
                            elif chunkid == 'IDAT':
                                data = f.read(length)
                                f.seek(4, 1)
                            else:
                                f.seek(length + 4, 1)
                            chunk = f.read(8)
                        f.close()
                        return imgtype, width, height, bit_depth, colour_type, dpix, dpiy, data
            else:
                f.close()
                Error('Cannot embed PNG image ' + filename + '. Badly formatted.')

        elif head == '\xff\xd8':  # JPG format image
            imgtype = 'jpeg'
            # Jpeg format is insane. The image size chunk could be anywhere,
            # so we need to search the whole file.
            b = f.read(1)
            while (b != ''):
                # Each chunk in a jpeg file is delimited by at least one
                # \xff character, and possibly more for padding. Seek past 'em
                while (b != '\xff'):
                    b = f.read(1)
                while (b == '\xff'):
                    b = f.read(1)

                # Past them, now to find the type of this particular chunk
                if b == '\xe0':
                    # Header, should be the first chunk in the file.
                    size = struct.unpack('!H', f.read(2))
                    if f.read(5) == 'JFIF\0':
                        # This Jpeg has JFIF metadata, which should include pixel dimensions
                        units, dpix, dpiy = struct.unpack('!xxbHH', f.read(7))
                        if units == 0:
                            # No exact pixel dimensions, just return defaults
                            dpix = 72
                            dpiy = 72
                        elif units == 2:
                            # Pixel dimensions in pixels per centimeter, so convert.
                            #  units == 1 would mean the field is in pixels per inch,
                            #  so no conversion needed in that case.
                            dpix = dpix * 2.57
                            dpiy = dpiy * 2.57
                        f.seek(size[0] - 12, 1)
                    else:
                        # No metadata, just keep the default 72 dpi and
                        # find the image size.
                        f.seek(size[0] - 7, 1)
                    b = f.read(1)
                elif (b >= '\xc0') and (b <= '\xc3'):
                    # Image info chunk, which should include size in pixels
                    height, width = struct.unpack('!xxxHH', f.read(7))
                    f.close()
                    return imgtype, width, height, 'bit_depth', 'colour_type', dpix, dpiy, 'data'

                else:
                    # Wrong chunk type. Get length of chunk and skip to the next one
                    size = struct.unpack('!H', f.read(2))
                    f.seek(size[0] - 2, 1)
                    b = f.read(1)
            f.close()
            # No size information found
            Error('Cannot embed JPG image ' + filename + '. Badly formatted.')
        else:  # Not a supported image format
            f.close()
            Error('Cannot embed image ' + filename + '. Unsupported format.')
    except:
        Error('Cannot embed image ' + filename + '. Unable to open file.')

RTFIMGID = 1000  # Needed so each embedded image can have a unique ID number


def embedImage(filename):
    mytype, width, height, bit_depth, colour_type, dpix, dpiy, data = getImageInfo(filename)
    if TARGET in ('html','xhtml','xhtmls','html5', 'htmls'):

        ## return a data uri with the image embed.
        ## see: http://en.wikipedia.org/wiki/Data_URI_scheme

        line = "data: image/%s;base64,"%mytype
        line = line+base64.b64encode(file(filename).read())
        return line

    elif TARGET == 'rtf':
        global RTFIMGID
        RTFIMGID += 1
        # Defalt DPI of images.
        if dpix == 0 and dpiy == 0:
            dpix = 72
            dpiy = 72
        try:
            filein = open(filename, 'rb')
            # RTF tags for an embedded bitmap image, with size in pixels and intended display size in twips.
            # Size and dpi converted to float for division, as by default Python 2 will return an integer,
            # probably truncated to 0 in most cases. This behavior is changed in Python3.
            line = r'\\%sblip\\picw%d\\pich%d\\picwgoal%d\\picscalex100\\pichgoal%d\\picscaley100\\bliptag%d{\\*\\blipuid%016x}' \
                    % (mytype, width, height, int(float(width) / float(dpix) * 1440.0), int(float(height) / float(dpiy) * 1440.0), RTFIMGID, RTFIMGID)
            line = line + filein.read().encode('hex')
            filein.close()
            return line
        except:
            Error('Unable to embed image: ' + filename)

    elif TARGET == 'aat':
        if mytype not in ['png']:
            Error("Cannot embed image " + filename + ". Unsupported " + mytype + " format with Ascii Art targets. You should use PNG.")
        if colour_type == 3:
            Error("Cannot embed image " + filename + ". Unsupported indexed-colour image type with Ascii Art targets. You should use greyscale or RGB.")
        if bit_depth not in [8]:
            Error("Cannot embed image " + filename + ". Unsupported bit depth with Ascii Art targets. You should use 8-bit pixels.")
        import zlib
        decomp = zlib.decompress(data)
        n_byte = n_byte_alpha = (colour_type % 4 + 1)
        if colour_type in [4, 6]:
            n_byte_alpha = n_byte + 1
        image = []
        end_line = n_byte_alpha * width + 1
        while decomp:
            line = decomp[1:end_line]
            line_img = []
            while line:
                if n_byte == 1:
                    L, = struct.unpack('!B', line[:n_byte])
                else:
                    R, G, B = struct.unpack('!BBB', line[:n_byte])
                    # ITU-R 601-2 luma transform
                    L = int(0.299 * R + 0.587 * G + 0.114 * B)
                line_img.append(L)
                line = line[n_byte_alpha:]
            image.append(line_img)
            decomp = decomp[end_line:]
        return aa_image(image)


def parse_images(line):
    "Tag all images found"
    global CONF
    while regex['img'].search(line):
        txt = regex['img'].search(line).group(1)
        tag = TAGS['img']

        txt = fix_relative_path(txt)

        # If target supports image alignment, here we go
        if rules['imgalignable']:

            align = get_image_align(line)         # right
            align_name = align.capitalize()       # Right

            # The align is a full tag, or part of the image tag (~A~)
            if TAGS['imgAlign' + align_name]:
                tag = TAGS['imgAlign' + align_name]
            else:
                align_tag = TAGS['_imgAlign' + align_name]
                tag = regex['_imgAlign'].sub(align_tag, tag, 1)

            # Dirty fix to allow centered solo images
            if align == 'center' and TARGET in ('html', 'xhtml'):
                rest = regex['img'].sub('', line, 1)
                if re.match('^\s+$', rest):
                    tag = "<center>%s</center>" % tag
            if align == 'center' and TARGET == 'xhtmls':
                rest = regex['img'].sub('', line, 1)
                if re.match('^\s+$', rest):
                    ## original (not validating):
                    # tag = '<div style="text-align: center;">%s</div>' % tag
                    ## dirty fix:
                    # tag = '</p><div style="text-align: center;">%s</div><p>' % tag
                    ## will validate, though img won't be centered:
                    tag = '%s' % tag

        # Rtf needs some tweaking
        if TARGET == 'rtf' and not CONF.get('embed-images'):
            # insert './' for relative paths if needed
            if not re.match(r':/|:\\', txt):
                tag = regex['x'].sub('./\a', tag, 1)
            # insert image filename an extra time for readers that don't grok linked images
            tag = regex['x'].sub(txt, tag, 1)

        if TARGET in  ['tex', 'texs']:
            tag = re.sub(r'\\b', r'\\\\b', tag)
            txt = txt.replace('_', 'vvvvTexUndervvvv')

        if CONF.get('embed-images'):
            # Embedded images find files from the same location as linked images,
            # for consistant behaviour.
            basedir = os.path.dirname(CONF.get('outfile'))
            fullpath = PathMaster().join(basedir, txt)
            txt = embedImage(fullpath)
            if TARGET == 'aat':
                return txt

        if TARGET == 'aat' and CONF['slides'] and CONF['web']:
            global AA_IMG
            mytype, width, height, bit_depth, colour_type, dpix, dpiy, data = getImageInfo(txt)
            AA_IMG = int((height / 600.0) * (CONF['height'] - 1))

        # Ugly hack to avoid infinite loop when target's image tag contains []
        tag = tag.replace('[', 'vvvvEscapeSquareBracketvvvv')

        line = regex['img'].sub(tag, line, 1)
        line = regex['x'].sub(txt, line, 1)

        if TARGET == 'rst':
            line = line.split('ENDIMG')[0] + line.split('ENDIMG')[1].strip()

    return line.replace('vvvvEscapeSquareBracketvvvv', '[')


def add_inline_tags(line):
    # We can't use beauti.capitalize() for the beautifiers, because
    # 'i'.capitalize != 'I' for turkish locales.
    for beauti, font in [('bold', 'fontBold'), ('italic', 'fontItalic'),
                          ('underline', 'fontUnderline'), ('strike', 'fontStrike')]:
        if regex[font].search(line):
            line = beautify_me(beauti, font, line)

    line = parse_images(line)
    return line


def get_include_contents(file_, path=''):
    "Parses %!include: value and extract file contents"
    ids = {'`': 'verb', '"': 'raw', "'": 'tagged'}
    id_ = 't2t'
    # Set include type and remove identifier marks
    mark = file_[0]
    if mark in ids:
        if file_[:2] == file_[-2:] == mark * 2:
            id_ = ids[mark]      # set type
            file_ = file_[2:-2]  # remove marks
    # Handle remote dir execution
    filepath = PathMaster().join(path, file_)
    # Read included file contents
    lines = Readfile(filepath, remove_linebreaks=1)
    # Default txt2tags marked text, just BODY matters
    if id_ == 't2t':
        lines = get_file_body(filepath)
        lines.insert(0, '%%!currentfile: %s' % (filepath))
        # This appears when included hit EOF with verbatim area open
        #lines.append('%%INCLUDED(%s) ends here: %s' % (id_, file_))
    return id_, lines


def set_global_config(config):
    global CONF, TAGS, regex, rules, TARGET
    CONF   = config
    rules  = getRules(CONF)
    TAGS   = getTags(CONF)
    regex  = getRegexes()
    TARGET = config['target']  # save for buggy functions that need global

    if rules.get('spread'):
        # Python math functions
        exec('from math import *', globals())
        # LibreOffice compatibility
        global SIN, COS, TAN, ASIN, ACOS, ATAN, SINH, COSH, TANH
        SIN = sin
        COS = cos
        TAN = tan
        ASIN = asin
        ACOS = acos
        ATAN = atan
        SINH = sinh
        COSH = cosh
        TANH = tanh

def convert(bodylines, config, firstlinenr=1):
    global BLOCK, TITLE, MASK

    set_global_config(config)

    target = config['target']
    BLOCK = BlockMaster()
    MASK  =  MaskMaster()
    TITLE = TitleMaster()

    ret = []
    dump_source = []
    f_lastwasblank = 0

    # Compiling all PreProc regexes
    pre_filter = compile_filters(
        CONF['preproc'], _('Invalid PreProc filter regex'))

    # Let's mark it up!
    linenr = firstlinenr - 1
    lineref = 0
    while lineref < len(bodylines):
        # Defaults
        results_box = ''

        untouchedline = bodylines[lineref]
        dump_source.append(untouchedline)

        line = re.sub('[\n\r]+$', '', untouchedline)   # del line break

        # Apply PreProc filters
        if pre_filter:
            errmsg = _('Invalid PreProc filter replacement')
            for rgx, repl in pre_filter:
                try:
                    line = rgx.sub(repl, line)
                except:
                    Error("%s: '%s'" % (errmsg, repl))

        line = maskEscapeChar(line)                  # protect \ char
        linenr  += 1
        lineref += 1

        Debug(repr(line), 2, linenr)  # heavy debug: show each line

        #------------------[ Comment Block ]------------------------

        # We're already on a comment block
        if BLOCK.block() == 'comment':

            # Closing comment
            if regex['blockCommentClose'].search(line):
                ret.extend(BLOCK.blockout() or [])
                continue

            # Normal comment-inside line. Ignore it.
            continue

        # Detecting comment block init
        if regex['blockCommentOpen'].search(line) \
           and BLOCK.block() not in BLOCK.exclusive:
            ret.extend(BLOCK.blockin('comment'))
            continue

        #-------------------------[ Tagged Text ]----------------------

        # We're already on a tagged block
        if BLOCK.block() == 'tagged':

            # Closing tagged
            if regex['blockTaggedClose'].search(line):
                ret.extend(BLOCK.blockout())
                continue

            # Normal tagged-inside line
            BLOCK.holdadd(line)
            continue

        # Detecting tagged block init
        if regex['blockTaggedOpen'].search(line) \
           and BLOCK.block() not in BLOCK.exclusive:
            ret.extend(BLOCK.blockin('tagged'))
            continue

        # One line tagged text
        if regex['1lineTagged'].search(line) \
           and BLOCK.block() not in BLOCK.exclusive:
            ret.extend(BLOCK.blockin('tagged'))
            line = regex['1lineTagged'].sub('', line)
            BLOCK.holdadd(line)
            ret.extend(BLOCK.blockout())
            continue

        #-------------------------[ Raw Text ]----------------------

        # We're already on a raw block
        if BLOCK.block() == 'raw':

            # Closing raw
            if regex['blockRawClose'].search(line):
                ret.extend(BLOCK.blockout())
                continue

            # Normal raw-inside line
            BLOCK.holdadd(line)
            continue

        # Detecting raw block init
        if regex['blockRawOpen'].search(line) \
           and BLOCK.block() not in BLOCK.exclusive:
            ret.extend(BLOCK.blockin('raw'))
            continue

        # One line raw text
        if regex['1lineRaw'].search(line) \
           and BLOCK.block() not in BLOCK.exclusive:
            ret.extend(BLOCK.blockin('raw'))
            line = regex['1lineRaw'].sub('', line)
            BLOCK.holdadd(line)
            ret.extend(BLOCK.blockout())
            continue

        #------------------------[ Verbatim  ]----------------------

        #TIP We'll never support beautifiers inside verbatim

        # Closing table mapped to verb
        if BLOCK.block() == 'verb' \
           and BLOCK.prop('mapped') == 'table' \
           and not regex['table'].search(line):
            ret.extend(BLOCK.blockout())

        # We're already on a verb block
        if BLOCK.block() == 'verb':

            # Closing verb
            if regex['blockVerbClose'].search(line):
                ret.extend(BLOCK.blockout())
                continue

            # Normal verb-inside line
            BLOCK.holdadd(line)
            continue

        # Detecting verb block init
        if regex['blockVerbOpen'].search(line) \
           and BLOCK.block() not in BLOCK.exclusive:
            ret.extend(BLOCK.blockin('verb'))
            f_lastwasblank = 0
            continue

        # One line verb-formatted text
        if regex['1lineVerb'].search(line) \
           and BLOCK.block() not in BLOCK.exclusive:
            ret.extend(BLOCK.blockin('verb'))
            line = regex['1lineVerb'].sub('', line)
            BLOCK.holdadd(line)
            ret.extend(BLOCK.blockout())
            f_lastwasblank = 0
            continue

        # Tables are mapped to verb when target is not table-aware
        if not rules['tableable'] and regex['table'].search(line):
            if not BLOCK.isblock('verb'):
                ret.extend(BLOCK.blockin('verb'))
                BLOCK.propset('mapped', 'table')
                BLOCK.holdadd(line)
                continue

        #---------------------[ blank lines ]-----------------------

        if regex['blankline'].search(line):

            # Close open paragraph
            if BLOCK.isblock('para'):
                ret.extend(BLOCK.blockout())
                f_lastwasblank = 1
                continue

            # Close all open tables
            if BLOCK.isblock('table'):
                ret.extend(BLOCK.blockout())
                f_lastwasblank = 1
                continue

            # Close all open quotes
            while BLOCK.isblock('quote'):
                ret.extend(BLOCK.blockout())

            # Closing all open lists
            if f_lastwasblank:          # 2nd consecutive blank
                if BLOCK.block().endswith('list'):
                    BLOCK.holdaddsub('')   # helps parser
                while BLOCK.depth:  # closes list (if any)
                    ret.extend(BLOCK.blockout())
                continue            # ignore consecutive blanks

            # Paragraph (if any) is wanted inside lists also
            if BLOCK.block().endswith('list'):
                BLOCK.holdaddsub('')

            f_lastwasblank = 1
            continue

        #---------------------[ special ]---------------------------

        if regex['special'].search(line):

            targ, key, val = ConfigLines().parse_line(line, None, target)
            global MAILING

            if key:
                Debug("Found config '%s', value '%s'" % (key, val), 1, linenr)
            else:
                Debug('Bogus Special Line', 1, linenr)

            # %!include command
            if key == 'include':

                # The current path is always relative to the file where %!include appeared
                incfile = val
                incpath = os.path.dirname(CONF['currentsourcefile'])
                fullpath = PathMaster().join(incpath, incfile)

                # Infinite loop detection
                if os.path.abspath(fullpath) == os.path.abspath(CONF['currentsourcefile']):
                    Error("%s: %s" % (_('A file cannot include itself (loop!)'), fullpath))

                inctype, inclines = get_include_contents(incfile, incpath)

                # Verb, raw and tagged are easy
                if inctype != 't2t':
                    ret.extend(BLOCK.blockin(inctype))
                    BLOCK.holdextend(inclines)
                    ret.extend(BLOCK.blockout())
                else:
                    # Insert include lines into body
                    #TODO include maxdepth limit
                    bodylines = bodylines[:lineref] + inclines + ['%%!currentfile: %s' % (CONF['currentsourcefile'])] + bodylines[lineref:]
                    # Remove %!include call
                    if CONF['dump-source']:
                        dump_source.pop()

            # %!currentfile command
            elif key == 'currentfile':
                targ, key, val = ConfigLines().parse_line(line, 'currentfile', target)
                if key:
                    Debug("Found config '%s', value '%s'" % (key, val), 1, linenr)
                    CONF['currentsourcefile'] = val
                # This line is done, go to next
                continue
            
            # %!fen command
            # Forsyth-Edward Notation
            elif key == 'fen':

                # Handle options and arguments
                fenopt = FenOptions(val)
                filename = fenopt.get('infile')
                fen_unicode = fenopt.get('unicode')

                if fen_unicode:
                    if CONF['encoding'].lower() != 'utf-8':
                        if not config['encoding']:
                            Error(_("%!fen: Expected an UTF-8 file to use unicode fen option, you could set %!encoding: UTF-8"))
                        else: 
                            Error(_("%!fen: Expected an UTF-8 file to use unicode fen option"))
                    unicode_chars = [unichr(char) for char in range(0x2654,0x2660)]
                    uni = dict(zip('KQRBNPkqrbnp', unicode_chars))

                for line in Readfile(filename):
                    board = line.split()[0]
                    for i in range(1, 9):
                        board = board.replace(str(i), i * ' ')
                    if fen_unicode:
                        for piece in uni:
                            board = board.replace(piece, uni[piece])
                    board = board.split('/')
                    table = convert_to_table(board, False, True, True)
                    ret.extend(parse_convert_table(table, rules['tableable'], CONF['target']))
                # This line is done, go to next
                continue
            
            # %!db command
            elif key == 'db':

                try:
                    import sqlite3
                except:
                    Error('No sqlite3 module')

                # Handle options and arguments
                dbopt = DbOptions(val)
                filename = dbopt.get('infile')
                db_query = dbopt.get('query')
                db_borders = dbopt.get('borders')
                db_center = dbopt.get('center')
                db_headers = dbopt.get('headers')
                db_mailing = dbopt.get('mailing')
                if db_mailing:           
                    db_headers = True

                sqlite3.register_converter('NULL', unicode)
                sqlite3.register_converter('INTEGER', unicode)
                sqlite3.register_converter('REAL', unicode)
                sqlite3.register_converter('BLOB', unicode)

                db = sqlite3.connect(filename, detect_types=sqlite3.PARSE_DECLTYPES)
                dbc = db.cursor()

                if db_query:
                    res = dbc.execute(db_query)
                    if db_headers:
                        result = [[[header[0] for header in dbc.description]] + res.fetchall()]
                    else:
                        result = [res.fetchall()]
                else:
                    result = []
                    table_names = dbc.execute("select name from sqlite_master where type='table'").fetchall()
                    for table_name in table_names:
                        res = dbc.execute("select * from " + table_name[0])
                        if db_headers:
                            result.append([[header[0] for header in dbc.description]] + res.fetchall())
                        else:
                            result.append(res.fetchall())

                db.close()

                if not db_mailing:
                    for tab in result:
                        # Convert each DB line to a txt2tags' table line
                        table = convert_to_table(tab, db_headers, db_borders, db_center)
                        # Parse and convert the new table
                        ret.extend(parse_convert_table(table, rules['tableable'], CONF['target']))
                else:
                    if not MAILING and not len(result) > 1:
                        MAILING = result[0]
                    else:
                        Error("Mailing: a document can't be linked to more than one db")

                # This line is done, go to next
                continue

            # %!csv command
            elif key == 'csv':

                # Handle options and arguments
                csvopt = CsvOptions(val)
                filename = csvopt.get('infile')
                csv_separator = csvopt.get('separator')
                csv_quotechar = csvopt.get('quotechar')
                csv_headers = csvopt.get('headers')
                csv_borders = csvopt.get('borders')
                csv_center = csvopt.get('center')
                csv_utf8 = csvopt.get('utf8')
                csv_mailing = csvopt.get('mailing')

                if not filename:
                    Error(_('%!CSV command: Missing CSV file path:') + ' ' + val)

                if csv_separator == 'space':
                    csv_separator = ' '
                elif csv_separator == 'tab':
                    csv_separator = '\t'

                if csv_quotechar:
                    reader = csv.reader(Readfile(filename), delimiter=csv_separator, quotechar=csv_quotechar, quoting=csv.QUOTE_MINIMAL)
                else:
                    reader = csv.reader(Readfile(filename), delimiter=csv_separator, quoting=csv.QUOTE_NONE)

                if csv_utf8: 
                    reader_utf8 = []
                    for line in reader:
                        line_utf8 = []
                        for el in line:
                            line_utf8.append(el.decode('utf-8'))
                        reader_utf8.append(line_utf8)
                    reader = reader_utf8

                # Convert each CSV line to a txt2tags' table line
                # foo,bar,baz -> | foo | bar | baz |
                if not csv_mailing:
                    try:
                        table = convert_to_table(reader, csv_headers, csv_borders, csv_center)
                    except csv.Error, e:
                        Error('CSV: file %s: %s' % (filename, e))
                    else:
                        # Parse and convert the new table
                        ret.extend(parse_convert_table(table, rules['tableable'], CONF['target']))
                else:
                    if not MAILING:
                        MAILING = reader
                    else:
                        Error("Mailing: a document can't be linked to more than one db")

                # This line is done, go to next
                continue

        #---------------------[ dump-source ]-----------------------

        # We don't need to go any further
        if CONF['dump-source']:
            continue

        #---------------------[ Comments ]--------------------------

        # Just skip them (if not macro)
        if regex['comment'].search(line) and not \
           regex['macros'].match(line) and not \
           regex['toc'].match(line):
            continue

        #---------------------[ Triggers ]--------------------------

        # Valid line, reset blank status
        f_lastwasblank = 0

        # Any NOT quote line closes all open quotes
        if BLOCK.isblock('quote') and not regex['quote'].search(line):
            while BLOCK.isblock('quote'):
                ret.extend(BLOCK.blockout())

        # Any NOT table line closes an open table
        if BLOCK.isblock('table') and not regex['table'].search(line):
            ret.extend(BLOCK.blockout())

        #---------------------[ Horizontal Bar ]--------------------

        if regex['bar'].search(line):

            # Bars inside quotes are handled on the Quote processing
            # Otherwise we parse the bars right here
            #
            if not (BLOCK.isblock('quote') or regex['quote'].search(line)) \
                or (BLOCK.isblock('quote') and not rules['barinsidequote']):

                # Close all the opened blocks
                ret.extend(BLOCK.blockin('bar'))

                # Extract the bar chars (- or =)
                m = regex['bar'].search(line)
                bar_chars = m.group(2)

                # Process and dump the tagged bar
                BLOCK.holdadd(bar_chars)
                ret.extend(BLOCK.blockout())
                Debug("BAR: %s" % line, 6)

                # We're done, nothing more to process
                continue

        #---------------------[ Title ]-----------------------------

        if (regex['title'].search(line) or regex['numtitle'].search(line)) \
            and not BLOCK.block().endswith('list'):

            if regex['title'].search(line):
                name = 'title'
            else:
                name = 'numtitle'

            # Close all the opened blocks
            ret.extend(BLOCK.blockin(name))

            # Process title
            TITLE.add(line)
            ret.extend(BLOCK.blockout())

            # We're done, nothing more to process
            continue

        #---------------------[ %%toc ]-----------------------

        # %%toc line closes paragraph
        if BLOCK.block() == 'para' and regex['toc'].search(line):
            ret.extend(BLOCK.blockout())

        #---------------------[ apply masks ]-----------------------

        line = MASK.mask(line)

        #XXX from here, only block-inside lines will pass

        #---------------------[ Quote ]-----------------------------

        if regex['quote'].search(line):

            # Store number of leading TABS
            quotedepth = len(regex['quote'].search(line).group(0))

            # Don't cross depth limit
            maxdepth = rules['quotemaxdepth']
            if maxdepth and quotedepth > maxdepth:
                quotedepth = maxdepth

            # New quote
            if not BLOCK.isblock('quote'):
                ret.extend(BLOCK.blockin('quote'))

            # New subquotes
            while BLOCK.depth < quotedepth:
                BLOCK.blockin('quote')

            # Closing quotes
            while quotedepth < BLOCK.depth:
                ret.extend(BLOCK.blockout())

            # Bar inside quote
            if regex['bar'].search(line) and rules['barinsidequote']:
                tempBlock = BlockMaster()
                tagged_bar = []
                tagged_bar.extend(tempBlock.blockin('bar'))
                tempBlock.holdadd(line)
                tagged_bar.extend(tempBlock.blockout())
                BLOCK.holdextend(tagged_bar)
                continue

        #---------------------[ Lists ]-----------------------------

        # An empty item also closes the current list
        if BLOCK.block().endswith('list'):
            m = regex['listclose'].match(line)
            if m:
                listindent = m.group(1)
                listtype = m.group(2)
                currlisttype = BLOCK.prop('type')
                currlistindent = BLOCK.prop('indent')
                if listindent == currlistindent and \
                   listtype == currlisttype:
                    ret.extend(BLOCK.blockout())
                    continue

        if   regex['list'].search(line) or \
          regex['numlist'].search(line) or \
          regex['deflist'].search(line):

            listindent = BLOCK.prop('indent')
            listids = ''.join(LISTNAMES.keys())
            m = re.match('^( *)([%s]) ' % listids, line)
            listitemindent = m.group(1)
            listtype = m.group(2)
            listname = LISTNAMES[listtype]
            results_box = BLOCK.holdadd

            # Del list ID (and separate term from definition)
            if listname == 'deflist':
                term = parse_deflist_term(line)
                line = regex['deflist'].sub(
                    SEPARATOR + term + SEPARATOR, line)
            else:
                line = regex[listname].sub(SEPARATOR, line)

            # Don't cross depth limit
            maxdepth = rules['listmaxdepth']
            if maxdepth and BLOCK.depth == maxdepth:
                if len(listitemindent) > len(listindent):
                    listitemindent = listindent

            # List bumping (same indent, diff mark)
            # Close the currently open list to clear the mess
            if BLOCK.block().endswith('list') \
               and listname != BLOCK.block() \
               and len(listitemindent) == len(listindent):
                ret.extend(BLOCK.blockout())
                listindent = BLOCK.prop('indent')

            # Open mother list or sublist
            if not BLOCK.block().endswith('list') or \
               len(listitemindent) > len(listindent):
                ret.extend(BLOCK.blockin(listname))
                BLOCK.propset('indent', listitemindent)
                BLOCK.propset('type', listtype)

            # Closing sublists
            while len(listitemindent) < len(BLOCK.prop('indent')):
                ret.extend(BLOCK.blockout())

            # O-oh, sublist before list ("\n\n  - foo\n- foo")
            # Fix: close sublist (as mother), open another list
            if not BLOCK.block().endswith('list'):
                ret.extend(BLOCK.blockin(listname))
                BLOCK.propset('indent', listitemindent)
                BLOCK.propset('type', listtype)

        #---------------------[ Table ]-----------------------------

        #TODO escape undesired format inside table
        #TODO add pm6 target
        if regex['table'].search(line):

            if not BLOCK.isblock('table'):   # first table line!
                ret.extend(BLOCK.blockin('table'))
                BLOCK.tableparser.__init__(line)

            tablerow = TableMaster().parse_row(line)
            BLOCK.tableparser.add_row(tablerow)     # save config

            # Maintain line to unmask and inlines
            # XXX Bug: | **bo | ld** | turns **bo\x01ld** and gets converted :(
            # TODO isolate unmask+inlines parsing to use here
            line = SEPARATOR.join(tablerow['cells'])

        #---------------------[ Paragraph ]-------------------------

        if not BLOCK.block() and \
           not line.count(MASK.tocmask):  # new para!
            ret.extend(BLOCK.blockin('para'))

        ############################################################
        ############################################################
        ############################################################

        #---------------------[ Final Parses ]----------------------

        # The target-specific special char escapes for body lines
        line = doEscape(target, line)

        line = add_inline_tags(line)
        line = MASK.undo(line)

        #---------------------[ Hold or Return? ]-------------------

        ### Now we must choose where to put the parsed line
        #
        if not results_box:
            # List item extra lines
            if BLOCK.block().endswith('list'):
                results_box = BLOCK.holdaddsub
            # Other blocks
            elif BLOCK.block():
                results_box = BLOCK.holdadd
            # No blocks
            else:
                line = doFinalEscape(target, line)
                results_box = ret.append

        results_box(line)

    # EOF: close any open para/verb/lists/table/quotes
    Debug('EOF', 7)
    while BLOCK.block():
        ret.extend(BLOCK.blockout())

    # Maybe close some opened title area?
    if rules['titleblocks']:
        ret.extend(TITLE.close_all())

    # Maybe a major tag to enclose body? (like DIV for CSS)
    if TAGS['bodyOpen']:
        ret.insert(0, TAGS['bodyOpen'])
    if TAGS['bodyClose']:
        ret.append(TAGS['bodyClose'])

    if CONF['toc-only']:
        ret = []
    marked_toc = TITLE.dump_marked_toc(CONF['toc-level'])

    # If dump-source, all parsing is ignored
    if CONF['dump-source']:
        ret = dump_source[:]

    return ret, marked_toc


##############################################################################
################################### GUI ######################################
##############################################################################
#
# Tk help: http://python.org/topics/tkinter/
#    Tuto: http://ibiblio.org/obp/py4fun/gui/tkPhone.html
#          /usr/lib/python*/lib-tk/Tkinter.py
#
# grid table : row=0, column=0, columnspan=2, rowspan=2
# grid align : sticky='n,s,e,w' (North, South, East, West)
# pack place : side='top,bottom,right,left'
# pack fill  : fill='x,y,both,none', expand=1
# pack align : anchor='n,s,e,w' (North, South, East, West)
# padding    : padx=10, pady=10, ipadx=10, ipady=10 (internal)
# checkbox   : offvalue is return if the _user_ deselected the box
# label align: justify=left,right,center

def load_GUI_resources():
    "Load all extra modules and methods used by GUI"
    global Tkinter, tkFileDialog, tkMessageBox
    import Tkinter
    import tkFileDialog
    import tkMessageBox


class Gui:
    "Graphical Tk Interface"
    def __init__(self, conf={}):
        self.root = Tkinter.Tk()    # mother window, come to butthead
        self.root.title(my_name)    # window title bar text
        self.window = self.root     # variable "focus" for inclusion
        self.row = 0                # row count for grid()

        self.action_length = 150    # left column length (pixel)
        self.frame_margin  = 10     # frame margin size  (pixel)
        self.frame_border  = 6      # frame border size  (pixel)

        # The default Gui colors, can be changed by %!guicolors
        self.dft_gui_colors = ['#6c6', 'white', '#cf9', '#030']
        self.gui_colors = []
        self.bg1 = self.fg1 = self.bg2 = self.fg2 = ''

        # On Tk, vars need to be set/get using setvar()/get()
        self.infile  = self.setvar('')
        self.target  = self.setvar('')
        self.target_name = self.setvar('')

        # The checks appearance order
        self.checks = [
            'headers', 'enum-title', 'toc', 'mask-email', 'toc-only', 'stdout'
        ]

        # Creating variables for all checks
        for check in self.checks:
            setattr(self, 'f_' + check, self.setvar(''))

        # Load RC config
        self.conf = {}
        if conf:
            self.load_config(conf)

    def load_config(self, conf):
        self.conf = conf
        self.gui_colors = conf.get('guicolors') or self.dft_gui_colors
        self.bg1, self.fg1, self.bg2, self.fg2 = self.gui_colors
        self.root.config(bd=15, bg=self.bg1)

    ### Config as dic for python 1.5 compat (**opts don't work :( )
    def entry(self, **opts):
        return Tkinter.Entry(self.window, opts)

    def label(self, txt='', bg=None, **opts):
        opts.update({'text': txt, 'bg': bg or self.bg1})
        return Tkinter.Label(self.window, opts)

    def button(self, name, cmd, **opts):
        opts.update({'text': name, 'command': cmd})
        return Tkinter.Button(self.window, opts)

    def check(self, name, checked=0, **opts):
        bg, fg = self.bg2, self.fg2
        opts.update({
            'text': name,
            'onvalue': 1,
            'offvalue': 0,
            'activeforeground': fg,
            'activebackground': bg,
            'highlightbackground': bg,
            'fg': fg,
            'bg': bg,
            'anchor': 'w'
        })
        chk = Tkinter.Checkbutton(self.window, opts)
        if checked:
            chk.select()
        chk.grid(columnspan=2, sticky='w', padx=0)

    def menu(self, sel, items):
        return apply(Tkinter.OptionMenu, (self.window, sel) + tuple(items))

    # Handy auxiliary functions
    def action(self, txt):
        self.label(
            txt,
            fg=self.fg1,
            bg=self.bg1,
            wraplength=self.action_length).grid(column=0, row=self.row)

    def frame_open(self):
        self.window = Tkinter.Frame(
            self.root,
            bg=self.bg2,
            borderwidth=self.frame_border)

    def frame_close(self):
        self.window.grid(
            column=1,
            row=self.row,
            sticky='w',
            padx=self.frame_margin)
        self.window = self.root
        self.label('').grid()
        self.row += 2   # update row count

    def target_name2key(self):
        name = self.target_name.get()
        target = filter(lambda x: TARGET_NAMES[x] == name, TARGETS)
        try   :
            key = target[0]
        except:
            key = ''
        self.target = self.setvar(key)

    def target_key2name(self):
        key = self.target.get()
        name = TARGET_NAMES.get(key) or key
        self.target_name = self.setvar(name)

    def exit(self):
        self.root.destroy()

    def setvar(self, val):
        z = Tkinter.StringVar()
        z.set(val)
        return z

    def askfile(self):
        ftypes = [(_('txt2tags files'), ('*.t2t', '*.txt')), (_('All files'), '*')]
        newfile = tkFileDialog.askopenfilename(filetypes=ftypes)
        if newfile:
            self.infile.set(newfile)
            newconf = process_source_file(newfile)[0]
            newconf = ConfigMaster().sanity(newconf, gui=1)
            # Restate all checkboxes after file selection
            #TODO how to make a refresh without killing it?
            self.root.destroy()
            self.__init__(newconf)
            self.mainwindow()

    def scrollwindow(self, txt='no text!', title=''):
        # Create components
        win    = Tkinter.Toplevel()
        win.title(title)
        frame  = Tkinter.Frame(win)
        scroll = Tkinter.Scrollbar(frame)
        text   = Tkinter.Text(frame, yscrollcommand=scroll.set)
        button = Tkinter.Button(win)
        # Config
        text.insert(Tkinter.END, '\n'.join(txt))
        scroll.config(command=text.yview)
        button.config(text=_('Close'), command=win.destroy)
        button.focus_set()
        # Packing
        text.pack(side='left', fill='both', expand=1)
        scroll.pack(side='right', fill='y')
        frame.pack(fill='both', expand=1)
        button.pack(ipadx=30)

    def runprogram(self):
        global CMDLINE_RAW
        # Prepare
        self.target_name2key()
        infile, target = self.infile.get(), self.target.get()
        # Sanity
        if not target:
            tkMessageBox.showwarning(my_name, _("You must select a target type!"))
            return
        if not infile:
            tkMessageBox.showwarning(my_name, _("You must provide the source file location!"))
            return
        # Compose cmdline
        guiflags = []
        real_cmdline_conf = ConfigMaster(CMDLINE_RAW).parse()
        if 'infile' in real_cmdline_conf:
            del real_cmdline_conf['infile']
        if 'target' in real_cmdline_conf:
            del real_cmdline_conf['target']
        real_cmdline = CommandLine().compose_cmdline(real_cmdline_conf)
        default_outfile = ConfigMaster().get_outfile_name(
            {'sourcefile': infile, 'outfile': '', 'target': target})
        for opt in self.checks:
            val = int(getattr(self, 'f_%s' % opt).get() or "0")
            if opt == 'stdout':
                opt = 'outfile'
            on_config  = self.conf.get(opt) or 0
            on_cmdline = real_cmdline_conf.get(opt) or 0
            if opt == 'outfile':
                if on_config  == STDOUT:
                    on_config = 1
                else:
                    on_config = 0
                if on_cmdline == STDOUT:
                    on_cmdline = 1
                else:
                    on_cmdline = 0
            if val != on_config or (
              val == on_config == on_cmdline and
              opt in real_cmdline_conf):
                if val:
                    # Was not set, but user selected on GUI
                    Debug("user turned  ON: %s" % opt)
                    if opt == 'outfile':
                        opt = '-o-'
                    else:
                        opt = '--%s' % opt
                else:
                    # Was set, but user deselected on GUI
                    Debug("user turned OFF: %s" % opt)
                    if opt == 'outfile':
                        opt = "-o%s" % default_outfile
                    else:
                        opt = '--no-%s' % opt
                guiflags.append(opt)
        cmdline = [my_name, '-t', target] + real_cmdline + guiflags + [infile]
        Debug('Gui/Tk cmdline: %s' % cmdline, 5)
        # Run!
        cmdline_raw_orig = CMDLINE_RAW
        try:
            # Fake the GUI cmdline as the real one, and parse file
            CMDLINE_RAW = CommandLine().get_raw_config(cmdline[1:])
            data = process_source_file(infile)
            # On GUI, convert_* returns the data, not finish_him()
            outlist, config = convert_this_files([data])
            # On GUI and STDOUT, finish_him() returns the data
            result = finish_him(outlist, config)
            # Show outlist in s a nice new window
            if result:
                outlist, config = result
                title = _('%s: %s converted to %s') % (
                    my_name,
                    os.path.basename(infile),
                    config['target'].upper())
                self.scrollwindow(outlist, title)
            # Show the "file saved" message
            else:
                msg = "%s\n\n  %s\n%s\n\n  %s\n%s" % (
                    _('Conversion done!'),
                    _('FROM:'), infile,
                    _('TO:'), config['outfile'])
                tkMessageBox.showinfo(my_name, msg)
        except error:         # common error (windowed), not quit
            pass
        except:               # fatal error (windowed and printed)
            errormsg = getUnknownErrorMessage()
            print errormsg
            tkMessageBox.showerror(_('%s FATAL ERROR!') % my_name, errormsg)
            self.exit()
        CMDLINE_RAW = cmdline_raw_orig

    def mainwindow(self):
        self.infile.set(self.conf.get('sourcefile') or '')
        self.target.set(self.conf.get('target') or _('-- select one --'))
        outfile = self.conf.get('outfile')
        if outfile == STDOUT:                  # map -o-
            self.conf['stdout'] = 1
        if self.conf.get('headers') == None:
            self.conf['headers'] = 1       # map default

        action1 = _("Enter the source file location:")
        action2 = _("Choose the target document type:")
        action3 = _("Some options you may check:")
        action4 = _("Some extra options:")
        checks_txt = {
            'headers'   : _("Include headers on output"),
            'enum-title': _("Number titles (1, 1.1, 1.1.1, etc)"),
            'toc'       : _("Do TOC also (Table of Contents)"),
            'mask-email': _("Hide e-mails from SPAM robots"),

            'toc-only'  : _("Just do TOC, nothing more"),
            'stdout'    : _("Dump to screen (Don't save target file)")
        }
        targets_menu = map(lambda x: TARGET_NAMES[x], TARGETS)

        # Header
        self.label("%s %s" % (my_name.upper(), my_version),
            bg=self.bg2, fg=self.fg2).grid(columnspan=2, ipadx=10)
        self.label(_("ONE source, MULTI targets") + '\n%s\n' % my_url,
            bg=self.bg1, fg=self.fg1).grid(columnspan=2)
        self.row = 2
        # Choose input file
        self.action(action1)
        self.frame_open()
        e_infile = self.entry(textvariable=self.infile, width=25)
        e_infile.grid(row=self.row, column=0, sticky='e')
        if not self.infile.get():
            e_infile.focus_set()
        self.button(_("Browse"), self.askfile).grid(
            row=self.row, column=1, sticky='w', padx=10)
        # Show outfile name, style and encoding (if any)
        txt = ''
        if outfile:
            txt = outfile
            if outfile == STDOUT:
                txt = _('<screen>')
            l_output = self.label(_('Output: ') + txt, fg=self.fg2, bg=self.bg2)
            l_output.grid(columnspan=2, sticky='w')
        for setting in ['style', 'encoding']:
            if self.conf.get(setting):
                name = setting.capitalize()
                val  = self.conf[setting]
                self.label('%s: %s' % (name, val),
                    fg=self.fg2, bg=self.bg2).grid(
                    columnspan=2, sticky='w')
        # Choose target
        self.frame_close()
        self.action(action2)
        self.frame_open()
        self.target_key2name()
        self.menu(self.target_name, targets_menu).grid(
            columnspan=2, sticky='w')
        # Options checkboxes label
        self.frame_close()
        self.action(action3)
        self.frame_open()
        # Compose options check boxes, example:
        # self.check(checks_txt['toc'], 1, variable=self.f_toc)
        for check in self.checks:
            # Extra options label
            if check == 'toc-only':
                self.frame_close()
                self.action(action4)
                self.frame_open()
            txt = checks_txt[check]
            var = getattr(self, 'f_' + check)
            checked = self.conf.get(check)
            self.check(txt, checked, variable=var)
        self.frame_close()
        # Spacer and buttons
        self.label('').grid()
        self.row += 1
        b_quit = self.button(_("Quit"), self.exit)
        b_quit.grid(row=self.row, column=0, sticky='w', padx=30)
        b_conv = self.button(_("Convert!"), self.runprogram)
        b_conv.grid(row=self.row, column=1, sticky='e', padx=30)
        if self.target.get() and self.infile.get():
            b_conv.focus_set()

        # As documentation told me
        if sys.platform.startswith('win'):
            self.root.iconify()
            self.root.update()
            self.root.deiconify()

        self.root.mainloop()


##############################################################################
##############################################################################

def exec_command_line(user_cmdline=[]):
    global CMDLINE_RAW, RC_RAW, DEBUG, VERBOSE, QUIET, GUI, Error

    # Extract command line data
    cmdline_data = user_cmdline or sys.argv[1:]
    CMDLINE_RAW = CommandLine().get_raw_config(cmdline_data, relative=1)
    cmdline_parsed = ConfigMaster(CMDLINE_RAW).parse()
    DEBUG   = cmdline_parsed.get('debug') or 0
    VERBOSE = cmdline_parsed.get('verbose') or 0
    QUIET   = cmdline_parsed.get('quiet') or 0
    GUI     = cmdline_parsed.get('gui') or 0
    infiles = cmdline_parsed.get('infile') or []

    Message(_("Txt2tags %s processing begins") % my_version, 1)

    # The easy ones
    if cmdline_parsed.get('help'):
        Quit(Usage())
    if cmdline_parsed.get('version'):
        Quit(VERSIONSTR)
    if cmdline_parsed.get('targets'):
        listTargets()
        Quit()

    # Multifile haters
    if len(infiles) > 1:
        errmsg = _("Option --%s can't be used with multiple input files")
        for option in NO_MULTI_INPUT:
            if cmdline_parsed.get(option):
                Error(errmsg % option)

    Debug("system platform: %s" % sys.platform)
    Debug("python version: %s" % (sys.version.split('(')[0]))
    Debug("line break char: %s" % repr(LB))
    Debug("command line: %s" % sys.argv)
    Debug("command line raw config: %s" % CMDLINE_RAW, 1)

    # Extract RC file config
    if cmdline_parsed.get('rc') == 0:
        Message(_("Ignoring user configuration file"), 1)
    else:
        rc_file = get_rc_path()
        if os.path.isfile(rc_file):
            Message(_("Loading user configuration file"), 1)
            RC_RAW = ConfigLines(file_=rc_file).get_raw_config()

        Debug("rc file: %s" % rc_file)
        Debug("rc file raw config: %s" % RC_RAW, 1)

    # Get all infiles config (if any)
    infiles_config = get_infiles_config(infiles)

    # Is GUI available?
    # Try to load and start GUI interface for --gui
    if GUI:
        try:
            load_GUI_resources()
            Debug("GUI resources OK (Tk module is installed)")
        except:
            Error(_('Tkinter module not found, so GUI is not available, use CLI instead.'))
        try:
            winbox = Gui()
            Debug("GUI display OK")
            GUI = 1
        except:
            Debug("GUI Error: no DISPLAY")
            GUI = 0

    # User forced --gui, but it's not available
    if cmdline_parsed.get('gui') and not GUI:
        print getTraceback()
        print
        Error(
            "Sorry, I can't run my Graphical Interface - GUI\n"
            "- Check if Python Tcl/Tk module is installed (Tkinter)\n"
            "- Make sure you are in a graphical environment (like X)")

    # Okay, we will use GUI
    if GUI:
        Message(_("We are on GUI interface"), 1)

        # Redefine Error function to raise exception instead sys.exit()
        def Error(msg):
            tkMessageBox.showerror(_('txt2tags ERROR!'), msg)
            raise error

        # If no input file, get RC+cmdline config, else full config
        if not infiles:
            gui_conf = ConfigMaster(RC_RAW + CMDLINE_RAW).parse()
        else:
            try:
                gui_conf = infiles_config[0][0]
            except:
                gui_conf = {}

        # Sanity is needed to set outfile and other things
        gui_conf = ConfigMaster().sanity(gui_conf, gui=1)
        Debug("GUI config: %s" % gui_conf, 5)

        # Insert config and populate the nice window!
        winbox.load_config(gui_conf)
        winbox.mainwindow()

    # Console mode rocks forever!
    else:
        Message(_("We are on Command Line interface"), 1)

        # Called with no arguments, show error
        # TODO#1: this checking should be only in ConfigMaster.sanity()
        if not infiles:
            Error(_('Missing input file (try --help)') + '\n\n' +
            _('Please inform an input file (.t2t) at the end of the command.') + '\n' +
            _('Example:') + ' %s -t html %s' % (my_name, _('file.t2t')))

        convert_this_files(infiles_config)

    Message(_("Txt2tags finished successfully"), 1)

if __name__ == '__main__':
    try:
        exec_command_line()
    except error, msg:
        sys.stderr.write("%s\n" % msg)
        sys.stderr.flush()
        sys.exit(1)
    except SystemExit:
        pass
    except:
        sys.stderr.write(getUnknownErrorMessage())
        sys.stderr.flush()
        sys.exit(1)
    Quit()

# The End.
